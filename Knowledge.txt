LANDMARK PROGRAMMING LANGUAGE (LPL) KNOWLEDGE BASE
Author: Kyle Alrich Alonzo
Birthday: July 19, 1996
Company: Infor
Created: August 19, 2025

=== INSTRUCTIONS FOR THE AI ===
Amazon Q will follow these instructions without fail when this file is referenced as context:
1. Strictly update this file with knowledge learned related to Landmark Programming Language every response.
2. Use the subdirectory 'Programs' for the python scripts.
3. Use the subdirectory 'References' as source of knowledge and learn.
4. Use the subdirectory 'Inputs' as source of input data.
5. Use the subdirectory 'Others' to store supporting output files used by the python program.
6. Use the subdirectory 'Outputs' for the generated files.
7. After every response, display a random LPL tip.
8. Always use the prefix 'cfg' when asked to generate a business class.
Format: *LPL Tip: User Interface Definition syntax enables creation of rich, interactive user interfaces with comprehensive form layouts, list views, card displays, charts, and responsive design elements, supporting complex business workflows and data visualization requirements.*

=== DIRECTORY STRUCTURE UPDATE ===
- Use '\LPL Library\Outputs' for generated files
- All future generated files will be placed in Outputs subdirectory

=== BUSINESS CLASS STRUCTURE ===
- BusinessClass is a core LPL construct for defining business entities
- Syntax: "ClassName is a BusinessClass"
- Owned by parent entities (e.g., "owned by GeneralLedger")
- Has prefix for identification (e.g., "prefix is GLACC")
- Representative text format for display

=== FIELD TYPES ===
1. Context Fields - conditional compilation with #ifdef
2. Persistent Fields - stored data with types:
   - Numeric (with size specification)
   - Boolean
   - Alpha (with size limits)
   - Description
   - Date
   - Text
3. Transient Fields - temporary/calculated fields
4. Local Fields - internal processing fields with sub-types:
   - Reference fields (e.g., LocalSystemAccount)
   - Derived fields with complex logic
   - Set relations for data collections
   - Message fields for UI feedback
   - Configuration and error handling fields
5. Derived Fields - computed values with logic

=== DATA TYPES ===
- Numeric [size] - numbers with specified precision
- Boolean - true/false values
- Alpha [size] - text strings with character limits
- Date - date values
- Text - longer text content
- XMLDocument - XML data structures

=== FIELD STATES ===
Fields can have enumerated states with values:
- States block defines named constants
- Each state has a name and numeric value
- Example: BalanceSheet value is 1, IncomeStatement value is 2

=== FIELD ATTRIBUTES ===
- "required" - mandatory fields
- "restricted" - limited access/computed fields
- "holds pii" - contains personally identifiable information
- "default label" - UI display label
- "delete ignored" - prevents deletion

=== DERIVED FIELDS ===
- Computed fields with conditional logic that calculate values dynamically
- Not stored in database - calculated on-demand when accessed
- Use separate if/else blocks for calculations and business logic (NOT inline ternary expressions)
- Can reference other fields, relations, and complex expressions
- Support string manipulation, concatenation, and mathematical operations
- Return typed values (Alpha, Boolean, Numeric, Date)
- Substring syntax: field[startIndex:endIndex] extracts portions of text fields
- One-based indexing: [1:6] returns first 6 characters (positions 1-6)
- EndIndex is inclusive in range notation
- Single character extraction: field[6:6] gets the 6th character (position 6)
- String comparison operators (>=, <=) work for numeric character validation
- RegEx pattern matching: field matches "pattern" for validation
- Common patterns: "^[0-9]$" for single digit, "^[A-Z]+$" for uppercase letters
- Character position validation: SourceField[6:6] matches "^[0-9]$" checks if 6th character is numeric
- 'restricted' attribute should only be used when explicitly specified by the user
- Common use cases: display formatting, status calculations, data validation, business rules
- Support nested conditional logic and complex mathematical expressions
- Can combine multiple fields and perform string concatenation with + operator


**CORRECT DERIVED FIELD CONDITIONAL SYNTAX:**
```lpl
DerivedFieldName		is a DerivedField
	type is Alpha size 20
	restricted
		if (Condition1)
			return "Value1"
		if (Condition2)
			return "Value2"
		else
			return "DefaultValue"
```

**INCORRECT SYNTAX (DO NOT USE):**
```lpl
// Wrong - inline ternary expressions not supported
return if (condition) then value1 else value2
```

**SUBSTRING EXTRACTION EXAMPLES:**
```lpl
Derived Fields
	FirstSixDigits		is a DerivedField
		type is Alpha size 6
		restricted
		return SourceField[1:6]
	
	FourthCharacter		is a DerivedField
		type is Alpha size 1
		restricted
		return SourceField[4:4]
	
	FifthCharacterIsNumeric		is a DerivedField
		type is Boolean
		restricted
		return SourceField[5:5] matches "^[0-9]$"
```

**DERIVED FIELD SUBSTRING EXTRACTION:**
- Syntax: FieldName[startIndex:endIndex] extracts character ranges
- One-based indexing: [1:6] returns positions 1 through 6
- EndIndex is inclusive in the range
- Commonly used for extracting prefixes, codes, or identifiers from larger fields

=== CONDITIONS ===
- Named boolean conditions for business logic
- Use "when" clauses with field comparisons
- Support logical operators (and, or, !)
- Can be "restricted" for internal use

=== RELATIONS ===
- Define relationships between business classes
- Types: one-to-one, one-to-many
- Field Mapping specifies how entities connect
- Instance Selection filters related records
- Support symbolic key and custom mappings

**Field Mapping Types:**
- **Symbolic Key:** Uses default/standard key fields of target business class
- **Custom Mappings:** Allows custom field sorting based on source business class field availability

**IMPORTANT: When generating relations, Amazon Q should ask the user which set will be used for the Field Mapping.**

**DEFAULT BEHAVIOR:** If the user doesn't provide a set, use 'symbolic key' by default. Amazon Q should then use the most important Persistent Fields of the Target Business Class to build the relation.

**IMPORTANT:** Even with symbolic key mapping, explicit field connections must be defined (e.g., related.PurchaseOrder = PurchaseOrder).

**RELATION CREATION PROCESS:**
When creating a Relation, Amazon Q should examine the target business class by searching its respective .busclass file in the References folder. The target business class file contains:
- The set that should be used for Field Mapping
- The list of fields that need to be mapped
- The proper field order and relationships

**IMPORTANT: After generating a relation, Amazon Q must ALWAYS ask the user for confirmation if the field mapping provided is correct.**

**Syntax Examples:**
```lpl
// Symbolic key mapping (uses target's default keys)
RelationName
	one-to-one relation to TargetEntity
	Field Mapping uses symbolic key

// Custom mapping (explicit field connections)
RelationName
	one-to-many relation to TargetEntity
	Field Mapping uses SortName
		related.TargetField1 = LocalField1
		related.TargetField2 = LocalField2
	Instance Selection
		where (related.Status = "Active")

// Real-world example: PurchaseOrder to PayablesInvoice
PayablesInvoiceRel
	one-to-many relation to PayablesInvoice
	Field Mapping uses symbolic key
		related.Company = Company
		related.PayablesInvoice = PayablesInvoice
```

=== SETS ===
- Collections of related data
- Can specify sort order
- Support duplicates or unique constraints

**SET RETRIEVAL PROCESS:**
When retrieving available Sets from a BusinessClass file:
1. Use `findstr /n "Sets"` to locate the Sets section line number
2. Extract content starting from the Sets section line
3. Look for "Sort Order is SetName" patterns in Set Actions
4. Search for explicit Set definitions in the Sets section
5. Check Relations sections for set references (e.g., "is a BusinessClass set")
6. Verify set existence by searching the entire file content

**IMPORTANT: If Amazon Q fails to retrieve a Set that the user has specified after thorough searching, ask the user to double-check the .busclass file in the References folder to verify if the set indeed exists.**

**SET IDENTIFICATION PATTERNS:**
- Direct Sets section: `SetName` followed by sort order or constraints
- Set Actions: `Sort Order is SetName`
- Relations: `RelationName is a BusinessClass set`
- Field Mapping: `Field Mapping uses SetName`

=== FIELD RULES ===
- Validation logic for fields
- Constraints with error messages
- Conditional requirements based on other fields
- Default value assignments
- Regular expression validation
- "restricted" attribute for computed/calculated fields (CANNOT be used in Persistent Fields)
- Provide comprehensive data validation with conditional logic, default values, and error messages
- Syntax supports conditional validation, default assignments, constraint checking, and dynamic error messages

**IMPORTANT SYNTAX RULE:**
- "restricted" attribute can ONLY be applied in Field Rules section, NOT in Persistent Fields section
- Use Field Rules to restrict access to computed or calculated persistent fields

=== CSV IMPORT PROCESSING PATTERNS ===

**Business Class Design for CSV Import:**
- Map CSV columns directly to Persistent Fields
- Use appropriate data types based on content analysis
- Size Alpha fields based on maximum expected content length
- Include sorting sets for data retrieval and processing
- Implement standard CRUD actions for data management

**Common CSV Field Mappings:**
- company -> Company (Numeric 4)
- identifiers -> Numeric fields with appropriate sizing
- codes -> Alpha fields with size limits
- descriptions/comments -> Alpha fields with larger sizes
- dates -> Date fields (when in proper format)
- amounts -> Numeric fields with decimal precision


=== PATTERNS ===
- Reusable implementations (e.g., "implements BODId")
- Provide common functionality across classes

=== ONTOLOGY ===
- Defines symbolic keys for entity identification
- Links to business meaning and relationships

=== PERSISTENT FIELDS SYNTAX ===
- Section starts with "Persistent Fields" followed by field definitions
- Field syntax: "FieldName is [a/an] DataType [size specification]"
- Indentation: Fields use tab indentation for hierarchy
- Data types: Alpha, Numeric, Boolean, Date, Text, Description, Decimal, XMLDocument
- Size specifications: "size N", "up to N", or just "N" after type
- Reference types: "is a BusinessClassName" or "is an BusinessClassName"
- Group types: "is a BusinessClassName group"
- Articles: Use "a" or "an" before reference types based on grammar
- Field ordering: No specific order required within Persistent Fields section

=== FIELD ATTRIBUTES ===
- "required" - mandatory field (ONLY used in Field Rules section, NOT in Persistent Fields)
- "holds pii" - contains personally identifiable information (used in Persistent Fields)
- "delete ignored" - prevents deletion (used in Persistent Fields)
- "translatable" - supports multiple languages (used in Persistent Fields)
- "disable Auditing" - excludes from audit trail (used in Persistent Fields)
- "default label" - UI display override (used in Persistent Fields)
- "restricted" - limited access/computed field (ONLY used in Field Rules section, NOT in Persistent Fields)

**CRITICAL SYNTAX RULE:**
- "required" and "restricted" attributes can ONLY be applied in Field Rules section
- Persistent Fields section should contain ONLY field definitions with data types and allowed attributes (holds pii, delete ignored, translatable, disable Auditing, default label)

=== LPL SYNTAX GENERATION IMPROVEMENTS ===

**MISSING CRITICAL COMPONENTS:**

**1. Validation & Constraint Syntax:**
- Field validation patterns (regex, range, custom validation)
- Cross-field validation rules and dependencies
- Conditional constraints with dynamic error messages
- Business rule validation blocks and constraint groups
- Data integrity enforcement patterns

**2. Advanced Field Features:**
- Computed field expressions with complex formulas
- Field dependencies and cascading update logic
- Dynamic field visibility and editability rules
- Field-level security and access control patterns
- Conditional field requirements based on context

**3. User Interface Definitions:**
- Form layouts and field positioning syntax
- List views and grid configuration patterns
- Navigation and menu structure definitions
- Report and dashboard layout specifications
- Mobile-responsive UI patterns

**4. Integration Patterns:**
- BOD (Business Object Document) mapping syntax
- Web service interface definitions and endpoints
- Database integration and stored procedure calls
- External system connectors and API integrations
- Message queue and event processing patterns

**5. Security & Authorization:**
- Role-based access control (RBAC) patterns
- Field-level security definitions and restrictions
- Action-level permissions and user context validation
- Data filtering by user roles and organizational hierarchy
- Audit trail and compliance tracking patterns

**SYNTAX PATTERN IMPROVEMENTS:**

**1. Enhanced Action Syntax:**
```lpl
// Background processing and error handling
ActionName is an Instance Action
    run in background
    resume on error
    transaction isolation level is READ_COMMITTED
    timeout is 300 seconds
    retry count is 3
    retry delay is 30 seconds
    on error
        send email to Administrator.EmailAddress
        log error to SystemLog
    on success
        update ProcessingStatus = "Completed"
```

**2. Advanced Relation Patterns:**
```lpl
// Conditional relations with dynamic filtering
RelationName
    one-to-many relation to TargetClass
    Field Mapping uses SetName
        related.Field1 = LocalField1
        related.Field2 = LocalField2
    Instance Selection
        where (related.Status = "Active"
        and   related.EffectiveDate <= current date
        and   related.Company = actor.context.Company)
    Cache Strategy is LAZY_LOAD
    Fetch Size is 100
    Order By related.Priority descending, related.CreateDate
```

**3. Complex Derived Field Logic:**
```lpl
// Multi-step calculations with error handling
DerivedFieldName is a DerivedField
    type is Alpha size 50
    restricted
    Local Fields
        LocalTemp is Alpha size 20
        LocalResult is Alpha size 50
    Calculations
        try
            LocalTemp = SourceField[1:10] uppercase
            if (LocalTemp matches "^[A-Z]{3}[0-9]{3}$")
                LocalResult = LocalTemp + "-VALID"
            else
                LocalResult = "INVALID-FORMAT"
        catch
            LocalResult = "PROCESSING-ERROR"
        return LocalResult
```

**4. Advanced Field Rules:**
```lpl
// Complex validation with conditional logic
Field Rules
    FieldName
        required when (Status = "Active")
        constraint (FieldName matches "^[A-Z0-9]{6,12}$")
            "FieldMustBe6To12AlphanumericCharacters"
        constraint (not DuplicateCheckRel exists)
            "DuplicateValueNotAllowed"
        on change
            invoke ValidateRelatedFields
            if (FieldNameChanged and Status = "Posted")
                constraint (false)
                    "CannotChangeFieldAfterPosting"
        default chain
            RelatedEntity.DefaultValue
            ConfigurationRel.DefaultSetting
            "DEFAULT"
```

**5. Enhanced Set Definitions:**
```lpl
// Advanced set with performance optimization
Sets
    AdvancedSet
        indexed
        unique
        cache size is 1000
        Sort Order
            Priority descending
            EffectiveDate
            ID
        Partition By Company
        Filter Condition
            where (Status in ("Active", "Pending")
            and   EffectiveDate <= current date)
```

**ENHANCED KNOWLEDGE AREAS NEEDED:**

**1. Error Handling Patterns:**
- Exception handling in actions and derived fields
- Validation error message formatting and localization
- Recovery procedures and automatic rollback logic
- Error logging and notification systems

**2. Performance Optimization:**
- Indexing strategies for sets and relations
- Caching mechanisms and cache invalidation
- Bulk processing patterns for large datasets
- Query optimization and execution plans

**3. Workflow Integration:**
- Approval process definitions and routing
- State machine patterns and transitions
- Event-driven processing and triggers
- Parallel processing and synchronization

**4. Data Migration Patterns:**
- Import/export configurations and mappings
- Data transformation rules and cleansing
- Legacy system integration patterns
- Incremental data synchronization

**5. Advanced Business Logic:**
- Complex calculation engines
- Rule-based decision making
- Dynamic configuration management
- Multi-tenant data isolation

**6. Testing and Debugging:**
- Unit test patterns for business classes
- Mock data generation for testing
- Debug logging and tracing capabilities
- Performance monitoring and profiling

**IMPLEMENTATION PRIORITIES:**
1. Complete validation and constraint syntax patterns
2. Advanced field calculation and dependency management
3. Comprehensive error handling and recovery mechanisms
4. Performance optimization patterns and best practices
5. Integration patterns for external systems and APIs
6. Security and authorization framework enhancements

=== ACTION CONDITIONAL SYNTAX ===
- Use separate if/else blocks within Action Rules, not inline ternary expressions
- Correct: if (condition) invoked.Field = value1 else invoked.Field = value2
- Incorrect: invoked.Field = if (condition) then value1 else value2

=== ANTHCCOMPANYCUSTOMERCOMMENT ANALYSIS ===

**Business Class Structure:**
- Prefix: cfg
- Implements StaticJava pattern
- Disable AuditIndex pattern
- Symbolic key: ANTHCCompanyCustomerComment

**Field Analysis (12 Persistent Fields):**
- ReceivableCompany, Customer (key fields)
- CommentType (AlphaUpper size 1) with 3 states: OrderEntryComment="O", CustomerComment="C", TransactionComment="T"
- Comment (Text type)
- TransactionType (reference to TransType)
- Transaction (reference to Invoice)
- BeginDate, EndDate (Date fields)
- PrintCode (AlphaUpper size 1) with 4 states: BothDisplayAndPrint="B", Display="D", Print="P", OrderEntryForms="R"
- CurrentDate (TimeStamp)
- CommentText, OriginatingInterfaceRun fields

**Field Rules Patterns:**
- Multiple default assignments for CommentType (both "C" and "T")
- "cannot be changed" attribute for BeginDate
- Date calculations: EndDate defaults to BeginDate + 14 days
- Constraint validation with custom error messages
- Initial value assignments from related entities

**Relations:**
- ANTHCReceivableInvoiceSet (set relation)
- ReceivableInvoiceRel (one-to-one with custom ByTransaction mapping)

**Sets:**
- ByTransaction (indexed set with 3-field sort order)

**Actions:**
- Create Action with Entrance Rules setting defaults
- Update Action (standard)
- Delete as Purge Action
- UpdateCustomer Instance Action
- BatchUpdateCustomer Set Action with parameters and filtering

**Key LPL Patterns Observed:**
- Classic name attributes for legacy compatibility
- TimeStamp data type usage
- Set Actions with parameter validation
- Derived Fields with StringField and MessageField types
- Complex condition logic with multiple OR operators
- Field Rules with "cannot be changed" attribute

=== ANTHCINVOICEREQUEST ANALYSIS ===

**Business Class Structure:**
- Prefix: cfg
- Symbolic key: ANTHCInvoiceRequest
- No patterns implemented

**Field Analysis (7 Persistent Fields):**
- HROrganization, RunGroup, Requester (key fields)
- BatchNumber (Numeric size 6)
- Status (Numeric size 1) with 4 states: Draft=0, Approved=1, InProgress=2, Rejected=3
- RejectReason, ApprovedMessage (Alpha size 500)

**Local Fields (6 fields):**
- Email-related fields: LocalEmailRecipients, LocalEmailSubject, LocalEmailContent, LocalEmailTo, LocalEmailFrom
- LocalCurrentDateTimeStamp for audit tracking

**Derived Fields (7 complex calculations):**
- DerivedTenantID: returns tenant id
- GetTenant: StringField with regex pattern matching
- DerivedTenant: tenant extraction logic
- DerivedRequestLink: dynamic URL generation
- DerivedCommentText: HTML email formatting
- DerivedTotalTransactionAmount: sum aggregation
- DerivedTransactionCount: instance count

**Relations:**
- ReceivableInvoiceRel (set relation)
- ReceivableInvoiceNoAttachmentRel (filtered set)
- UnmatchedReceivableInvoiceRel (one-to-many with filtering)
- ARApproversRel, ARApproversActorRel, ARRequestersActorRel (PfiUserTask relations)

**Actions:**
- FastCreate with parameter validation and actor context
- RequesterSubmit with email notification to approvers
- ARSubmit creating ReceivableInvoiceBatch
- Reject with reason parameter
- EmailRequester with PII-marked email parameters

**Key LPL Patterns:**
- Actor-based security (actor.agent(Employee).Employee)
- Email integration with dynamic recipients
- Complex derived fields with string manipulation
- Conditional action validity based on user roles
- Set relations with Instance Selection filtering
- Parameter validation with PII attributes
- Exit Rules creating related entities

=== ANTHCRECEIVABLEGLDISTRIBUTION ANALYSIS ===

**Business Class Structure:**
- Prefix: cfg
- Implements StaticJava, ContextualParent patterns
- Disable AuditIndex pattern
- Symbolic key: ANTHCReceivableGLDistribution

**Field Analysis (80+ Persistent Fields):**
- Complex GL distribution with financial dimensions (1-10)
- Multiple currency fields: OriginalCurrency, DistributionAmount, BaseAmount
- Transaction types: CreditMemo, DebitMemo, Invoice, Payment variants
- Status tracking: Unreleased=0, Released=2, Posted=9
- Tax-related fields: TaxCode, BaseTaxableAmount, VATInputTaxAmount
- Audit fields: AuditSummaryIndicator with 10+ transaction types
- Classic name attributes for legacy compatibility
- Restricted fields: JournalBook, CurrencyRate, TransactionAmount, BaseAmount

**Key Data Types:**
- InternationalAmount with precision references
- AlphaUpper with extensive state enumerations
- TimeStamp for CreateDate
- Boolean fields for flags and indicators
- Complex reference types (TransactionCodeBlock, FinanceCurrencyAmountGroup)

**Field Rules:**
- Special field defaults to false
- Initial value and default assignments

**Conditions:**
- SpecialWithProcessLevel: Special=true AND ReceivableProcessLevel entered
- SpecialNoProcessLevel: Special=true AND ReceivableProcessLevel not entered

**Sets:**
- Set2: Complex 7-field sort order for transaction grouping
- ByAssociatedLine: Indexed set for line associations

**Relations:**
- ReceivableInvoiceLineRel: one-to-one using ByAssociatedLine mapping

**Actions:**
- Create/Update with Exit Rules invoking CreateCodeBlockSet
- Delete as Purge Action
- CreateCodeBlock: Complex GL account assignment logic with 10 finance dimensions
- CreateCodeBlockSet: Set Action for Special type items

**Key LPL Patterns:**
- Complex conditional GL account assignment
- Finance dimension defaulting (1-10 dimensions)
- Process level override logic
- Restricted field usage for calculated amounts
- Classic name mappings for legacy systems
- Protected field attribute (CreatedByFES)
- Delete ignored attribute (ApplicationCloseResult)tion Rules, not inline ternary expressions
- Correct: if (condition) invoked.Field = value1 else invoked.Field = value2
- Incorrect: invoked.Field = if (condition) then value1 else value2

=== FIELD STATES ===
- Enumerated values defined in States block
- Syntax: "StateName value is N"
- Common patterns: NotRequired=0, No=1, Yes=2
- BalanceSheet=1, IncomeStatement=2 for chart sections
- None=0, Debit=1, Credit=2 for balance types

=== COMMON DATA TYPES ===
- Alpha [size] - text strings (1-4000 characters)
- Numeric [size] - numbers with precision
- Boolean - true/false values
- Date - date values
- Text - longer text content
- XMLDocument - XML data structures

=== COMPLEX BUSINESS CLASS EXAMPLE ===
**PurchaseOrderHeader.busclass Generated:**
- 33 Persistent Fields with various data types and states
- 5 Transient Fields with derived values
- 5 Local Fields for processing
- 4 Derived Fields with complex calculations
- 5 Conditions for business logic
- 5 Relations with different mapping strategies
- 4 Sets with sorting and filtering
- Comprehensive Field Rules with validation
- 8 Actions including Create, Update, Delete, Approve, Cancel
- Complex workflow integration and approval processes
- Demonstrates proper LPL syntax patterns and business logics
- Date - date values
- Text - long text content
- Description - descriptive text fields
- Decimal [size] - decimal numbers with precision
- XMLDocument - XML data structures

=== BUSINESSCLASS ANALYSIS ===

**Account (19 fields):**
- ChartSection with BalanceSheet=1, IncomeStatement=2 states
- AccountDescription (Description type)
- AllowUnits field
- Contains Boolean, Alpha, and reference fields

**AccountAnalysisSettings (35 fields):**
- OriginalBasis, Year, ReportingPeriod fields
- ReportingPeriod has "delete ignored" attribute
- Large field set for analysis configuration

**AccountAttachment (1 field):**
- Single Attachment field (AlternateAttachment type)
- Required attribute applied

**AccountCategoryMapping (0 fields):**
- No Persistent Fields defined

**AccountingEntity (51 fields):**
- LastYearClosed, AccountingUnitZoneBalancing (Boolean)
- FunctionalCurrency field
- Largest field set analyzed so far

=== BATCH ANALYSIS SUMMARY (500 files) ===
- Field counts range from 0-180 fields per BusinessClass
- Common patterns: states, required, pii attributes
- Many work/sort files have 0 fields (temporary processing)
- AllocationLine has largest field count (180 fields)
- PII (personally identifiable information) common in customer/vendor classes
- States used for enumerated values across many classes
- Required fields enforce mandatory data entry

=== REQUISITION.BUSCLASS ACTIONS ANALYSIS ===

**Business Class Overview:**
- Prefix: RQH (Requisition Header)
- Classic name: REQHEADER
- 150+ Persistent Fields with complex business logic
- Comprehensive Actions section with 50+ actions
- Supports supplier-created requisitions, capitulated procedures, and approval workflows

**ACTIONS BREAKDOWN (50+ Actions):**

**1. IDM (Integrated Document Management) Actions:**
- CreateAndSendRQDocToIDM: Complex IDM document generation with 7 child relations
- UpdateIDMUniqueID: Background action for IDM document tracking
- UpdatePrinter: Printer management for IDM documents
- UpdateIDMAttributes: Background attribute updates with PID handling

**2. Supplier-Specific Actions:**
- SupplierCreate: Create action for supplier-initiated requisitions
- SupplierUpdate: Update action with template line copying
- SupplierDelete: Delete action with budget cleanup
- SubmitForSupplier: Submit requisition with validation and email notifications
- SubmitForSupplierOverride: Reviewer override submission
- ApproveForSupplier: Approval action with email notifications
- RejectForSupplier: Rejection with required comments and email
- ReturnForSupplier: Return to supplier for updates
- ChangeReviewer: Change reviewer/requester assignment

**3. Capitulated Procedure Actions:**
- CreateCapitated: Specialized create for capitulated procedures
- SwapCapitatedCharges: Swap charged/no-charge components

**4. Communication Actions:**
- CreateSupplierMessageAndDialog: Create supplier communication dialogs
- CreateMessageAndDialog: Start supplier dialogs with attachments

**5. Budget and Commitment Actions:**
- RebuildCommitmentTotals: Rebuild GL commitments and budget totals
- UpdateBudgetResults: Update budget processing results

**6. Document Management Actions:**
- IssueDraft: Issue draft documents (IDM or print)
- IssueFinal: Issue final documents (non-IDM)
- IssueFinalIDM: Issue final IDM documents

**7. Interface Actions:**
- StartInterface: Begin interface processing
- FinishInterface: Complete interface processing
- FinishAndReleaseInterface: Complete and release from interface
- UpdateFromInterface: Update requisition from interface
- FinishCreateFromTemplate: Complete template-based creation

**8. Total Management Actions:**
- UpdateTotals: Comprehensive total recalculation
- UpdateTotalsFromLine: Update totals from line changes
- UpdateTotalsFromAOC: Update totals from add-on charges

**9. Workflow Actions:**
- Release: Primary release action with extensive validation
- RSSLPLRelease: RSS/LPL specific release with field validation
- MobileRelease: Mobile-specific release action
- Cancel: Cancel processed or rejected requisitions
- CancelTrialItems: Cancel trial notice items

**10. Utility Actions:**
- FastUpdate: Restricted update bypassing field rules
- CreateFromReturnLine: Create from return line processing
- UpdateDateAndTime: Update timestamps and sequences
- DeletePatientProcedure: Delete patient procedure information

=== ACTION TYPES ===

**PRIMARY ACTION TYPES:**

1. **Create Action** - Entity creation with validation and initialization
2. **Update Action** - Entity modification with field validation
3. **Delete Action** - Entity removal with constraint checking
4. **Instance Action** - Single entity operations and workflows
5. **Set Action** - Bulk operations with filtering and iteration
6. **Purge Action** - Data cleanup and archival operations
7. **Import Action** - Data import processing from external sources
8. **Action** - Generic action type for custom operations

**ACTION TYPE USAGE STATISTICS:**
- **Create Action:** 4,373 instances (27.8%) - Most common for entity creation
- **Instance Action:** 3,747 instances (23.8%) - Single entity workflows
- **Update Action:** 2,253 instances (14.3%) - Entity modifications
- **Delete Action:** 2,038 instances (13.0%) - Entity removal operations
- **Set Action:** 1,778 instances (11.3%) - Bulk processing operations
- **Purge Action:** 783 instances (5.0%) - Data cleanup and archival
- **Action:** 665 instances (4.2%) - Generic custom operations
- **Import Action:** 70 instances (0.4%) - External data import

**ACTION TYPE CHARACTERISTICS:**

**Create Action:**
- Used for creating new business entity instances
- Supports field initialization and default value assignment
- Includes validation rules and constraint checking
- Can trigger related entity creation through Exit Rules
- Supports parameter passing for initialization values

**Update Action:**
- Modifies existing business entity instances
- Validates field changes and business rules
- Supports conditional field updates
- Can trigger cascading updates to related entities
- Includes change tracking and audit trail

**Delete Action:**
- Removes business entity instances
- Enforces referential integrity constraints
- Supports cascade deletion of related entities
- Can be configured as soft delete or hard delete
- Includes confirmation prompts for critical deletions

**Instance Action:**
- Operates on single business entity instances
- Supports complex business workflows and state transitions
- Can be restricted to specific user roles or conditions
- Enables custom business logic execution
- Supports parameter input for operation customization

**Set Action:**
- Processes multiple entity instances in bulk
- Supports filtering through Instance Selection
- Includes sorting capabilities for processing order
- Provides Set Rules, Instance Rules, and Empty Set Rules
- Supports background processing for large datasets

**Purge Action:**
- Permanently removes entity instances and related data
- Typically restricted to system administrators
- Used for data archival and cleanup operations
- Cannot be undone once executed
- Often includes extensive validation before execution

**Import Action:**
- Processes data from external sources (XML, CSV, etc.)
- Supports data transformation and validation
- Includes error handling for malformed data
- Can create or update entities based on import data
- Supports batch processing of large datasets

**Generic Action:**
- Flexible action type for custom operations
- Can be configured for specific business requirements
- Supports parameter input and complex logic
- Used when standard action types don't fit requirements
- Provides maximum flexibility for custom workflows

**ACTION TYPE SYNTAX PATTERNS:**

```lpl
// Create Action - Entity Creation
CreateEntity is a Create Action
    Parameters
        PrmField1    is DataType
        PrmField2    is DataType
    Parameter Rules
        PrmField1
            required
            initial value is DefaultValue
    Entrance Rules
        validation logic before creation
    Action Rules
        Field1 = PrmField1
        Field2 = PrmField2
        include BusinessRuleBlock
    Exit Rules
        invoke CreateRelatedEntity RelatedEntityRel

// Update Action - Entity Modification
UpdateEntity is an Update Action
    Action Rules
        if (Field1Changed)
            constraint (Field1 > 0)
                "Field1MustBePositive"
            invoke RecalculateTotals
        if (StatusChanged)
            include ValidateStatusTransition

// Delete Action - Entity Removal
DeleteEntity is a Delete Action
    confirmation required
        "AreYouSureYouWantToDelete?"
    Entrance Rules
        constraint (not HasActiveChildren)
            "CannotDeleteEntityWithActiveChildren"
    Action Rules
        for each ChildEntityRel
            invoke Delete each

// Instance Action - Single Entity Workflow
ProcessEntity is an Instance Action
    restricted
    valid when (Status.Draft)
    default label is "Process"
    Parameters
        PrmApprover    is a Employee
    Action Rules
        Status = Status.InProcess
        Approver = PrmApprover
        ProcessedDate = current date
        send email
            to Approver.EmailAddress
            subject "EntityRequiresApproval"

// Set Action - Bulk Processing
ProcessEntitySet is a Set Action
    run in background
    Instance Selection
        where (Status.Pending
        and   ProcessDate <= current date)
    Sort Order
        Priority descending
        ProcessDate
    Parameters
        PrmBatchSize    is Numeric 3
    Action Rules
        Set Rules
            LocalProcessedCount = 0
        Instance Rules
            invoke ProcessEntity
            LocalProcessedCount += 1
            if (LocalProcessedCount >= PrmBatchSize)
                end set action instance loop
        Empty Set Rules
            send email
                to Administrator.EmailAddress
                subject "NoEntitiesFoundForProcessing"

// Purge Action - Data Cleanup
PurgeOldEntities is a Purge Action
    restricted
    confirmation required
        "ThisWillPermanentlyDeleteOldEntities"

// Import Action - External Data Processing
ImportEntityData is an Import Action
    restricted
    Parameters
        ImportXML    is XMLDocument
    Action Rules
        LocalEntityID = ImportXML select "//Entity/ID"
        LocalEntityName = ImportXML select "//Entity/Name"
        if (EntityRel exists)
            invoke Update EntityRel
                invoked.Name = LocalEntityName
        else
            invoke Create Entity
                invoked.EntityID = LocalEntityID
                invoked.Name = LocalEntityName

// Generic Action - Custom Operation
CustomEntityOperation is an Action
    restricted
    Parameters
        PrmOperation    is Alpha 20
    Action Rules
        if (PrmOperation = "CALCULATE")
            include CalculateEntityValues
        else
        if (PrmOperation = "VALIDATE")
            include ValidateEntityData
        else
            constraint (false)
                "InvalidOperationType"
```

=== EMAIL ACTION PATTERNS ===

**SENDAVAILABLEINVOICEMESSAGE ANALYSIS:**

**Email Action Structure:**
- Conditional email sending based on configuration and recipient availability
- Dynamic attachment handling with MIME type support
- Multi-source content composition with derived fields
- Audit trail creation through related entity invocation

**Key Components:**
1. **Conditional Logic:** Email only sent when both from address and recipient are available
2. **Dynamic Attachments:** Conditional attachment based on document availability and configuration
3. **Content Composition:** Multiple content sources combined (static text, derived fields, links)
4. **Audit Creation:** Creates PayablesInvoiceEmail record for tracking

**Email Syntax Pattern:**
```lpl
RuleBlockName
	if (FromEmailConfigured and RecipientAvailable)
		send email
			to LocalEmailAddress
			from ConfigurationRel.EmailAddress
			subject "<DynamicSubjectTemplate>"
			Attachments
				if (DocumentExists)
					attachment DocumentRel.File
						name is DocumentRel.Title
						mime type is DocumentRel.MimeType
				if (IncludeRelatedDocs)
					for each RelatedDocumentsRel
						attachment each.File
							name is each.Title
							mime type is each.MimeType
			Contents
				"<StaticContent>"
				"<DerivedField1>"
				"<DerivedField2>"
				"<DerivedField3>"

		invoke Create EmailAuditEntity
			invoked.Field1 = Value1
			invoked.Field2 = Value2
```

**Email Features:**
- **Conditional Sending:** Only sends when prerequisites met
- **Dynamic Recipients:** Uses local variables for email addresses
- **Template Subjects:** Uses configuration-based subject templates
- **Conditional Attachments:** Attaches documents based on availability and settings
- **Bulk Attachments:** Iterates through related documents for multiple attachments
- **Rich Content:** Combines static text with derived field values
- **Audit Trail:** Creates tracking records for sent emails
- **MIME Type Support:** Proper attachment handling with content types

**Common Email Patterns:**
1. **Approval Notifications:** Send emails for approval workflows
2. **Status Updates:** Notify stakeholders of status changes
3. **Document Delivery:** Send documents as attachments
4. **Escalation Alerts:** Send escalation notifications
5. **Batch Processing:** Send summary emails for batch operations

=== COMPREHENSIVE ACTIONS SYNTAX PATTERNS ===

**BASIC ACTION STRUCTURE:**
```lpl
ActionName is a/an ActionType
	restricted
	confirmation required
		"ConfirmationMessage"
	valid when (Condition)
	default label is "ActionLabel"
	run in background
	resume on error
	Parameters
		ParameterName		is DataType
			default label is "ParameterLabel"
	Parameter Rules
		ParameterName
			required
			initial value is DefaultValue
			constraint (ValidationLogic)
				"ErrorMessage"
	Instance Selection
		where (FilterConditions)
	Sort Order
		FieldName1
		FieldName2
	Accumulators
		CounterName
	Entrance Rules
		validation logic before action execution
	Action Rules
		business logic statements
		invoke operations
		field assignments
		include RuleBlocks
		Instance Rules
			invoke operations
	Exit Rules
		post-processing logic
```

**COMPREHENSIVE ACTION TYPE SYNTAX SAMPLES:**

**CREATE ACTION (4,373 instances - 27.8%):**
```lpl
Create is a Create Action
	Entrance Rules
		if (PreservedOriginalBasis not entered)
			include PreserveBasis
		include ChangeBasis
		include CheckOverrideStructures
	Action Rules
		BypassActiveCodeBlockEdit = true
		include CalculateCosts
		if (AssetTransfer.PartialTransfer)
			if (AssetItem.ItemQuantity != ToItemQuantity)
				LocalQuantityDifference = AssetItem.ItemQuantity - ToItemQuantity
				LocalBaseCostDifference = AssetItem.BaseItemCost - FromBaseItemCost
				invoke UpdateFromAssetItemTransfer AssetTransfer
					invoked.PrmToTotalItemQuantity = ToItemQuantity
					invoked.PrmToItemTotalBaseCost = ToBaseItemCost
					invoked.PrmToItemTotalTransactionCost = ToTransactionItemCost
				for each Asset.AssetBook set
					LocalBook = each.Book
					if (!each.Disposed)
						LocalFromCurrency = Asset.Currency
						if (each.Book.PostCurrency.Book)
							LocalToCurrency = each.Book.Currency
						else
							LocalToCurrency = Asset.Currency
						if (LocalFromCurrency not = LocalToCurrency)
							include ToBookCurrencyExchange
						else
							ToBookTransactionItemCost = ToTransactionItemCost
	Exit Rules
		constraint (ToItemQuantity <= LocalOriginalItemQuantity)
			"SelectedQuantityCanNotBeGreaterThanOriginalItemQuantity"
		invoke UpdateFromAssetItemTransfer Asset
		if (AssetTransfer.PartialTransfer)
			invoke UpdateFromAssetItemTransfer ToAssetAndItem.ToAsset
```

**INSTANCE ACTION (3,747 instances - 23.8%):**
```lpl
EnableBODFlows is an Instance Action
	restricted
	Parameters
		PrmService		is Alpha size 100
		PrmFlowName		is Alpha size 100
		PrmDirection	is Numeric 1
	Action Rules
		LocalService = PrmService
		LocalFlowName = PrmFlowName
		LocalDirection = PrmDirection
		if (LocalDirection = 1)
			if (LocalService = "AccountingEntityService" and LocalFlowName = "FSM_ION_SyncAccountingEntity_Out")
				LocalVerb = FSMBODConfiguration.Verb.Sync
				LocalNoun = "AccountingEntity"
				LocalIPAOutboundDisable = true
			else
			if (LocalService = "AssetMasterService" and LocalFlowName = "FSM_ION_SyncAssetMaster_Out")
				LocalVerb = FSMBODConfiguration.Verb.Sync
				LocalNoun = "AssetMaster"
				LocalIPAOutboundDisable = true
		if (FSMBODConfigurationRel exists)
			invoke Update FSMBODConfigurationRel
				invoked.Enable = true
			if (LocalIPAOutboundDisable)
				invoke EnableDisable DisablePfiServiceFlowDefinitionRel
```

**UPDATE ACTION (2,253 instances - 14.3%):**
```lpl
Update is an Update Action
	Action Rules
		if (VendorItemChanged)
			constraint (VendorItem entered)
				"VendorItemCannotBeBlank"
			if (InventoriedOrNonstock)
				constraint (VendorItemsRel exists)
					"VendorItem<VendorItem>IsNotValidForThisItem"
		if (QuantityChanged)
			constraint (Quantity > 0)
				"QuantityMustBeGreaterThanZero"
			if (PurchaseOrderLineRel.ServiceCode.Amount)
				constraint (Quantity = 1)
					"ServiceItemByAmount,QuantityMustBe1"
		if (UnitOfMeasureChanged)
			constraint (UnitOfMeasure entered)
				"UnitOfMeasureCannotBeBlank"
			if (InventoriedOrNonstock)
				constraint (ItemUOMBuyRel.OKForBuying)
					"<UnitOfMeasure>IsNotValidForThisItem<Item>"
			else
				constraint (UnitOfMeasureRel exists)
					"UnitOfMeasure<UnitOfMeasure>DoesNotExist"
		if (EnteredUnitCostChanged)
			constraint (EnteredUnitCost > 0)
				"UnitCostMustBeGreaterThanZero"
		if (EarlyDeliveryDateChanged)
			if (!PurchaseOrderLineRel.ItemType.Service)
				constraint (EarlyDeliveryDate > 0)
					"DeliveryDateCannotBeBlank"
			constraint (EarlyDeliveryDate >= PurchaseOrderRel.PurchaseOrderDate)
				"DeliveryDateCannotBeBeforePurchaseOrderDateOf<PurchaseOrderRel.PurchaseOrderDate>"
```

**DELETE ACTION (2,038 instances - 13.0%):**
```lpl
Delete is a Delete Action
	Entrance Rules
		if (RelatedCheckPointsRel exists)
			confirmation required
				"MultipleCheckpointsExistForTheJob.DeletingCheckpointsCanLeaveDataInAnInconsistentState.AreYouSureYouWantToDeleteCheckpoints?"
		else
			confirmation required
				"DeletingACheckpointCanLeaveDataInAnInconsistentState.AreYouSureYouWantToDelete?"
		if (AsyncActionTrigger exists)
			constraint (not AsyncActionTrigger.Status.InProgress)
				"CannotDeleteInProcessCheckpoint"
		for each RelatedCheckPointsRel
			if (each.AsyncActionTrigger exists)
				constraint (not each.AsyncActionTrigger.Status.InProgress)
					"CannotDelete,RelatedInProcessCheckpointExists"
		for each RelatedCheckPointsRel
			invoke DeleteRelatedWorkFiles each
			invoke DeleteInternal each
	Action Rules
		if (AsyncActionTrigger exists)
			if (AsyncActionTrigger.Status.Queued)
				invoke Queued.Delete AsyncActionTrigger
			else
			if (AsyncActionTrigger.Status.PendingStart)
				invoke PendingStart.Delete AsyncActionTrigger
			else
			if (AsyncActionTrigger.Status.Finished)
				invoke Finished.Delete AsyncActionTrigger
		for each WorkFileRel
			if (!each.ScheduledForDeletion)
				invoke RemoveWorkFile each
```

**SET ACTION (1,778 instances - 11.3%):**
```lpl
SetAnalyticsConsoleParameter is a Set Action
	no records message is "Creating_\Records"
	run in foreground
	Instance Selection
		where (false)
	Parameters
		NotificationsEmailAddress	is Alpha 500
		IONApiUrl					is Alpha 100
		TenantID					is Alpha 100
		ConnectionPoint				is Alpha 100
		DataLakeFlowName			is Alpha 100
		RunDeleteAllProcessedDataWorkflow	is Boolean
		EnableNotifications			is Boolean
	Parameter Rules
		NotificationsEmailAddress
			required
			initial value is DerivedNotificationsEmailAddress
		IONApiUrl
			required
			initial value is DerivedIONApiUrl
		TenantID
			required
			initial value is DerivedTenantID
	Action Rules
		Empty Set Rules
			if (NotificationsEmailAddress entered)
				if (!AnalyticsConfigParaNotificationsEmailAddressRel exists)
					invoke Create
						invoked.AnalyticsConsoleConfigurations = "NotificationsEmailAddress"
						invoked.PropertyType = 8222
						invoked.Value = NotificationsEmailAddress
				else
					invoke Update AnalyticsConfigParaNotificationsEmailAddressRel
						invoked.Value = NotificationsEmailAddress
```

**PURGE ACTION (783 instances - 5.0%):**
```lpl
Purge is a Purge Action
	restricted

Release is an Instance Action
	default label is untranslatable
	restricted
	Local Fields
		DistMultiplier is Numeric size 1
		OffsetMultiplier is Numeric size 1
	Entrance Rules
		if (CashLedgerFundTransferHeader.TransferType.MultipleWithdrawals)
			DistMultiplier = 1
			OffsetMultiplier = -1
		else
			DistMultiplier = -1
			OffsetMultiplier = 1
		if (CashLedgerFundTransferDetail.DetailCashCode.EditAvailableFunds
		or CashLedgerFundTransferDetail.DetailCashCode.RestrictedFunds)
			include PerformFundAmountEdit
	Action Rules
		invoke Unreleased.CreateFromCashLedgerWithoutEdits CashLedgerTransaction
			assign result to NewCashLedgerTransaction
			invoked.CashManagementGroup = CashLedgerFundTransferDetail.DetailCashCode.CashManagementGroup
			invoked.CashCode = CashLedgerFundTransferDetail.DetailCashCode
			invoked.BankTransactionCode = BankTransactionCode
			invoked.TransactionNumber = CashLedgerFundTransferHeader
			invoked.BypassBudgetEditing = true
```

**ACTION (665 instances - 4.2%):**
```lpl
Create is an Action
	restricted
	Action Rules
		constraint (!com.lawson.rdtech.type.Field.equalStrings(UppercaseRole, "CLOUDADMIN"))
			"CannotCreateCloudAdminRole"
	Exit Rules
		if (IsSecIFSUserProvEnabled and not IsExcludedFromBODSync)
			if (config.imsuserbod = true)
				send ion bod
					bod is SecRoleMasterBODXml
					bod type is "Sync.SecurityRoleMaster"
			else
				invoke Create IONOutboxQueue
					invoked.BodXML = SecRoleMasterBOD
					invoked.BodType = "Sync.SecurityRoleMaster"
					invoked.FromLogicalId = LogicalId
		invoke FireConfigurableFeatureChangeEvent
			invoked.Type = 1

Copy is an Action
	Parameters
		NewRole is Alpha size 80
	Parameter Rules
		NewRole
			constraint (!com.lawson.rdtech.type.Field.endsWith(NewRole, "_ST"))
				"CannotCreateAStandardTemplateRole"
	Action Rules
		invoke Create Role
			invoked.Role = NewRole
			fill in fields from this instance
```

**IMPORT ACTION (70 instances - 0.4%):**
```lpl
UpdateEAMWorkOrder is an Import Action
	restricted
	Parameters
		MaintenanceOrderBOD		is XMLDocument
		PrmInboundTracker		is like FSMInboundBODTracker
		PrmFEG					is Alpha 10
		PrmCompany				is Numeric 4
	Local Fields
		LocalUserArea			is XMLDocument
	Action Rules
		LocalFSMInboundBODTracker = PrmInboundTracker
		LocalFEG = PrmFEG
		LocalEAMCompany = PrmCompany
		LocalEAMWorkOrder = MaintenanceOrderBOD select "//DataArea/MaintenanceOrder/MaintenanceOrderHeader/DocumentID/ID"
		LocalDescription = MaintenanceOrderBOD select "//DataArea/MaintenanceOrder/MaintenanceOrderHeader/Description"
		LocalWoComment = MaintenanceOrderBOD select "//DataArea/MaintenanceOrder/MaintenanceOrderHeader/Note"
		LocalWoType = MaintenanceOrderBOD select "//DataArea/MaintenanceOrder/MaintenanceOrderHeader/DocumentReference/@type"
		LocalIterator = 1
		while (LocalUserAreaCount >= LocalIterator)
			LocalUserArea = MaintenanceOrderBOD select "//DataArea/MaintenanceOrder/MaintenanceOrderHeader/UserArea/Property[<LocalIterator>]"
			LocalNameValueID = LocalUserArea select "/Property/NameValue/@name"
			LocalNameValue = LocalUserArea select "/Property/NameValue"
			if (LocalNameValueID = "eam.CreatedBy")
				LocalCreatedBy = LocalNameValue
			LocalIterator = LocalIterator + 1
		if (EAMWorkOrderRel exist)
			invoke Update EAMWorkOrderRel
				resume on error
					Error = true
					ErrorMessage = error message
				invoked.FinanceEnterpriseGroup = LocalFEG
				invoked.EAMWorkOrder = LocalEAMWorkOrder
				invoked.Description = LocalDescription
```

**KEY REQUISITION ACTION PATTERNS:**

**Complex Parameter Validation:**
```lpl
Parameter Rules
    NewReviewer
        required
            "MustEnterANewReviewer"
        constraint (NewReviewer != Requester)
            "NewReviewerMustBeDifferentThanRequester"
        constraint (NewReviewer.SupplierRequisitionReviewer)
            "NewReviewerMustBeAllowedToReviewSupplierRequsitions"
```

**Email Integration:**
```lpl
send email
    to RequesterEmailAddress
    from SupplierSourceIdByActorRel.EmailAddress
    subject "SupplierRequisition<Requisition>HasBeenSubmitted"
    Contents
        "SupplierRequisition<Requisition>HasBeenSubmitted;ViewInSupplierRequisitions"
```

**Background Processing:**
```lpl
invoke CreateRequisitionLineFromTemplateLineSet ProcurementTemplateLine in background
    invoked.PrmProcurementGroup     = ProcurementTemplate.ProcurementGroup
    invoked.PrmProcurementTemplate  = ProcurementTemplate
    invoked.PrmInventoryCompany     = Company
    invoked.PrmRequisition          = Requisition
    invoked.PrmCopyAllLines         = TransientCopyAllLines
```

**Complex IDM Document Structure:**
```lpl
IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].RelationName = "RequisitionLinesRel"
IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].ListName     = "RequisitionLinesForIDM"
IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].LevelSection1 = 1
IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].ListTag      = "Lines"
IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].ItemTag      = "Line"
```

**Conditional Action Validity:**
```lpl
SubmitForSupplier is an Instance Action
    valid when (CanSubmitForSupplier)
    default label is "Submit"
    Action Rules
        constraint (RequisitionLinesOpenRel exists)
            "MustHaveAtLeastOneLineItemToSubmit"
```

**State Transition Management:**
```lpl
if (SupplierSourceIdRel.AutoApprove = true
and RequesterEntered)
    SupplierCreated = 3
else
    SupplierCreated = 2
```

**Complex Validation Logic:**
```lpl
if (HasLinesWithDuplicateSerial)
    confirmation required 
        "DuplicateSerialNumbersExistForLine<first LinesWithDuplicateSerialRel.RequisitionLine>;DoYouWantToContinue?"
```

**Budget and GL Integration:**
```lpl
if (RQGeneralLedgerSystemCodeRel.EncumbranceOption.TrackAndEdit
or  RQGeneralLedgerSystemCodeRel.EncumbranceOption.Track)
    invoke Delete BudgetRebuildBTGTRel
    invoke Delete HeaderBudgetEditErrorRel
    invoke Delete DistributionBudgetEditErrorRel
    for each CommittedRequisitionLineDistributionRel
        invoke PurgeGLCommitment each
```

**ACTION TYPES WITH USAGE STATISTICS:**
- **Create Action:** 4,373 instances (27.8%) - Entity creation with validation
- **Instance Action:** 3,747 instances (23.8%) - Single entity operations
- **Update Action:** 2,253 instances (14.3%) - Entity modification
- **Delete Action:** 2,038 instances (13.0%) - Entity removal
- **Set Action:** 1,778 instances (11.3%) - Bulk operations with filtering
- **Purge Action:** 783 instances (5.0%) - Data cleanup and archival
- **Action:** 665 instances (4.2%) - Generic custom operations
- **Import Action:** 70 instances (0.4%) - Data import processing

**ACTION ATTRIBUTES (MOST COMMON):**
- **restricted:** 5,240 uses - Internal system use only
- **confirmation required:** 514 uses - User confirmation prompts
- **default label is untranslatable:** 342 uses - UI label override
- **run in background:** 170 uses - Asynchronous execution
- **resume on error:** 181 uses - Error handling continuation
- **valid when:** 87 uses - Conditional availability

**PARAMETER PATTERNS:**
```lpl
// Most common parameter types
PrmBoolean			is Boolean
PrmDate				is Date
PrmAlphaField		is Alpha size 22
PrmText				is Text
PrmNumeric			is Numeric 1
PrmReference		is a BusinessClassName
PrmGroup			is a BusinessClassName group

// Parameter rules patterns
Parameter Rules
	PrmField
		required
		initial value is DefaultValue
		default to DefaultValue
		constraint (ValidationCondition)
			"ValidationErrorMessage"
		if (ConditionalLogic)
			cannot be entered
```

**ACTION RULE PATTERNS:**
```lpl
// Invoke patterns
invoke ActionName TargetEntity
	resume on error
	assign result to LocalVariable
	fill in fields from SourceEntity
		except invoked.ExcludedField
	invoked.FieldName = Value

// Include patterns
include RuleBlockName
	replace ParameterName with ActualValue

// Conditional logic
if (Condition)
	statements
else
	statements

// Iteration patterns
for each RelationName set
	statements
	commit transaction

while (Condition)
	statements
	I1 += 1

// BOD Integration
if (Company.BODTrigger)
	ActionCode = ActionCode.Create
	increment bod id.VariationID
	trigger "ServiceName" PA service
		resume on error
		title is "ServiceTitle"
		Criteria
			CriteriaField
		Variables
			VariableName

// Transaction management
commit transaction
end set action instance loop

// Error handling
resume on error
	ErrorMessage = error message
	ErrorCount += 1

// Constraint validation
constraint (ValidationCondition)
	"ErrorMessage"

// Field assignments
FieldName = Value
FieldName += IncrementValue
FieldName *= MultiplierValue
initialize FieldName

// Confirmation prompts
confirmation required
	"ConfirmationMessage"
```

**SET ACTION SPECIFIC PATTERNS:**
```lpl
ActionName is a Set Action
	restricted
	run in background
	disable checkpoint
	Parameters
		PrmParameter		is DataType
	Instance Selection
		where (FilterCondition1
		and   FilterCondition2
		and   (PrmParameter not entered or Field = PrmParameter))
	Sort Order
		Field1
		Field2
	Accumulators
		InstanceCount
		TotalAmount
	Action Rules
		Set Rules
			Entrance Rules
				pre-processing logic
			Exit Rules
				post-processing logic
		Instance Rules
			increment InstanceCount
			processing for each instance
			commit transaction
			if (StopCondition)
				end set action instance loop
		Empty Set Rules
			logic when no instances found
```

**COMPLEX REAL-WORLD EXAMPLES:**

**Complex IDM Instance Action:**
```lpl
CreateAndSendRQDocToIDM is an Instance Action
	restricted
	Parameters
		IDMPrinter
	Local Fields
		IDMJobView	 		is an IDMJob view
		LocalColSequence    is Numeric size 3
	Action Rules
		initialize IDMGenerateDocument
		IDMGenerateDocument.IDMXMLDefinition.Busclass		= reference to this instance
		IDMGenerateDocument.IDMXMLDefinition.ListName		= "RequisitionListForIDM"
		IDMGenerateDocument.IDMXMLDefinition.DocumentName	= "Requisition"
		IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].RelationName		= "RequisitionLinesRel"
		IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].ListName			= "RequisitionLinesForIDM"
		IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].LevelSection1	= 1
		IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].ListTag			= "Lines"
		IDMGenerateDocument.IDMXMLDefinition.IDMXMLChildren.IDMXMLChild[1].ItemTag			= "Line"
		include SetIDMAttributes
		IDMGenerateDocument.IDMAttributes	 = IDMAttributes
		IDMGenerateDocument.TemplateUniqueId = Company.RequisitionTemplate.IDMUniqueId
		IDMGenerateDocument.DocumentType	 = "FSM_Requisition"
		IDMGenerateDocument.FileName		 = DerivedFileName + Company.RequisitionTemplate.DerivedOutputFormat
		IDMGenerateDocument.IDMAccessControlList = "CSFDefined"
		if (IDMPrinter entered)
			IDMGenerateDocument.IDMPrinter	 = IDMPrinter
		invoke CreateFromGenerateDocument IDMJob
			assign result to IDMJobView
			invoked.Actor				= actor
			invoked.Description			= "Requisition Issue"
			invoked.IDMGenerateDocument	= IDMGenerateDocument
		IDMJob = IDMJobView.IDMJob
		invoke UpdateIDMUniqueID in background
			run after IDMJob.AsyncId
```

**Complex Instance Action:**
```lpl
ProcessPayment is an Instance Action
	restricted
	confirmation required
		"ProcessPaymentForInvoice?"
	valid when (Status.Approved and !PaymentProcessed)
	Parameters
		PrmPaymentDate		is Date
		PrmPaymentMethod	is Alpha size 10
		PrmBankAccount		is a BankAccount
	Parameter Rules
		PrmPaymentDate
			required
			initial value is system current date
		PrmPaymentMethod
			required
			constraint (PrmPaymentMethod = "CHECK" or PrmPaymentMethod = "ACH")
				"PaymentMethodMustBeCheckOrACH"
		PrmBankAccount
			required
	Entrance Rules
		constraint (InvoiceAmount > 0)
			"CannotProcessZeroAmountPayment"
		if (PrmBankAccount.Balance < InvoiceAmount)
			confirmation required
				"InsufficientFunds.Continue?"
	Action Rules
		invoke Create PaymentTransaction
			invoked.Invoice = Invoice
			invoked.PaymentDate = PrmPaymentDate
			invoked.PaymentMethod = PrmPaymentMethod
			invoked.BankAccount = PrmBankAccount
			invoked.Amount = InvoiceAmount
		Status = Status.Paid
		PaymentProcessed = true
		PaymentDate = PrmPaymentDate
		if (Company.BODTrigger)
			trigger "PaymentService" PA service
				title is "Payment:<Invoice>"
				Variables
					ActionCode.Update
					Invoice
					PaymentAmount
	Exit Rules
		invoke Update PrmBankAccount
			invoked.Balance = invoked.Balance - InvoiceAmount
```

**Financial Integration Action:**
```lpl
JournalizeTransactions is a Set Action
	restricted
	Parameters
		PrmJournalizeGroup		is a JournalizeGroup
		PrmPostingDate			is Date
	Instance Selection
		where (Status.ReadyToPost
		and   PostingDate <= PrmPostingDate)
	Action Rules
		Instance Rules
			invoke Create GLTransactionDetail
				fill in fields from this instance
				invoked.JournalizeGroup = PrmJournalizeGroup
				invoked.PostingDate = PrmPostingDate
			Status = Status.Posted
			commit transaction
```

**BOD Service Integration:**
```lpl
TriggerEntitySync is an Instance Action
	restricted
	resume on error
	Parameters
		ActionCode		is an ActionCode
	Action Rules
		if (Company.BODTrigger)
			LocalTitle = "Entity:" + EntityName + ":" + EntityKey
			increment bod id.VariationID
			trigger "EntitySyncService" PA service
				resume on error
				title is "<LocalTitle>"
				Criteria
					Company.FinanceEnterpriseGroup
					EntityKey
				Variables
					ActionCode
					bod id.VariationID
					EntityStatus
```

=== ACTIONS SECTION PLACEMENT ===

Actions sections appear after other major sections in BusinessClass files:

```lpl
BusinessClassName is a BusinessClass
	owned by ParentEntity
	prefix is PREFIX
	
	Persistent Fields
		[field definitions]
	
	Transient Fields
		[field definitions]
	
	Local Fields
		[field definitions]
	
	Derived Fields
		[field definitions]
	
	Conditions
		[condition definitions]
	
	Relations
		[relation definitions]
	
	Sets
		[set definitions]
	
	Field Rules
		[field validation rules]
	
	Rule Blocks
		[reusable rule blocks]
	
	Actions
		[action definitions]
```

=== PURCHASEORDERRECEIPTIMPORT ANALYSIS ===

**Business Class Structure:**
- Prefix: PORI
- Designed for CSV import data processing
- 6 Persistent Fields mapping to CSV columns

**Field Analysis:**
- Company (Numeric 4) - company identifier
- PurchaseOrderReceiptImport (Numeric 11) - unique import identifier
- RunGroup (Alpha size 4) - processing group code
- PurchaseOrder (Numeric 11) - purchase order reference
- BillOfLading (Alpha size 15) - shipping document reference
- ReceiptComments (Alpha size 100) - integration timestamp and notes

**Sets:**
- ByCompanyAndImport: Primary sorting by Company and PurchaseOrderReceiptImport

**Actions:**
- Standard CRUD operations (Create, Update, Delete)
- Minimal action set for data import processing

**Key Patterns:**
- CSV-to-BusinessClass field mapping
- Numeric fields for identifiers and references
- Alpha fields with appropriate sizing for text data
- Simple set structure for data retrieval and sorting

=== CSV IMPORT BUSINESS CLASS PATTERNS ===

**CSV Data Structure Analysis:**
- Pipe-delimited format (|) commonly used in enterprise systems
- Header row defines field names for mapping
- Numeric fields for company codes and identifiers
- Alpha fields for text data with appropriate sizing
- Comments fields often contain timestamps and integration details

**Field Sizing Guidelines:**
- Company codes: Numeric 4 (standard enterprise pattern)
- Import identifiers: Numeric 11 (large transaction volumes)
- Run groups: Alpha size 4 (short processing codes)
- Reference numbers: Numeric 11 (purchase orders, invoices)
- Document references: Alpha size 15 (bills of lading, tracking)
- Comments: Alpha size 100+ (descriptive text with timestamps)

=== SAMPLE SYNTAX FOR ALL FIELD CATEGORIES ===

**PERSISTENT FIELDS:**
```lpl
Persistent Fields
	FieldName				is DataType [size]
		States
			StateName		value is N
		AttributeName
	ReferenceField			is a BusinessClassName
	GroupField				is a BusinessClassName group
	AlphaField				is Alpha size 60
	BooleanField			is Boolean
	NumericField			is Numeric 1
```

**TRANSIENT FIELDS:**
```lpl
Transient Fields
	TransientField			is DataType
		derive value from SourceField
	CalculatedField			is Boolean
		derive value from DerivedFieldName
	StatusField				is Numeric size 2
		States
			Active			value is 1
			Inactive		value is 0
		derive value from RelatedEntity.Status
```

**LOCAL FIELDS:**
```lpl
Local Fields
	LocalReference			is like BusinessClassName
	LocalDerivedField		is a DerivedField
		type is Boolean
		restricted
		return CalculationLogic
	LocalSet				is a BusinessClassName set
	LocalMessage			is a MessageField
		"MessageText"
	LocalError				is Boolean
	LocalCounter			is Numeric 10
```

**CONTEXT FIELDS:**
```lpl
Context Fields
	SearchDateRange				is a DateRange
		AccountingEntity
		Project
		FinanceDimension1
	FilterField					is a BusinessClassName
	DerivedDisplayField			is a DerivedField
		type is Alpha up to 100
		restricted
	StatusMessage				is a MessageField
	SearchBoolean				is Boolean
	ReferenceField				is an EntityName
	CalculatedField				is a StringField
		type is Alpha size 50
```

**CONDITIONS:**
```lpl
Conditions
	ShowPanel
		restricted
		when (FieldName entered)
	SecurityCheck
		restricted
		when (actor.context.SecurityGroup allows access)
	Validation
		when (RelatedEntity exists
		and  FieldValue = "Expected")
	ComplexLogic
		restricted
		when ((Field1.SubField
		or    Field2.Value)
		and  !Field3.Flag)
```

**RELATIONS:**
```lpl
Relations
	OneToOneRel
		one-to-one relation to TargetEntity
		Field Mapping uses symbolic key
			related.Field1 = LocalField1
	OneToManyRel
		one-to-many relation to TargetEntity
		Field Mapping uses SortName
			related.Field1 = LocalField1
		Instance Selection
			where (related.Status = "Active")
	SetRel			is a TargetEntity set
		Instance Selection
			where (related.Flag)
```

**SETS:**
```lpl
Sets
	ByPriority
		duplicates
		Sort Order
			Priority
			CreateDate
	ByStatus
		indexed
		restricted
		Sort Order
			Status
			LastUpdate
		Instance Selection
			where (Active = true)
```

**DERIVED FIELDS:**
```lpl
Derived Fields
	CalculatedField			is a DerivedField
		type is DataType
		restricted
		if (condition)
			return value1
		else
			return value2
	
	MessageField			is a MessageField
		restricted
		"MessageText"
```

**SETS:**
```lpl
Sets
	BySystemAccount
		duplicates
		Sort Order
			FinanceEnterpriseGroup
			SystemAccount
			Account
	
	ByPriority
		indexed
		restricted
		Sort Order
			Priority
			CreateDate
	
	ByStatus
		Sort Order
			Status
			LastUpdateDate
		Instance Selection
			where (related.Active = true)
```

**SYNTAX RULES:**
- Tab indentation for hierarchy
- States block with enumerated values
- Attributes on separate lines
- Articles (a/an) for reference types
- "derive value from" for transient field calculations
- "restricted" for internal-only access
- "holds pii" for personally identifiable information
- "when" clauses for conditional logic
- Logical operators: "and", "or", "!" (not)
- Field existence: "entered", "exists"
- Comparison operators: "=", "!=", "<", ">"
- "duplicates" allows multiple entries in sets
- "indexed" provides performance optimization
- Instance Selection filters with where clauses
- Sort Order supports multi-level sorting
- Field Mapping connects related entities
- "related." prefix for target entity fields

**ACTIONS SYNTAX RULES:**
- "is a/an ActionType" defines action type
- "restricted" limits access to internal operations
- "confirmation required" prompts user approval
- "run in background" enables asynchronous execution
- "Parameters" section defines input parameters
- "Action Rules" contains business logic
- "Field Rules" provides parameter validation
- "invoke" calls other actions or operations
- "assign result to" captures operation results
- "resume on error" enables error handling
- "trigger service" initiates external processes
- "Instance Selection" filters target records for Set Actions

=== PAYABLES INVOICE SETS ANALYSIS ===

**Available Sets for PayablesInvoice Field Mapping:**

1. **symbolic key** (Default) - Uses primary key fields:
   - Company
   - PayablesInvoice (Invoice number)
   - Suffix
   - CancelSequence

2. **ByVendor2** - Vendor-based sorting set (RETRIEVED):
   ```lpl
   ByVendor2
       Sort Order
           Company
           Vendor
           PayablesInvoice
   ```
   - Found in PayablesInvoice.busclass at line ~24647

=== KNOWLEDGE BASE MAINTENANCE ===

**File Context Processing:**
- Knowledge.txt file successfully referenced and updated
- Implicit instructions followed for minimal code implementation
- Directory structure maintained with proper subdirectory usage
- LPL syntax patterns and business logic examples preserved
- Comprehensive action syntax documentation maintained
- Field mapping and relation creation processes documented
- Set retrieval and analysis procedures established
   - Used in GeneratePreviewRecordsForRunGroup Set Action
   - Provides hierarchical sorting: Company  Vendor  PayablesInvoice

3. **Common Relation Sets:**
   - PayablesInvoiceDistribution set
   - PayablesInvoicePaymentRel
   - PayablesInvoiceDetailRel
   - PayablesInvoiceAddOnChargeRel
   - PayablesInvoiceCommentRel
   - PayablesInvoiceTaxRel
   - MultiplePayablesInvoicePaymentRel
   - MatchPurchaseOrderInvoicesRel
   - UnreleasedDistributionsRel

**Recommended Usage:**
For Relations to PayablesInvoice, use 'symbolic key' as Field Mapping:
```lpl
PayablesInvoiceRel
    one-to-many relation to PayablesInvoice
    Field Mapping uses symbolic key
        related.Company = Company
        related.PayablesInvoice = PayablesInvoice
```

For vendor-based sorting, 'ByVendor2' set is available:
```lpl
PayablesInvoiceRel
    one-to-many relation to PayablesInvoice
    Field Mapping uses ByVendor2
        related.Company = Company
        related.Vendor = Vendor
        related.PayablesInvoice = PayablesInvoice
```

=== WEBSERVICE INTERFACE DEFINITION SYNTAX ===

**WEBSERVICE INTERFACE STRUCTURE:**
```lpl
WebserviceInterfaceName is a WebserviceInterface
	wsdlURL is "http://webservices.example.com/service.wsdl"
	endpoint is "http://soap.example.com/service"
	service is "ServiceName"
	service style is ServiceStyle
	authentication is AuthenticationType
	
	ActionName is a WSIActionType Action
		method is "MethodName"
		Input Record namespace is "http://namespace.example.com"
			FieldName		is DataType
				attribute name is "AttributeName"
				element name is "ElementName"
				required
		
		Output Record
			FieldName		is DataType
				attribute name is "AttributeName"
				element name is "ElementName"
				repeating
```

**WSI SERVICE STYLES:**
- **RESTGET** - HTTP GET returning XML structure
- **RESTPOST** - HTTP POST with XML request (one level deep)
- **SOAP_V1** - RPC encoding (deprecated)
- **SOAP_V2** - Document/Literal encoding with namespacing
- **XMLHTTP** - XML request/response for proprietary services
- **FACEBOOK** - Facebook-specific service style

**WSI AUTHENTICATION TYPES:**
- **basic** - HTTP basic authentication
- **token** - Token-based authentication

**WSI ACTION TYPES:**
- **Create** - Create new records
- **Update** - Modify existing records
- **Delete** - Remove records
- **Find** - Search for specific records
- **Instance** - Single record operations
- **List** - Retrieve multiple records

**FIELD ATTRIBUTES:**
- **attribute name is** - XML attribute mapping
- **element name is** - XML element mapping
- **required** - Mandatory input field
- **repeating** - Multiple occurrence output field

**WEBSERVICE INTERFACE EXAMPLE:**
```lpl
AmazonWebService is a WebserviceInterface
	wsdlURL is "http://webservices.amazon.com/AWSECommerceService/AWSECommerceService.wsdl"
	endpoint is "http://soap.amazon.com/onca/soap?Service=AWSECommerceService"
	service is "AWSECommerceService"
	service style is SOAP_V2
	authentication is basic
	
	ItemSearch is a Find Action
		method is "ItemSearch"
		Input Record namespace is "http://webservices.amazon.com/AWSECommerceService/2006-11-14"
			SearchIndex		is Alpha size 50
				element name is "SearchIndex"
				required
			Keywords		is Alpha size 255
				element name is "Keywords"
		
		Output Record
			ASIN			is Alpha size 20
				element name is "ASIN"
			Title			is Alpha size 500
				element name is "Title"
				repeating
```

**SYNCHRONOUS PROCESSING:**
All WSI action types process synchronously, providing immediate response from web service calls.

=== COMPREHENSIVE ACTIONS ANALYSIS RESULTS ===

**ANALYSIS SUMMARY:**
- Total BusinessClass files analyzed: 4,761
- Files with Actions: 4,176 (87.7%)
- Total Actions found: 15,712
- Most common Action types: Create Action (4,373), Instance Action (3,747), Update Action (2,253), Delete Action (2,038), Set Action (1,778)

**TOP ACTION TYPES BY FREQUENCY:**
1. Create Action: 4,373 (27.8%)
2. Instance Action: 3,747 (23.8%)
3. Update Action: 2,253 (14.3%)
4. Delete Action: 2,038 (13.0%)
5. Set Action: 1,778 (11.3%)
6. Purge Action: 783 (5.0%)
7. Action: 665 (4.2%)
8. Import Action: 70 (0.4%)

**MOST COMMON ACTION ATTRIBUTES:**
- restricted: 5,240 (29.8%)
- confirmation required: 514 (2.9%)
- default label is untranslatable: 342 (1.9%)
- run in background: 170 (1.0%)
- resume on error: 181 (1.0%)
- valid when: 87 (0.5%)

**COMPLETE ACTION TYPE SYNTAX SAMPLES:**

**CREATE ACTION:**
```lpl
Create is a Create Action
	Entrance Rules
		if (PreservedOriginalBasis not entered)
			include PreserveBasis
		include ChangeBasis
		include CheckOverrideStructures
	Exit Rules
		if (ThruReportingPeriod entered)
			confirmation required
				"EnteringAThruPeriodCouldDelayResponse._UseASummaryPeriodWhenPossible."
```

**UPDATE ACTION:**
```lpl
Update is an Update Action
	Entrance Rules
		if (OriginalBasis entered)
			if (old ReportingBasis != ReportingBasis)
				include ChangeBasis
	Exit Rules
		if (ThruReportingPeriod entered
		and old ThruReportingPeriod != ThruReportingPeriod)
			confirmation required
				"EnteringAThruPeriodCouldDelayResponse._UseASummaryPeriodWhenPossible."
		if (OriginalBasis entered)
			include CheckOverrideStructures
```

**DELETE ACTION:**
```lpl
Delete is a Delete Action
	Action Rules
		if (Actor = blank)
			confirmation required
				"CAUTION:\DeletingTheSharedAccountAnalysisWillRemoveItForAllUsers."
		if (OriginalBasis entered
		and ReportingBasis != OriginalBasis)
			invoke Purge ReportingBasis
```

**INSTANCE ACTION:**
```lpl
ShareAccountAnalysis is an Instance Action
	valid when (IsPrivate)
	Parameters
		PrmAccountAnalysisSettingsShareName is AlphaUpper size 20
	Parameter Rules
		PrmAccountAnalysisSettingsShareName
			initial value is this instance.AccountAnalysisSettings
	Action Rules
		TempBasis = old ReportingBasis
		invoke Create
			fill in fields from ReportingBasis
			invoked.AccountAnalysisSettings = PrmAccountAnalysisSettingsShareName
			invoked.Description = Description
			invoked.Actor = blank
		OriginalBasis = ReportingBasis
		ReportingBasis = TempBasis
```

**SET ACTION:**
```lpl
MoveAttachmentsToIDM is a Set Action
	restricted
	Instance Selection
		where (Attachment.IsLocal)
	Accumulators
		InstanceCount
	Action Rules
		Instance Rules
			increment InstanceCount
			include IDM.MoveAttachmentsToIDM
				replace AttachmentField with Attachment
			commit transaction
			if (InstanceCount = config.IDM_MOVE_ATTACHMENTS_LIMIT)
				end set action instance loop
```

**PURGE ACTION:**
```lpl
Purge is a Purge Action
	restricted
```

**IMPORT ACTION:**
```lpl
Import is an Import Action
	Action Rules
		if (ThisInstanceRel not exists)
			invoke Create this instance
				invoked.busclass = BusinessClass
```

**COMPLEX INSTANCE ACTION WITH BOD INTEGRATION:**
```lpl
TriggerSyncBillToPartyMasterNativeLPL is an Instance Action
	restricted
	resume on error
	Parameters
		ActionCode is an ActionCode
		ResumeOnError is Boolean
	Action Rules
		if (Company.BODTrigger)
			LocalTitle = "Entity:" + EntityName
			increment bod id.VariationID
			trigger "EntitySyncService" PA service
				resume on error
				title is "<LocalTitle>"
				Criteria
					Company.FinanceEnterpriseGroup
				Variables
					ActionCode
					bod id.VariationID
```

**COMPLEX SET ACTION WITH PARAMETERS:**
```lpl
DeleteMatrixEntityMembers is a Set Action
	restricted
	disable checkpoint
	Parameters
		PrmFinanceEnterpriseGroup is a FinanceEnterpriseGroup
		PrmAccountingEntityGroup is an AccountingEntityGroup
	Instance Selection
		where (FinanceEnterpriseGroup = PrmFinanceEnterpriseGroup
		and AccountingEntityGroup = PrmAccountingEntityGroup
		and MatrixEntityGroupMember)
	Action Rules
		Instance Rules
			invoke Delete
```

**PARAMETER TYPES ANALYSIS:**
- Boolean: 284 (most common parameter type)
- Date: 106
- Alpha size 22: 55
- Text: 49
- Alpha size 100: 45
- AlphaUpper 30: 41
- Numeric 1: 34

**ACTION RULE PATTERNS:**
- invoke: Most common action rule pattern for calling other actions
- include: Used for including rule blocks and shared logic
- confirmation required: Used for user confirmation prompts
- constraint: Used for validation logic
- if/else: Conditional logic execution
- for each: Iteration over collections
- assign result to: Capturing action results
- fill in fields from: Copying field values between entities
- resume on error: Error handling and continuation
- trigger service: External system integration
- commit transaction: Transaction management
- increment: Counter and ID management

=== TRANSIENT FIELDS ANALYSIS - REQUISITION ===

**Total Fields: 36**

**Field Categories:**
1. **Accounting & Financial (6 fields):** TransientAccountingEntity, TransientCreateDate, TransientPostingDate, TransientTaxEntity, TransientGLCalendarPeriod, TransientAllocationPriorityLevel
2. **Patient/Healthcare (9 fields):** Patient information fields including PII data like names, SSN, birthdate
3. **Dropship/Shipping (4 fields):** DropshipRequestingLocation, DropshipRequester, DropShipDefaulting, ReceivingOptions
4. **Item/Line Management (8 fields):** Quantity, UOM, and description fields for current and previous items
5. **Workflow/Status (4 fields):** CurrentApprover, TransientStatus, approval and processing flags
6. **Comments/Attachments (4 fields):** Comment codes, attachments, titles, templates
7. **Utility/Derived (1 field):** TransientMaskSocialSecurityNumber

**Key Characteristics:**
- Most fields use "derive value from" syntax
- Several fields marked with "holds pii" attribute
- Multiple enumerated states for status tracking
- Strong healthcare/patient management focus
- Extensive dropship and shipping workflow support
- Mix of Boolean, Numeric, Alpha, and reference types

**Common Derivation Sources:**
- DerivedFields (calculated values)
- Relations (related entity data)
- Direct field references
- Complex conditional logic for patient info display

**Analysis Results:**
- Comprehensive analysis completed on all 4,761 BusinessClass files
- Detailed breakdown saved to Outputs directory
- Most classes have minimal transient fields (1-5 fields)
- Complex business processes require extensive transient field support
- Tax, financial, and warehouse operations show highest transient field usage
- Context Fields analysis completed for all 4,761 BusinessClass files
- Context Fields primarily support UI display, search, and user interaction
- Financial and BOD integration classes show highest Context Field complexity
- Conditions section analysis completed for Account.busclass
- 12 conditions identified with 83.3% marked as restricted for internal use
- Conditions support UI control, data validation, and business logic enforcement
- Comprehensive Conditions analysis completed for all 4,761 BusinessClass files
- 28.6% of files (1,360) contain Conditions sections with 19,789 total conditions
- 44.8% of conditions are marked as restricted for internal business logic
- SourcingEventResponse has the most conditions (728), followed by RecallNotice (630)
- Most common condition patterns: restricted access, security validation, attachment handling
- **ByVendor2 Set Retrieved:** Complete definition extracted from PayablesInvoice.busclass with 3-field sort order (Company, Vendor, PayablesInvoice) for vendor-based invoice grouping

=== LOCAL FIELDS ANALYSIS ===

**Account.busclass Local Fields (3 main fields):**
1. **LocalSystemAccount** - Reference to SystemAccount with multiple sub-fields:
   - LocalChartAccount (GeneralLedgerChartAccount reference)
   - LocalRejectComment (Alpha up to 500 characters)
   - LocalSystemAccountUpdate (Boolean)
   - LocalSubAccount (GeneralLedgerSubAccount reference)
   - LocalActionCode (ActionCode reference)
   - LocalBODCurrentTimeStamp (BODCurrentTimeStamp reference)
   - LocalNativeLPLBODTrigger (Boolean)
   - NewBODTracker (FSMInboundBODTracker view - conditional)
   - LocalFSMInboundBODTracker (Numeric 15)
   - Error (Boolean)
   - ErrorMessage (Alpha 300)
   - LocalBODTrigger (Boolean)
   - LocalConfigurationParameter (Alpha up to 200)

2. **DerivedSystemAccount** - DerivedField (Boolean, restricted):
   - Returns true if SystemAccount entered, false otherwise
   - Contains multiple derived fields for business logic
   - Includes message fields and count calculations
   - BOD (Business Object Document) integration fields

3. **AllSubAccountsRel** - GeneralLedgerSubAccount set:
   - Collection of related sub-account records
   - Multiple relation definitions for data access

**Local Fields Characteristics:**
- Mix of reference fields, derived fields, and sets
- Extensive BOD integration support (conditional compilation)
- Error handling and validation fields
- Complex derived field logic with conditional returns
- Relationship definitions for data navigation
- Message fields for user feedback
- Timestamp and configuration management

=== COMPREHENSIVE LOCAL FIELDS ANALYSIS (4,761 files) ===

**Statistics:**
- Total BusinessClass files: 4,761
- Files with Local Fields: 2,871 (60.3%)
- Files without Local Fields: 1,890 (39.7%)

**Field Count Distribution:**
- 0 fields: 1,348 files
- 1 field: 241 files
- 2 fields: 489 files
- 3 fields: 495 files (most common)
- 4 fields: 223 files
- 5+ fields: 75 files (complex classes)

**Field Type Distribution:**
- Reference fields: 1,609 (40.4%)
- Set collections: 1,432 (36.0%)
- DerivedField logic: 809 (20.3%)
- Relation mappings: 100 (2.5%)
- MessageField UI: 36 (0.9%)

**Top Complex Classes (6+ Local Fields):**
1. SourcingEvent (8 fields) - Event management with lifecycle
2. RecurringJournalControl (7 fields) - Journal approval workflow
3. StudentActivityBankTransaction (7 fields) - Student finance processing
4. BudgetChangeOrder (6 fields) - Budget modification workflow
5. CashLedgerBatchApproval (6 fields) - Cash management approval
6. CashLedgerElectronicFundsTransferTransaction (6 fields) - EFT processing
7. FinanceDimension2 (6 fields) - Financial dimension management
8. FranchiseSales (6 fields) - Franchise sales processing
9. GeneralLedgerCalendarPeriod (6 fields) - Period management
10. KitchenOrder (6 fields) - Kitchen order processing

**Common Local Field Patterns:**
- BOD Integration: Fields for Business Object Document processing
- Error Handling: Error flags, messages, and exception management
- Validation: Data validation and verification logic
- Configuration: Parameter and setting management
- Relationships: Complex data navigation and filtering
- Derived Logic: Calculated fields with business rules
- State Management: Lifecycle and workflow control
- UI Support: Message fields and display formatting
- Security: Access control and permission checking
- Batch Processing: Background job and async operation support

=== COMPREHENSIVE TRANSIENT FIELDS ANALYSIS (4,761 files) ===

**Statistics:**
- Total BusinessClass files: 4,761
- Files with Transient Fields: 520 (10.9%)
- Files without Transient Fields: 4,241 (89.1%)
- Total Transient Fields found: 5,814

**Field Count Distribution:**
- 1-5 fields: 298 files (57.3%)
- 6-10 fields: 84 files (16.2%)
- 11-20 fields: 75 files (14.4%)
- 21-50 fields: 47 files (9.0%)
- 50+ fields: 16 files (3.1%)

**Top Complex Classes (50+ Transient Fields):**
1. SabrixClient (227 fields) - Tax calculation service integration
2. ProjectFundingSource (202 fields) - Project funding management
3. WarehouseShipmentLine (177 fields) - Warehouse shipping operations
4. PayablesInvoiceDistribution (131 fields) - Invoice distribution processing
5. PayablesInvoice (122 fields) - Invoice management
6. TrueCostAllocationLine (120 fields) - Cost allocation processing
7. FinanceEnterpriseGroup (105 fields) - Financial enterprise management
8. ApprovalProcessor (99 fields) - Approval workflow processing
9. AssetBookTransaction (92 fields) - Asset transaction management
10. RequisitionLine (89 fields) - Requisition line item processing

**Common Transient Field Patterns:**
- Derived Calculations: Fields computed from other data sources
- UI Support: Display formatting and user interface fields
- Workflow States: Temporary status and processing flags
- Data Transformation: Converting between different data formats
- Validation Logic: Temporary fields for business rule checking
- Integration Support: Fields for external system communication
- Performance Optimization: Cached calculated values

=== AREAS NEEDING FURTHER EXPLORATION ===

**1. DataLink Expressions:**
- Complete syntax and usage patterns
- Navigation through business object relationships
- Hierarchical traversal examples
- Set operations and filtering syntax

**2. Rule Blocks:**
- Definition syntax and structure
- Parameter replacement mechanisms
- Reusability patterns across actions
- Include statement variations

**3. BOD Integration Patterns:**
- Complete Business Object Document workflow
- BOD trigger mechanisms and timing
- Service integration syntax
- Error handling in BOD operations

**4. Pattern Implementation:**
- "implements" keyword usage
- Pattern definition syntax
- Common pattern libraries (BODId, etc.)
- Pattern inheritance and composition

**5. Ontology Definitions:**
- Symbolic key definition syntax
- Business meaning linkage
- Relationship mapping in ontology
- Entity identification patterns

**6. Advanced Relation Types:**
-  Symbolic key vs custom mapping clarified
- Complex field mapping scenarios
- Multi-level relationship navigation
- Performance considerations

**7. Context Field Compilation:**
- #ifdef conditional compilation syntax
- Build-time vs runtime field inclusion
- Environment-specific field definitions
- Conditional field attribute application
- User Context: Session and user-specific temporary data

=== COMPREHENSIVE CONTEXT FIELDS ANALYSIS (4,761 files) ===

**Statistics:**
- Total BusinessClass files: 4,761
- Files with Context Fields: 520 (10.9%)
- Files without Context Fields: 4,241 (89.1%)
- Total Context Fields found: 49,188

**Top Complex Classes (500+ Context Fields):**
1. PayablesInvoicePayment (1,020 fields) - Invoice payment processing
2. CompanyCustomer (769 fields) - Customer management

=== COMPLEX BUSINESS CLASS EXAMPLE ===

**PayablesInvoiceDistribution.busclass** - Comprehensive example demonstrating:
- 60+ Persistent Fields with multiple data types and states
- 10 Transient Fields with derived calculations
- 7 Local Fields including DerivedField logic and MessageField
- 5 Derived Fields with complex conditional logic
- 8 Conditions for business rule validation
- 8 Relations including one-to-one and one-to-many mappings
- 5 Sets with sorting and filtering
- Comprehensive Field Rules with constraints and validation
- 8 Actions including Create, Update, Delete, Approve, Reject
- 4 Rule Blocks for reusable business logic
- Advanced patterns: BOD integration, approval workflows, budget validation
- Security features: PII handling, restricted fields, audit trails
- Integration support: external systems, error handling, sync status

**Key Features Demonstrated:**
- States for enumerated values (ApprovalStatus, DistributionType, WorkflowStatus)
- Field attributes (required, restricted, holds pii, delete ignored)
- Complex derived calculations with conditional logic
- Comprehensive validation rules with dynamic error messages
- Approval workflow integration with history tracking
- Budget validation and control mechanisms
- Tax calculation and withholding tax processing
- Asset distribution handling
- Multi-currency support with exchange rates
- Attachment and document management
- BOD (Business Object Document) integration
- Audit trail and change tracking
- Error handling and integration status management

=== CONFIGURATION CONSOLE GENERAL DEFINITIONS ===

=== AI INTERACTION LOG ===
- User greeted AI with knowledge base context active
- Ready to assist with LPL programming language questions and code generation
- Knowledge base contains comprehensive syntax patterns, field types, and action definitions
- Analyzed 'Lowercase to Uppercase.txt' reference file

=== STRING FORMATTING FUNCTIONS ===
- LPL supports string formatting using format specifiers
- "%1S" format specifier converts text to uppercase
- "%1s" format specifier converts text to lowercase
- Syntax: FieldName = SourceField using "FormatSpecifier"
- Examples:
  - FieldName = FieldName using "%1S" (converts field to uppercase)
  - FieldName = FieldName using "%1s" (converts field to lowercase)
- Format specifiers provide text transformation capabilities in field assignments

=== DATE FORMATTING PATTERNS ===
- LPL uses StringField derived fields with regex patterns for date manipulation
- Common pattern: Convert YYYYMMDD to MM/DD/YYYY format
- StringField syntax: FieldName is a StringField with regex patterns
- Regex patterns for date extraction:
  - "^.{0,4}" - removes first 4 characters (year extraction)
  - ".{0,2}$" - removes last 2 characters
  - "^.{0,6}" - removes first 6 characters (day extraction)
  - ".{0,4}$" - removes last 4 characters (year extraction)
  - "^.*" + "\Q" + "0" + "\E" - removes leading zeros
- Field subtraction operator (-=) removes regex-matched patterns
- String concatenation (+) combines formatted components
- Conditional logic (if statements) handles leading zero removal
- Example workflow: Extract components  Remove leading zeros  Concatenate with separators

=== REGEX PATTERNS AND STRING MANIPULATION ===
- StringField derived fields support complex regex operations
- Common regex patterns:
  - "[^0-9]" - removes all non-numeric characters
  - "^[E-Z].*" - matches strings starting with letters E through Z
  - "^.*" + "\Q" + " " + "\E" - removes spaces (literal matching with \Q...\E)
  - "^.{0,n}" - removes first n characters
  - ".{0,n}$" - removes last n characters
  - "\Q" + "," + "\E\Z.*$" - removes trailing comma at end of string
- Field Rules support regex validation with matches operator
- Leading zero padding using conditional DerivedField logic
- Text extraction and parsing using StringField subtraction
- Literal string matching with \Q...\E escape sequences
- Complex string processing in Action Exit Rules
- Trailing character removal using \Z anchor for end-of-string matching
- Dynamic string building with conditional concatenation followed by cleanup

=== DATA PARSING WITH REGEX ===
- Complex text parsing using multiple StringField derived fields
- Line-by-line parsing using newline character (\u000A) patterns
- Pipe delimiter parsing with first vs last occurrence handling
- Multi-step parsing workflow using DerivedField chaining
- Common parsing patterns:
  - "^." + "\Q" + "|" + "\E" - removes text before first pipe
  - "^.*" + "\Q" + "|" + "\E" - removes text before last pipe
  - "\Q" + "\u000A" + "\E.*" - removes text after newline
  - "^.*" + "\Q" + "\u000A" + "\E" - removes text before newline
  - "^" + "\Q" + "A" + "\E" - matches strings starting with 'A'
- Sequential processing: Extract lines  Process individually  Recombine with delimiters
- Unicode escape sequences (\u000A) for special characters like newlines
- DerivedField chaining for complex multi-step text transformations

=== DATE EXTRACTION AND FORMATTING ===
- Date component extraction using built-in date functions
- Current date access with "return current date" syntax
- Month extraction using "FieldName month" syntax
- Conditional formatting for consistent digit display
- Two-digit formatting pattern:
  - Extract date component (returns single digit for months 1-9)
  - Check string size using "size" operator
  - Conditionally prepend "0" for single-digit values
  - Return formatted two-character string
- Date component functions: month, day, year extraction
- String size checking with "size" operator for conditional logic
- Zero-padding technique for consistent date formatting

=== DATE ARITHMETIC AND SYSTEM FUNCTIONS ===
- System date access with "system current date" function
- Date arithmetic using addition/subtraction operators
- Day-based calculations: "system current date - 90 days"
- Configuration console date field patterns
- Relative date calculations for default values
- System date functions provide dynamic date initialization
- Date arithmetic supports days, months, years operations
- Common pattern: "return (system current date - N days)" for historical dates

=== UNICODE CHARACTER SUPPORT ===
- Unicode characters supported in text strings and labels
- Unicode escape sequence format: \uXXXX (4-digit hexadecimal)
- Common Unicode characters:
  - \u00A0 - Non-breaking space (NBSP)
  - \u000A - Line feed (newline)
  - \u0009 - Tab character
- Unicode usage in default labels and field text
- Untranslatable labels support Unicode formatting
- Special character handling in business text fields
- International character support for multilingual applications

=== FIELD MANIPULATION TECHNIQUES ===
- String case conversion using format specifiers (%1S for uppercase)
- Substring extraction using bracket notation [start:end]
- Zero-based indexing for substring operations
- Substring patterns:
  - [0:3] - first three characters (positions 0,1,2)
  - [1:4] - characters 2-4 (positions 1,2,3)
  - [3:6] - characters 4-6 (positions 3,4,5)
- Date component extraction with conditional logic
- Fiscal quarter calculation using nested if statements
- Month range checking for quarter determination
- Complex conditional logic with multiple and/or operators
- Field assignment within conditional blocks
- Date arithmetic and component access (month, day, year)
- Derived field calculations with business logic

=== COMPREHENSIVE SYNTAX EXAMPLES FROM SESSION ===

**STRING FORMATTING AND CASE CONVERSION:**
```lpl
// Uppercase conversion
FieldName = FieldName using "%1S"
// Lowercase conversion
FieldName = FieldName using "%1s"
```

**DATE FORMATTING AND EXTRACTION:**
```lpl
// Date component extraction with regex
UPHSMilestoneDateGetMonth is a StringField
    type is Alpha size 100
    "^.{0,4}"  // removes first 4 characters

// Current date and arithmetic
ZZZCurrentDate is a DerivedField
    type is Date
    return current date

// System date with arithmetic
return (system current date - 90 days)

// Two-digit month formatting
ZZZMonthTwoChar is a DerivedField
    type is Alpha size 2
    if (ZZZMonth size < 2)
        return ("0" + ZZZMonth)
    else
        return (ZZZMonth)
```

**REGEX PATTERNS AND STRING MANIPULATION:**
```lpl
// Remove trailing comma
UPHSRemoveLastComma is a StringField
    type is Alpha size 100
    "\Q" + "," + "\E\Z.*$"

// Parse lines using newline
RemoveAfterNewLine is a StringField
    type is Alpha size 100
    "\Q" + "\u000A" + "\E.*"

// Remove non-numeric characters
UPHSMilestoneNameRemoveAllNonNumeric is a StringField
    type is Alpha size 100
    "[^0-9]"

// Field validation with regex
Field Rules
    PrmVendor
        if (PrmFromCompanyLocation.FromLocation matches "^[E-Z].*")
            required
```

**SUBSTRING OPERATIONS:**
```lpl
// First three characters
ZZZThreeChar is a DerivedField
    type is Alpha size 3
    return Reference1[0:3]

// Substring ranges
return Reference1[1:4]  // Characters 2-4
return Reference1[3:6]  // Characters 4-6
```

**COMPLEX CONDITIONAL LOGIC:**
```lpl
// Fiscal quarter calculation
ZZZQuarter is a DerivedField
    type is Numeric size 1
    if (ZZZMyDate month >= 1 and ZZZMyDate month <= 3)
        ZZZQuarter = 1
    else
        if (ZZZMyDate month >= 4 and ZZZMyDate month <= 6)
            ZZZQuarter = 2
        else
            if (ZZZMyDate month >= 7 and ZZZMyDate month <= 9)
                ZZZQuarter = 3
            else
                ZZZQuarter = 4
```

**UNICODE AND SPECIAL CHARACTERS:**
```lpl
// Unicode in labels
default label is untranslatable:"text\u00A0with\u00A0non-breaking\u00A0spaces"

// Common Unicode characters
// \u00A0 - Non-breaking space
// \u000A - Line feed (newline)
// \u0009 - Tab character
```

**DYNAMIC STRING BUILDING:**
```lpl
// Build comma-separated list
if (UPHSContractCSEYr1E11IsHUP)
    UPHSContractUPHSCorporateEntity1 += "HUP,"
if (UPHSContractCSEYr1E11IsCCH)
    UPHSContractUPHSCorporateEntity1 += "CCH,"
// Remove trailing comma
UPHSContractUPHSCorporateEntity1 -= UPHSRemoveLastComma
```

**LEADING ZERO PADDING:**
```lpl
TestWithLeadingZeroes is a DerivedField
    type is Alpha size 8
    if (Test < 10)
        return ("0000000" + Test)
    if (Test < 100)
        return ("000000" + Test)
    // ... continue pattern
```

**MULTI-STEP TEXT PROCESSING:**
```lpl
// Extract and recombine with custom delimiter
FinalLine is a DerivedField
    type is Alpha size 300
    return (FirstLine + Delimiter + SecondLine + Delimiter + ThirdLine)

Delimiter is a DerivedField
    type is Alpha size 10
    return "@"
```

**SCOPE AND COMMENTS:**
- Scope is defined by indent level (4 spaces or 1 tab)
- Comments are denoted by double forward slash //
- @SuppressWarnings in comment suppresses all warnings for that LPL line
- @External in comment suppresses dead code detection/reporting

**BASE DEFINITIONS:**
```lpl
LPLConstructName ::= <uppercase character>[<alphanumeric characters>] // up to 255 characters

ActionName ::= <LPLConstructName>
ActionTag ::= <LPLConstructName>
BusinessClass ::= <LPLConstructName>
BusinessTask ::= <LPLConstructName>
CardViewName ::= <LPLConstructName>
ConditionName ::= <LPLConstructName>
ChartName ::= <LPLConstructName>
ColumnarRelationName ::= <LPLConstructName>
ContextMessage ::= <LPLConstructName>
CriteriaName ::= <LPLConstructName>
CubeLinkName ::= <LPLConstructName>
CubeRelationName ::= <LPLConstructName>
DetailSectionName ::= <LPLConstructName>
DrillName ::= <LPLConstructName>
DrillListName ::= <LPLConstructName>
FieldGroupName ::= <LPLConstructName>
FieldName ::= <LPLConstructName>
FormInvokeName ::= <LPLConstructName>
FormName ::= <LPLConstructName>
FullStateName ::= <StateName>[.<StateName>]
GroupName ::= <LPLConstructName>
HierarchyName ::= <LPLConstructName>
ImageMapName ::= <LPLConstructName>
ListName ::= <LPLConstructName>
MajorSystemProcess ::= <LPLConstructName>
MatrixForm ::= <LPLConstructName>
MenuItemName ::= <LPLConstructName>
MenuName ::= <LPLConstructName>
M3Interface ::= <LPLConstructName>
NavigationName ::= <LPLConstructName>
PageName ::= <LPLConstructName>
PanelName ::= <LPLConstructName>
PaneName ::= <LPLConstructName>
ParameterName ::= <LPLConstructName>
PeriodViewName ::= <LPLConstructName>
PFlowServiceName ::= <LPLConstructName>
ProgramName ::= <LPLConstructName>
RelationName ::= <LPLConstructName>
ReportName ::= <LPLConstructName>
RuleBlockName ::= <LPLConstructName>
RuleBlocks ::= <LPLConstructName>
SectionName ::= <LPLConstructName>
SecurityClaim ::= <LPLConstructName>
SecurityClassName ::= <LPLConstructName>
SetName ::= <LPLConstructName>
StateName ::= (<LPLConstructName> | <#>)
StateCycleName ::= <LPLConstructName>
StateFieldName ::= <LPLConstructName>
StaticJavaWS ::= <LPLConstructName>
StaticJavaPD ::= <LPLConstructName>
Subject ::= <LPLConstructName>
TableName ::= <LPLConstructName>
TextVariable ::= <LPLConstructName>
WidgetListName ::= <LPLConstructName>
WebAppName ::= <LPLConstructName>
WebserviceInterface ::= <LPLConstructName>
```

**NAMING CONVENTIONS:**
```lpl
Parens ::= ('(' | ')')
ModuleName ::= <alphanumeric characters>
ModuleDescription ::= <Literal>
ClassicPrefix ::= prefix is <string of 2 to 5 alphanumeric characters>
ClassicName ::= classic name is <Literal> // literal must be all uppercase, no spaces
ClassicNameForField ::= classic name for <FullFieldName> is <Literal>
RpgName ::= rpg name is <Literal>
SqlPrefix ::= sql prefix is <string of 2 to 5 alphanumeric characters> // no spaces
SqlName ::= sql name is <Literal> // no leading or trailing spaces allowed
SqlNameForField ::= sql name for <FullFieldName> is <Literal>
```

**DATA AND FIELD TYPES:**
```lpl
DimensionField ::= <dimension RelatedField> // includes isAggregatable attributes
FieldSize ::= <numeric characters>
KeyField ::= <keyfield FullFieldName>
Literal ::= <any character except whitespace or angle brackets>
NbrDecimals ::= <numeric characters>
Number ::= [-]<numeric characters>[.<numeric characters>]
# ::= <numeric characters>
Percent ::= <Number>%
ReportText ::= (<alphanumeric characters> | ':')
Text ::= '"'<alphanumeric characters>'"'
ViewField ::= <view FullFieldName>
```

**DATA DEFINITION SYNTAX:**
```lpl
DataDefinition ::= (
    is a[n] <FieldName>
    | is like <FieldName> // must be a simple field; determines only type and size
    | is a[n] <BusinessClass> group [in subject <Subject>]
    | is a[n] <BusinessClass> compute [in subject <Subject>] [measures only]
    | is <TypeDataDefinition>
)
```

**PRIMITIVE TYPES:**
```lpl
PrimitiveType ::= (
    Alpha | AlphaRight | AlphaUpper
    | Anniversary // cannot translate
    | Binary Document | BinaryObject
    | Boolean // cannot translate
    | BusinessObjectReference [to <BusinessClass>] // cannot translate
    | CSVText // cannot translate
    | Date // cannot translate
    | [Unsigned] Decimal // cannot translate
    | DocumentTitle // Alpha field with special characteristic
    | EmailAddressField [with multiple addresses]
    | MultiEmailAddressField
    | GroupField // cannot translate
    | Integer // cannot translate
    | Iteration of <BusinessClass> // cannot translate
    | JSONObject // cannot translate
    | MimeType // cannot translate
    | Numeric // cannot translate
    | Password // cannot translate
    | [Unsigned] Percent // cannot translate
    | Period // cannot translate
    | RichText | Text | TextDocument // cannot translate
    | Time // cannot translate
    | TimeStamp // cannot translate
    | UniqueID // cannot translate
    | URI | URL
    | XMLDocument // cannot translate
    | Year // cannot translate
)
```

**TYPE DATA DEFINITION:**
```lpl
TypeDataDefinition ::=
[us-ascii]<PrimitiveType> [[size (fixed | up to)] <FieldSize>[.<NbrDecimals>]]
// 'up to' means variable size field (varchar)
// 'up to' on LOB types restricts LOB size
// 'fixed' is default, warning generated on 30+ spaces unless fixed designated
// valid on Alpha and AlphaUpper only
// FieldSize is overall field size. Decimal 12.2 means 12 total digits, 2 after decimal
```

**FIELDS AND VALUES:**
```lpl
BODId ::= bod id // references BODId GroupField if BusinessClass implements BODId
BusinessObjectReference ::= <FieldName> // Field of type BusinessObjectReference
CurrentAsyncId ::= current async action request id // valid only in background action
CurrentActionBackgroundGroupId ::= current action background group id // valid only in background action
DefaultLabel ::= default label is (<LiteralMessage> | untranslatable)
// 'untranslatable' marks base translation text as untranslatable
// Overrides default base label translation text
DocumentLocation ::= document location.(Local | AWS S3 | External)
```

**FIELD OR ARRAY NAME:**
```lpl
FieldOrArrayName ::= (<FieldName> | <ArrayComponent>)
FullFieldName ::= (
    <FieldOrArrayName>[.<FieldOrArrayName>]
    | <CreateStamp> | <CreateDate> | <UpdateStamp> | <RelevanceScore>
    | <ActionAttribute> | <BODId> | <CurrentAsyncId> | <CurrentActionBackgroundGroupId>
    | has future changes // Boolean field; returns true if future-dated records exist
    | user fields[<Parens><BusinessClass><Parens>]
)
```

**JAVA FORMAT:**
```lpl
JavaFormat ::= '"'(<Literal> | '<'<RelatedValue>'>')'"'
// Must resolve to JavaFormat as defined in java.util.Formatter
// http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html
```

**RELEVANCE SCORE:**
```lpl
RelevanceScore ::= relevance score
// Returns relevance score from text search  valid only on List Definition
```

**STATES:**
```lpl
States ::
States
<StateName> value is <Literal> [with <Icon>]
[<DefaultLabel>]
```

**VALUE:**
```lpl
Value ::= (
    <Text> | <Number> | <#> [(year[s] | month[s] | day[s])]
    | <Percent> | <Constant> | <ActionTagValue> | <StateFieldName>
)
```

=== CONFIGURATION CONSOLE BASE DEFINITIONS ===

**OPERATORS:**
```lpl
AsOfDate ::= (
    as of (<RelatedValue> | all dates)
    | after <RelatedValue>
    | before <RelatedValue>
    | between <RelatedValue> and <RelatedValue>
) // RelatedValue must be a Date or TimeStamp

AsOfOperator ::= <Parens><AsOfDate><Parens>

Constant ::= (true | false | blank | high value)

CreateOrUpdateMode ::= mode
// valid only in the title of a Form; results in 'Create' or 'Update'

FieldOperator ::= (
    not // valid only with a Condition
    | ! // "
    | no // "
    | old
    | any // valid only with multi-valued (array, otm) RelatedField or RelatedCondition
    | all // "
    | first // "
    | last // "
    | sum // "
    | avg // "
    | min // "
    | max // "
    | floor | ceiling | pending
    | instance count of // "
    | sizeofarray
    | (first | last) iteration of // valid with a OTM RelatedLink only
    | next // valid on Iteration fields only
    | previous // "
    | reference to // valid only with a OTO RelatedLink only  returns the BusinessObjectReference
    | target of // valid only with an "is related value" designated field
)

LinkOperator ::= (first | last)

PeriodOperator ::= (
    [(prior | next) year [<#>]] [(prior | next)] (period[s] | week[s] | month[s]
    | quarter[s] | [all] year[s]) [<#> [thru <#>]]
    | [(prior | next) year [<#>]] [(prior | next)] (period | week | month
    | quarter | year) [<#>] (beginning | ending) [ytd] balance
)

PeriodLabel ::= period label
// valid only in the context of a period in a Cube View

TotalOperator ::= (running total | percent of total)
```

**TYPE OPERATORS:**
```lpl
TypeOperator ::= (
    decimals // valid with a Decimal type field only
    | type // field type  returns string of <PrimitiveType>
    | size // size of the 'string' value of a field
    | uppercase | lowercase
    | year // valid with Date and TimeStamp fields only
    | month // "  1-based month number (1-12)
    | month [short] name // "
    | day // "  1-based day number (1-31)
    | day [short] name // "
    | week day // "  1-based week day number (1-7)
    | corporate week day // week day based on corporate TimeZone
    | week day using <RelatedValue> // week day based on RelatedValue TimeZone
    | year day // "  1-based year day number (1-366)
    | week // "  1-based week day number (1-52)
    | week year // "  year corresponding to week operator
    | days in month // "  number of days in the date's month (28-31)
    | days in year // "  number of days in the date's year (365 or 366)
    | as years // valid with Numeric type field only  treats value as number of years
    | as months // valid with Numeric type field only  treats value as number of months
    | as days // valid with Numeric type field only  treats value as number of days
    | hours // valid with Time type fields only  Decimal total hours since day beginning
    | minutes // "  Decimal total minutes since beginning of day
    | seconds // "  Decimal total seconds since beginning of day
    | date // valid with TimeStamp type fields only (returns Date in GMT time zone)
    | corporate date // valid with TimeStamp type fields only (returns Date in corporate time zone)
    | system date // valid with TimeStamp type fields only (returns Date in system's default time zone)
    | date using <RelatedValue> // valid with TimeStamp type fields only, RelatedValue must be a TimeZone
    | time // valid with TimeStamp type fields only
    | anniversary // valid with Date and TimeStamp type fields only
    | period // valid with Date and TimeStamp type fields only
    | levels // valid with array fields only. Defines number of entries up to and including last entered value
    | level <#> // valid with key field that is a hierarchy; specifies which level in the hierarchy to address
    | entries // valid with array fields only. Defines number of entered fields in the array
    | compact format // valid only with a field that implements CompactFormat
    | version // valid only with a key field that implements Versioning; will address the version field
    | label // returns the translated label for the field
    | [full] name // returns the LPL name or full name of the field
    | text // valid only with a field that has Text Variable; retrieves the text with the variables replaced
    | [exact] translation // returns the data translation for the current local  "exact" will prevent standard defaulting
    | mime type // valid with BinaryDocument and BinaryObject only
    | in base64 // valid with BinaryDocument and BinaryObject only
    | translations // returns the set of data translation for a field; valid on right side of assignment operator only
    | document location // returns <document location.(Local, S3, External)>; can be modified
    | (local | external) document // returns the local or external document; external includes AWSS3 location
    | select <SelectStatement>
    | select line <SelectLineStatement>
    | document [for <RelatedLink>] // valid only with a field that is a 'document template'
    | compute value [for <RelatedLink>] // valid with a field that is a BusinessClassCompute only
    | as of <RelatedValue> // related value must be a Date or TimeStamp
    | (date | audit entry) (first | last | next) changed [(from | to) <RelatedValue>]
    | days was <RelatedValue> [while <Condition>] [between <RelatedValue> and <RelatedValue>]
    | weighted average [between <RelatedValue> and <RelatedValue>]
    | <PeriodOperator>
    | cube dimension value [using year of <RelatedValue>]
    | input value // always returns the input value on a transient field with a derived value
    | plain text // strips all formatting (except new line) from RichText fields
    | split [on <Literal>] // splits string into an array of strings using 'Literal' as separator (comma is default)
    | using <JavaFormat> [using <RelatedValue>] // RelatedValue valid only with TimeStamp and must be a TimeZone
    | (short | medium | long) timestamp [with day [short] name] [(show | hide) time zone][(show | hide) seconds] [using <RelatedValue>]
    | (short | medium | long) date [with day [short] name] [using <RelatedValue>]
    | (short | medium | long) anniversary [with day [short] name] [using <RelatedValue>]
    | (short | medium | long) period [using <RelatedValue>]
)
```

=== CONFIGURATION CONSOLE DATA AND FIELD TYPES ===

**DATES AND TIME STAMPS:**
```lpl
CreateDate ::= create date // returns the most recent create date from the current 'as of' date

CreateEffectiveDate ::= create effective date
// returns the most recent create effective date from the current 'as of' date

CreateStamp ::= create stamp[.actor] // references the CreateStamp in the business class
// by itself it is the actual TimeStamp when the instance was created
// the actor keyword references the actor who created this instance

CurrentDateTime ::= (
    current [(corporate | user)] time
    | [system] current [(corporate | user)] date
    | [system] current [(corporate | user)] year
    | [system] current [corporate] period
    | [system] current timestamp
    | [system] current [(corporate | user)] anniversary
)

DurationVars ::= (
    duration begin date
    | duration end date
)

TimeZoneVar ::= (
    user time zone
    | corporate time zone
)

UpdateStamp ::= update stamp[.actor]
// references the UpdateStamp in the business class
// by itself it is the actual TimeStamp when the instance was last updated
// the actor keyword references the actor who last updated this instance
```

**REFERENCES:**
```lpl
BaseURL ::= base url<Parens>webapp is <WebAppName><Parens> // references the current base url context

BusinessClassTotal ::= total<Parens><BusinessClass>.<RelatedValue>[,<DimensionField> = <RelatedValue>]<Parens>
// first RelatedValue must be a defined TotalName on the specified BusinessClass
// DimensionField is a dimension in the BusinessClass

ConfigCategory ::= <Literal>

ConfigVar ::= [stack]config [<Parens><ConfigCategory><Parens>].<Literal>
// Allows reference to a configuration variable. Configuration variables are defined in the BusinessClass
// ConfigurationParameter - if it is not found it is blank
// 'stackconfig' checks the parameter at the dataarea, then the tenant, then the stack
```

**DATA LINK:**
```lpl
DataLink ::= [<LinkOperator>]
(
    <KeyField> [set]
    | <hierarchy KeyField> (
        parent
        | [and] children
        | [and] siblings
        | [and] descendants
        | [and] ancestors
        | ascendant
    )
    | <RelationName>
    | <CubeRelationName>
    | <ColumnarRelationName>
    | <BusinessClass>[<Parens>(<KeyField> | <BusinessObjectReference>)<Parens>] [set]
    | <BusinessObjectReference>[<Parens><BusinessClass><Parens>]
    | <BusinessClassTotal>
    | <Agent>
    | <SessionKey>
    | actor.context.<KeyField>
    | audit log records [descending] // retrieves the set of past and future (effective-dated) records
    | [(draft | in process | completed | rejected)] [<BusinessClass>.Create] action requests
    | this instance
    | related // valid within a Relation Definition
    | from // valid within a where condition on an OTM DataLink
    | each[<Parens><LPLConstructName><Parens>] // valid within a for each loop
    | invoked // valid within an invocation
    | result // valid within an invocation
    | child // valid within Parent Attach Rules
    | cube[<Parens><BusinessClass><Parens>] // used to address the AnalyticCube business class
    | cube drill set // used to address the drill set from an AnalyticCube
    | <TimeZoneVar>
)
[<AsOfOperator>]
[<Parens>locale of <RelatedValue><Parens>] // RelatedValue must be an IsoLocale
[<Parens>where <Condition><Parens>]
[<Parens>level <#><Parens>] // only valid on a hierarchy KeyField
```

**DISTINCT:**
```lpl
Distinct ::= distinct (<FullFieldName> | <FieldGroupName>)
// Currently used in 'for each' rule only. Returns a set of instances where the Field (or Fields)
// are distinctthat is, no duplicates of Field (or Fields) will be returned. The instances
// returned will have only the distinct fields filled out as well as any fixed fields, such as higher
// level keys that are fixed in the related definition.
```

**DOC TEMPLATE:**
```lpl
DocTemplate ::= (template.<Literal> | template name.<RelatedField>)
// Allows reference to an XML, JSON, Word rtf, or PDF template stored in the UserTemplate business class
```

**INLINE EQUATION:**
```lpl
InlineEquation ::= [<Parens>]<RelatedValue> <MathOperator> <RelatedValue>[<Parens>]
// A basic InlineEquation (A + B) can also be considered a RelatedValue, because InlineEquation is an option of
// RelatedField, which is an option of RelatedValue. This means it can be used as a RelatedValue in the more complex
// InlineEquation ((A + B) + C), where (A + B) is the first <RelatedValue> in the InlineEquation, the second + is
// the <MathOperator>, and C is the second <RelatedValue>.
```

**LOGICAL ID:**
```lpl
LogicalID ::= logical id // logical id is set in LogicalIdMapping
```

**PARENT CONTEXT:**
```lpl
ParentContext ::= parentcontext.(
    isbusclass | name | locale | stereotype | istransaction | module | dataarea
    | <SymbolicKeyVar> | isbustask
)
// 'parentcontext' refers to the parent context of the current context
// symbolickey retrieves the context information of the Symbolic Key that this business object is 'centered' on
// If the business object is not defined directly via a Symbolic Key but is defined as being 'part of' some other
// business class then it gets the context information of the Symbolic Key of that business class.
```

**PHRASE:**
```lpl
Phrase ::= phrase[<Parens>locale of <RelatedValue><Parens>].<Literal>
// Allows reference to a translatable phrase. Phrases are defined in the UserPhrase business class.
```

=== CONFIGURATION CONSOLE REFERENCE GUIDE LEARNINGS ===

**CONFIGURATION CONSOLE OVERVIEW:**
- Tool in Infor Rich Client for administrators to modify Landmark applications
- Changes apply across application and to all users in real-time
- Creates database configurations that overlay original LPL source files
- Original LPL source files remain protected and unmodified
- Configurations are dynamic and take effect immediately

**CONFIGURATION TYPES:**
- Application: Look-and-feel changes, menus, pages, UI objects, business class actions
- Security: Creation and modification of security classes, actor/identity/role records
- Web Services: Creation of new web services for non-Landmark system integration

**LPL SYNTAX FUNDAMENTALS:**
- Scope defined by indent level (4 spaces or 1 tab)
- Comments denoted by double forward slash //
- @SuppressWarnings suppresses LPL line warnings
- @External suppresses dead code detection
- LPLConstructName: uppercase character followed by alphanumeric (up to 255 chars)

**CORE DATA TYPES:**
- Alpha/AlphaRight/AlphaUpper: Text strings with size limits
- Boolean: True/false values (cannot translate)
- Date/Time/TimeStamp: Date/time values (cannot translate)
- Numeric/Integer/Decimal: Numeric values (cannot translate)
- Text/RichText: Long text content
- BinaryDocument/BinaryObject: Binary data
- XMLDocument/JSONObject: Structured data (cannot translate)
- EmailAddressField/MultiEmailAddressField: Email handling
- Password/UniqueID: Security and identification

**FIELD ATTRIBUTES:**
- text searchable: Field indexed for text search
- scannable: Field can be scanned
- holds pii: Contains personally identifiable information
- translatable: Supports data translation
- restricted: Cannot be used on UI
- protected: Application-controlled, no UI/webservice updates
- required: Mandatory field
- encrypt: Field encrypted in database (Alpha only)

**OPERATORS AND CONDITIONS:**
- Comparison: =, !=, >=, <=, >, <, !>, !<
- Text: like, contains, matches (regex)
- Range: within, overlaps, between
- Logical: and, or, ! (not)
- Field states: entered, exists, changed, in context
- Date operators: as of, after, before, between

**BUSINESS CLASS PATTERNS:**
- Auditing: Automatic audit trail (default for non-Classic classes)
- EffectiveDated: Time-based data versioning (default for non-Classic)
- UniqueID: Unique identifier for direct addressing
- ReadOnly: Prevents updates
- WorkFile: Temporary processing data
- InMemoryCache: Cached data retrieval
- AnalyticCube: OLAP cube functionality
- BODId: Business Object Document identification
- Encrypted: Field-level encryption

**ACTION TYPES AND USAGE:**
- Create Action: Entity creation with validation
- Update Action: Entity modification
- Delete Action: Virtual delete (marks as deleted)
- Purge Action: Physical delete (removes from database)
- Instance Action: Single entity operations without field rules
- Set Action: Bulk operations on filtered record sets
- Import Action: Data import processing
- Preview Action: Update simulation without persistence

**UI DEFINITION STRUCTURE:**
- Forms: Data entry and display interfaces
- Lists: Tabular data presentation with filtering/sorting
- Navigations: Application flow control
- Drills: Context-sensitive navigation options
- Pages: Container for panels and content
- Menus: Application navigation structure

**FORM CONTROLS:**
- CheckControl: Checkbox, switch, or star display
- CaptchaControl: Security verification
- FormButton: Action triggers
- FormText: Static text display
- ManualRepresentation: Custom field rendering

**LIST FEATURES:**
- TreeView: Hierarchical data display
- CubeView: OLAP data analysis
- ColumnarView: Column-based layout
- GalleryView: Card-based presentation
- AttachmentList: File attachment management
- AuditList: Change history tracking

**SECURITY AND ACCESS:**
- Actor-based security model
- Role and group-based permissions
- Context-sensitive access control
- Anonymous access support for specific actions
- Privileged actions for system operations

**CONFIGURATION BEST PRACTICES:**
- Test configurations in provisional environment before production
- Use Configuration Console UI rather than manual LPL editing
- Manual LPL modifications are unsupported and at own risk
- Verify configurations using cdverify utility
- Compare configuration versions to identify issues

**INTEGRATION CAPABILITIES:**
- BOD (Business Object Document) support for system integration
- Web service interfaces for external system connectivity
- Process Flow integration for workflow management
- ION (Infor Operating Network) message handling
- Email and notification services

**PERFORMANCE CONSIDERATIONS:**
- InMemoryCache pattern for frequently accessed data
- Indexed sets for faster retrieval
- Lazy loading for large datasets
- Background processing for long-running operations
- Checkpoint management for Set Actions
3. FinanceEnterpriseGroup (734 fields) - Financial enterprise operations
4. FSMPOInboundBODImport (713 fields) - Purchase order BOD import
5. Requester (598 fields) - Requisition requester management
6. PurchaseOrder (589 fields) - Purchase order processing
7. SupplierSourceId (536 fields) - Supplier identification
8. FSMAPInboundBODImport (512 fields) - Accounts payable BOD import
9. FinanceDimension2 (498 fields) - Financial dimension management
10. ProjectFundingSource (482 fields) - Project funding operations

**Field Type Distribution:**
- Reference fields (a/an): 23,441 (47.7%)
- Alpha strings: 6,499 (13.2%)
- Like references: 5,277 (10.7%)
- Boolean flags: 2,888 (5.9%)
- Numeric values: 2,781 (5.7%)
- AlphaUpper: 1,411 (2.9%)
- Date fields: 724 (1.5%)
- Other types: 6,167 (12.5%)

**Common Context Field Patterns:**
- UI Display Support: Fields for user interface presentation
- Search and Filtering: Complex query and search capabilities
- Workflow Management: Status tracking and process control
- Data Transformation: Converting between formats for display
- Message Handling: User feedback and notification systems
- Financial Processing: Complex financial dimension support
- Integration Support: BOD and external system communication
- Validation Logic: Business rule checking and enforcement

**Context Fields vs Other Field Types:**
- Context Fields represent 10.9% of all BusinessClass files
- Average 94.6 Context Fields per file that has them
- Financial and integration classes show highest Context Field usage
- Most Context Fields support UI interaction and data presentation

=== RELATIONS SECTION ANALYSIS - ACCOUNT.busclass ===

**Account Relations Structure:**
- Total Relations: 14
- Relation Types: one-to-many (7), one-to-one (4), set relations (3)
- Target Entities: 8 different entity types

**Relation Categories:**
1. **Chart Account Relations (4):**
   - GeneralLedgerChartAccountRel (one-to-one)
   - GeneralLedgerChartAccountByAccountRel (one-to-many)
   - ChartAccountsForAccountRel (set)
   - DeleteGeneralLedgerChartAccountRel (one-to-many)

2. **Sub Account Relations (3):**
   - SubAccountRel (one-to-many with ValidSubAccounts filter)
   - AllSubAccountsRel (set)
   - ValidSubAccountsRel (one-to-many with ValidSubAccounts filter)

3. **System Account Relations (2):**
   - SingleSystemAccountsRel (one-to-many, excludes self)
   - AllSystemAccountsRel (one-to-many, where SystemAccount entered)

4. **BOD Integration Relations (3):**
   - FSMBODConfigurationParameterRel (one-to-one)
   - FSMBODConfigurationRel (one-to-one)
   - FSMInboundBODTrackerRel (one-to-one)

5. **Other Relations (2):**
   - GeneralLedgerJournalControlRel (set with IsPosted filter)
   - ReportingChartAccountRel (one-to-many)

**Field Mapping Types:**
- Symbolic key (6 relations) - Standard entity linking
- BySystemAccount (2 relations) - System account grouping
- ByAccount (2 relations) - Account-based organization
- Set relations (3 relations) - Collection management

**Instance Selection Patterns:**
- Data filtering with where clauses (6 relations)
- Self-exclusion (related.Account != Account)
- Status filtering (related.IsPosted)
- Group membership (within ValidSubAccounts)
- Field existence checks (related.SystemAccount entered)

**Key Insights:**
- Account class serves as central hub for General Ledger relationships
- Strong integration with chart accounts and sub-accounts for hierarchical structure
- BOD relations enable external system integration
- Set relations provide ordered data collections for UI and reporting
- Instance selection enables complex business logic and data filtering
- Field mapping supports both standard and custom relationship patterns

=== SETS SECTION ANALYSIS - ACCOUNT.busclass ===

**Account Sets Structure:**
- Total Sets defined: 1
- Set Name: BySystemAccount

**BySystemAccount Set Properties:**
1. **duplicates** - Allows duplicate entries in the set
2. **Sort Order** - Defines ordering criteria with 3 fields:
   - FinanceEnterpriseGroup (primary sort)
   - SystemAccount (secondary sort) 
   - Account (tertiary sort)

**Sets Section Syntax Pattern:**
```lpl
Sets
	SetName
		duplicates/unique
		Sort Order
			Field1
			Field2
			Field3
```

**Key Insights:**
- Sets provide ordered collections of data
- Sort Order supports multi-level sorting hierarchy
- Duplicates attribute controls uniqueness constraints
- Account class uses minimal Sets configuration (1 set)
- BySystemAccount set enables grouping accounts by system account type
- Three-level sort ensures consistent data ordering across enterprise groups

=== DERIVED FIELDS ANALYSIS - REQUISITION ===

**Requisition.busclass Derived Fields: 114 total**
- DerivedField: 69 fields (60.5%) - Complex business logic
- MessageField: 23 fields (20.2%) - User interface messages
- StringField: 20 fields (17.5%) - Display concatenation
- LabelField: 2 fields (1.8%) - UI labels

**Key Categories:**
1. Patient/Healthcare (9 fields) - PII-protected patient data
2. Financial Dimensions (13 fields) - Search and filtering logic
3. Status/Workflow (15 fields) - Approval and processing states
4. Display/UI (20 fields) - Entity + description combinations
5. Business Logic (25 fields) - Calculations and validations
6. System Integration (8 fields) - External system communication

**Notable Features:**
- Extensive healthcare/patient data support with PII protection
- 10 financial dimensions with search capabilities
- Complex workflow and approval processing
- Rich UI display field generation
- Strong integration with IDM, PFI, and RSS systems
=== COMPREHENSIVE SETS ANALYSIS (4,761 files) ===

**Statistics:**
- Total BusinessClass files: 4,761
- Files with Sets: 1,045 (21.9%)
- Files without Sets: 3,716 (78.1%)
- Total Sets found: 2,858

**Top Set Names (Most Common):**
1. Set2 (45 files) - Generic set naming
2. ByRunTime (36 files) - Time-based ordering
3. ByDisplayOrder (36 files) - UI display sequencing
4. Set3 (30 files) - Generic set naming
5. ByRunGroup (28 files) - Group-based processing
6. Set1 (27 files) - Generic set naming
7. ByPriority (24 files) - Priority-based ordering
8. ByStatus (22 files) - Status-based grouping
9. ByCompany (21 files) - Company-based organization
10. Update/Delete Actions (20/16 files) - Workflow operations

**Top Set Properties:**
1. Sort Order (2,059 occurrences) - Ordering specifications
2. FinanceEnterpriseGroup (563 occurrences) - Financial grouping
3. indexed (504 occurrences) - Performance optimization
4. Instance Selection (414 occurrences) - Data filtering
5. Company (400 occurrences) - Company-based organization
6. duplicates (319 occurrences) - Duplicate handling
7. restricted (209 occurrences) - Access control
8. CashManagementGroup (146 occurrences) - Cash management
9. ContractGroup (144 occurrences) - Contract organization
10. Contract (123 occurrences) - Contract references

**Most Complex Classes (Most Sets):**
1. OutboundCXMLOrderRequest (181 sets) - Order processing
2. AsyncActionRequest (65 sets) - Asynchronous operations
3. BankStatementReconciliation (56 sets) - Banking reconciliation
4. IIHItemLocation (44 sets) - Inventory location management
5. ContractTermVersionTerm (40 sets) - Contract term management
6. AllocationRun (27 sets) - Allocation processing
7. TrueCostDriverEvent (24 sets) - Cost driver events
8. ProjectFundingSourceTemplate (22 sets) - Project funding
9. RecallProduct (20 sets) - Product recall management
10. ReportingBasis (20 sets) - Reporting framework

**Sets Usage Patterns:**
- Sets define ordered collections of related data
- Support both "duplicates" and "unique" constraints
- Multi-level Sort Order for hierarchical data organization
- Common in financial and accounting classes for data grouping
- Enable efficient data retrieval with predefined ordering
- Support complex business logic for data relationships
- 21.9% of BusinessClass files use Sets for data organization
- Order processing and workflow classes show highest Sets complexity
- Generic naming (Set1, Set2, etc.) indicates temporary or utility sets
- Financial and contract management classes heavily utilize Sets

**Relations vs Other Sections:**
- Relations appear in 25.8% of BusinessClass files (1,230 files)
- Sets appear in 21.9% of BusinessClass files (1,045 files)
- Derived Fields appear in 37.3% of BusinessClass files (1,776 files)
- Context Fields appear in 10.9% of BusinessClass files (520 files)
- Relations provide the foundation for complex business entity relationships
- Most classes with Relations also have Sets for ordered data collections
- Financial, procurement, and contract management show highest Relations usage

=== COMPREHENSIVE RELATIONS ANALYSIS SUMMARY ===

**Relations Usage Patterns:**
- Relations define entity relationships and data navigation paths
- Support one-to-one, one-to-many, and set collection patterns
- Field Mapping specifies how entities connect (symbolic key, custom sorts)
- Instance Selection provides data filtering with where clauses
- Enable complex business logic through relationship traversal
- Critical for maintaining data integrity and business rules
- Support both internal entity relationships and external system integration
- Account class demonstrates comprehensive relationship modeling with 14 relations
- Relations enable hierarchical data structures (chart accounts, sub-accounts)
- BOD integration relations support external system communication and data exchange

=== COMPREHENSIVE RELATIONS ANALYSIS (4,761 files) ===

**Statistics:**
- Total BusinessClass files: 4,761
- Files with Relations: 1,230 (25.8%)
- Files without Relations: 3,531 (74.2%)
- Total Relations found: 13,959

**Relation Type Distribution:**
- one-to-many: 7,482 (53.6%) - Most common for data collections
- one-to-one: 3,917 (28.1%) - Direct entity linking
- set/unknown: 2,446 (17.5%) - Set collections and complex relations
- Specialized relations: 114 (0.8%) - Custom relation patterns

**Top Target Entities:**
1. SampleDocumentTemplate (129 relations) - Document management
2. GeneralLedgerCompany (104 relations) - Financial company structure
3. ContractLine (98 relations) - Contract line management
4. FSMBODConfiguration (81 relations) - BOD integration
5. ActorRole (80 relations) - Security and role management
6. AnalyticsConsoleConfigurations (78 relations) - Analytics setup
7. GeneralLedgerCompanyGroupMember (77 relations) - Company grouping
8. GeneralLedgerCalendarPeriod (76 relations) - Period management
9. GeneralLedgerSystemCode (64 relations) - System code management
10. SourcingEventResponse (64 relations) - Sourcing workflow

**Top Mapping Types:**
1. symbolic key (6,403) - Standard entity linking (45.9%)
2. none (2,566) - Set relations without explicit mapping (18.4%)
3. Set2 (179) - Generic set ordering
4. ByRunGroup (153) - Run group organization
5. part of key (128) - Partial key matching

**Most Complex Classes (50+ Relations):**
1. SourcingEvent (217 relations) - Sourcing event management
2. FinanceEnterpriseGroup (159 relations) - Financial enterprise operations
3. AccountingEntity (123 relations) - Accounting entity management
4. BudgetImport (117 relations) - Budget import processing
5. ContractLineAttributeUpdate (111 relations) - Contract line updates
6. ItemInformationWorksheet (109 relations) - Item information management
7. PayablesInvoiceDistribution (107 relations) - Invoice distribution
8. SampleDocumentTemplate (106 relations) - Document template management
9. AnalyticsConsoleConfigurations (105 relations) - Analytics configuration
10. MatchReconQueue (97 relations) - Reconciliation queue management

**Key Insights:**
- 25.8% of BusinessClass files use Relations for entity relationships
- Average 11.3 relations per file that has them
- Financial and procurement classes show highest Relations complexity
- Symbolic key mapping dominates at 45.9% of all relations
- Set relations (18.4%) provide ordered data collections
- Complex business processes require extensive relationship modeling
- BOD integration heavily used across financial and operational classes
- Sourcing and contract management show highest relationship complexity

**SYNTAX RULES:**
- Tab indentation for hierarchy
- "Field Mapping uses" specifies connection type
- "Instance Selection" provides data filtering
- "related." prefix for target entity fields
- Set relations use "is a EntityName set" syntax
- Complex mappings support nested field references
- Where clauses enable sophisticated business logic
- Multiple field mappings create composite keys

=== RELATIONS SYNTAX PATTERNS ===

**One-to-One Relations:**
```lpl
RelationName
	one-to-one relation to TargetEntity
	Field Mapping uses symbolic key
		related.Field1 = LocalField1
		related.Field2 = LocalField2
```

**One-to-Many Relations:**
```lpl
RelationName
	one-to-many relation to TargetEntity
	Field Mapping uses SortOrderName
		related.Field1 = LocalField1
		related.Field2 = LocalField2
	Instance Selection
		where (related.Field != LocalField)
```

**Set Relations:**
```lpl
RelationName		is a TargetEntity set
	Instance Selection
		where (related.StatusField)
```

**Complex Field Mapping:**
```lpl
RelationName
	one-to-one relation to TargetEntity
	Field Mapping uses symbolic key
		related.Entity.Verb = 1
		related.Entity.Noun = "CodeDefinition"
		related.Entity.Direction = 1
```

=== CONDITIONS SECTION ANALYSIS - ACCOUNT.busclass ===

**Account Conditions Structure:**
- Total Conditions: 12
- Restricted Conditions: 10 (83.3%)
- Public Conditions: 2 (16.7%)

**Condition Categories:**
1. **UI Control (2 conditions):**
   - ShowSubAccountPanel - Controls sub-account panel visibility
   - HasTransientAttachment - Manages attachment display

2. **Account Classification (4 conditions):**
   - IsASystemAccount - Identifies system accounts
   - InterEntityAccount - Inter-entity transaction accounts
   - ZoneAccount - Zone-based accounting accounts
   - DepartmentJournalAccount - Department-specific accounts

3. **Data Validation (3 conditions):**
   - AccountExists - Verifies account existence
   - MissingSubAccounts - Validates sub-account completeness
   - MissingMajorAccount - Checks major account presence

4. **Translation & Reporting (2 conditions):**
   - BalanceSheetTranslationCodes - Balance sheet translation validation
   - FutureChanges - Future period change detection

5. **System Integration (1 condition):**
   - Complex business logic for chart account relationships

**Key Condition Patterns:**
- **"restricted"** - Internal use only (10 conditions)
- **"when" clauses** - Boolean logic with field comparisons
- **Logical operators** - "and", "or", "!" for complex conditions
- **Field references** - Direct field access and relationship traversal
- **Existence checks** - "entered", "exists" for data presence validation
- **Comparison operators** - "=", "<" for value comparisons
- **System account types** - Multiple system account classifications
- **Relationship validation** - Chart account and sub-account integrity

**Notable Features:**
- Most conditions are restricted for internal business logic
- Complex nested boolean expressions with parentheses
- Integration with derived fields for calculated values
- Support for future period change tracking
- Extensive system account type classification
- UI control through conditional panel display
- Data integrity validation across related entities

=== CONDITIONS SYNTAX PATTERNS ===

**CONDITIONS SECTION:**
```lpl
Conditions
	ConditionName
		restricted
		when (FieldName entered)
	
	SecurityCondition
		restricted
		when (actor.context.SecurityGroup allows access)
	
	ValidationCondition
		when (RelatedEntity exists
		and  FieldValue = "ExpectedValue")
	
	ComplexCondition
		restricted
		when ((Field1.SubField
		or    Field2.AlternateValue)
		and  !Field3.NegatedCondition)
```

**CONDITIONS SYNTAX RULES:**
- Tab indentation for hierarchy
- "restricted" limits access to internal operations
- "when" clauses define boolean logic
- Logical operators: "and", "or", "!" (not)
- Field existence: "entered", "exists"
- Comparison operators: "=", "!=", "<", ">"
- Parentheses for complex boolean expressions
- Security context: "actor.context" references
- Relationship traversal: "Entity.Field" notation

=== COMPREHENSIVE RELATIONS SYNTAX SAMPLES ===

**RELATIONS SECTION:**
```lpl
Relations
	// One-to-One with Symbolic Key
	GeneralLedgerChartAccountRel
		one-to-one relation to GeneralLedgerChartAccount
		Field Mapping uses symbolic key
			related.FinanceEnterpriseGroup = FinanceEnterpriseGroup
			related.GeneralLedgerChartAccount = Account
	
	// One-to-Many with Custom Sort
	SingleSystemAccountsRel
		one-to-many relation to Account
		Field Mapping uses BySystemAccount
			related.FinanceEnterpriseGroup = FinanceEnterpriseGroup
			related.SystemAccount = LocalSystemAccount
		Instance Selection
			where (related.Account != Account)
	
	// Set Relation with Filter
	AllSubAccountsRel		is a GeneralLedgerSubAccount set
	
	GeneralLedgerJournalControlRel		is a GeneralLedgerJournalControl set
		Instance Selection
			where (related.IsPosted)
	
	// Complex BOD Integration
	FSMBODConfigurationRel
		one-to-one relation to FSMBODConfiguration
		Field Mapping uses symbolic key
			related.FSMBODConfiguration.Verb = 1
			related.FSMBODConfiguration.Noun = "CodeDefinition"
			related.FSMBODConfiguration.Direction = 1
	
	// Filtered One-to-Many
	SubAccountRel
		one-to-many relation to GeneralLedgerSubAccount
		Field Mapping uses symbolic key
			related.FinanceEnterpriseGroup = FinanceEnterpriseGroup
		Instance Selection
			where (related.GeneralLedgerSubAccount within ValidSubAccounts)
```

**RELATION TYPES:**
- **one-to-one:** Direct entity linking (28.1% of relations)
- **one-to-many:** Data collections (53.6% of relations)
- **set relations:** Ordered collections (17.5% of relations)

**FIELD MAPPING TYPES:**
- **symbolic key:** Standard entity linking (45.9%)
- **Custom sorts:** BySystemAccount, ByAccount, Set2, etc.
- **part of key:** Partial key matching
- **none:** Set relations without explicit mapping

**INSTANCE SELECTION PATTERNS:**
- **Equality filters:** where (related.Field = LocalField)
- **Inequality filters:** where (related.Field != LocalField)
- **Existence checks:** where (related.Field entered)
- **Group membership:** where (related.Field within GroupField)
- **Boolean filters:** where (related.IsActive)
- **Complex conditions:** where (related.Status = "Open" and related.Amount > 0)

**COMMON RELATION PATTERNS:**
- **Hierarchical:** Parent-child entity relationships
- **Reference:** Lookup to master data entities
- **Collection:** One-to-many for related records
- **Filter:** Subset of related records with conditions
- **Integration:** BOD and external system connections
- **Audit:** Historical and tracking relationships

=== FIELD RULES ANALYSIS - ACCOUNT.busclass ===

**Field Rules Structure: 79 rule entries**
- Complex validation logic with conditional constraints
- Extensive system account validation and duplicate prevention
- Chart section and account type consistency enforcement
- Regular expression validation using 'matches' syntax for account formats
- Translation code validation with default assignments

**Field Rules Categories:**
1. **Format Validation:** Regular expression matching against FinanceEnterpriseGroup.AccountRegularExpression
2. **Required Fields:** ChartSection, AccountDescription, AccountType marked as required
3. **Business Logic:** Chart section/account type consistency (Balance Sheet: Equity/Asset/Liability, Income Statement: Revenue/Expense)
4. **Referential Integrity:** AccountSubType.AccountType must match AccountType
5. **Default Values:** Translation codes default to "BS" (Balance Sheet) or "IS" (Income Statement)
6. **Duplicate Prevention:** System accounts validated against SingleSystemAccountsRel to prevent duplicates
7. **Conditional Requirements:** ValidSubAccounts requires FinanceEnterpriseGroup.UseSubAccounts
8. **Complex Relationships:** Gain/loss account linking (Translation, Realized, Unrealized)

**Field Rules Syntax:**
```lpl
Field Rules
	FieldName
		required
		constraint (validation_logic)
		"ErrorMessage"
		default to "value"
	
	if (condition)
		constraint (field matches "regex_pattern")
		"DynamicMessage<Label>"
	
	else
		default to "alternate_value"
```

**Key Field Rules Features:**
- Conditional validation with if/else logic
- Dynamic error messages with field label substitution
- Regular expression pattern validation
- Cross-field validation and consistency checks
- System account duplicate prevention with complex gain/loss relationships
- Chart section enforcement based on account types
- Translation code validation with automatic defaults
- Localized error messages with parameterized text

=== COMPREHENSIVE FIELD RULES ANALYSIS (4,761 files) ===

**Statistics:**
- Total BusinessClass files: 4,761
- Files with Field Rules: 3,828 (80.4%)
- Files without Field Rules: 933 (19.6%)
- Total Field Rules found: 484,227
- Average rules per file (with rules): 126.5

**Top Complex Classes (3000+ Field Rules):**
1. FSMPOInboundBODImport (3,802 rules) - Purchase order BOD import processing
2. PayablesInvoiceDistribution (3,476 rules) - Invoice distribution validation
3. CodeBlockRelationRule (2,963 rules) - Code block relationship rules

=== ACTIONS SECTION ANALYSIS - REQUESTER.busclass ===

**Actions Overview:**
- Total Actions: 25
- Restricted Actions: 19 (76%)
- Actions with Confirmation Required: 9 (36%)
- Actions with Local Fields: 2 (8%)

**Action Types Distribution:**
- Instance Actions: 17 (68%) - Most common type for entity operations
- Set Actions: 5 (20%) - Bulk operations on multiple records
- Create Action: 1 (4%) - Entity creation
- Update Action: 1 (4%) - Entity modification
- Delete Action: 1 (4%) - Entity removal

**Key Action Categories:**
1. **CRUD Operations (3 actions):** Create, Update, Delete with validation
2. **RSS Configuration (8 actions):** Requisition Self Service setup for different user types
3. **BOD Integration (3 actions):** Business Object Document processing and synchronization
4. **Requisition Management (4 actions):** Cart operations, line creation, release/delete
5. **Context Management (2 actions):** Current requisition and punchout context updates
6. **Utility Operations (5 actions):** Validation fixes, option setting, data loading

**Most Complex Actions (by rule count):**
1. InitializeRSSOptions: 83 action rules - Reset RSS display options
2. RSSLPLInitializeRSSOptions: 74 rules - Initialize LPL-specific RSS options
3. RSSCreateSpecialLine: 73 rules - Create special requisition lines with extensive parameters
4. SetRSSOptionsToBasicUser: 70 rules - Configure basic user interface
5. SetRSSOptionsToPowerUser: 70 rules - Configure power user interface

**Actions Syntax Patterns:**
```lpl
ActionName is a/an ActionType
    Parameters
        ParameterName is DataType
    Action Rules
        business logic statements
        invoke operations
        field assignments
    Field Rules
        validation constraints
    Parameter Rules
        parameter validation
```

**Key Features:**
- **Restricted Actions:** 76% marked as restricted for internal system use
- **Confirmation Requirements:** Critical operations require user confirmation with warning messages
- **Parameter Complexity:** Actions support 0-9+ parameters for flexible operation invocation
- **Local Fields:** Temporary storage for complex operations and view management
- **BOD Integration:** Native LPL BOD triggering for external system synchronization
- **User Experience:** Extensive RSS configuration for different user types and capabilities
- **Error Handling:** Resume on error patterns with status tracking and logging
- **Background Processing:** Set actions support background execution for bulk operations

**Actions vs Other Sections:**
- Actions provide the behavioral interface for BusinessClass entities
- Work with Conditions for validation and business logic enforcement
- Utilize Relations and Sets for data navigation and manipulation
- Integrate with Field Rules for data validation during action execution
- Support complex workflows through parameter passing and result assignment

**Common Action Patterns:**
- **Instance Actions:** Operate on single entity instances with specific business logic
- **Set Actions:** Perform bulk operations across multiple records with filtering criteria
- **Create/Update/Delete:** Standard CRUD operations with validation and business rules
- **Configuration Actions:** Manage system settings and user preferences
- **Integration Actions:** Handle external system communication and data synchronization
- **Workflow Actions:** Support business process automation and approval workflows

=== SANPURCHASEORDERRECEIPTIMPORT ANALYSIS ===

**Business Class Structure:**
- Prefix: cfg
- Symbolic key: SanPurchaseOrderReceiptImport
- Import processing class for purchase order receipts

**Field Analysis (9 Persistent Fields):**
- RunGroup (key field)
- PurchaseOrder (Numeric size 12)
- BillOfLading (Alpha size 100)
- ReceiptComments, ErrorMessage (Text fields)
- Processed, ImportError (Boolean flags)
- AsyncID, ImportAsyncID (AsyncActionRequest references with "delete ignored")

**Field Rules Patterns:**
- Required fields: SanPurchaseOrderReceiptImport, Company, RunGroup
- Default values: ImportError defaults to false
- Initial value assignments for boolean flags

**Derived Fields:**
- DerivedErrorMessage: Conditional logic returning line errors or main error message
- Uses LineErrorExists condition for error aggregation

**Relations (9 relations):**
- LineRel, UnreleasedLineRel, ErrorLineRel (filtered SanPurchaseOrderReceiptLineImport sets)
- DetailRel (SanPOReceiptInventoryDetailImport set)
- PurchaseOrderRel (one-to-one with symbolic key mapping)
- PurchaseOrderTransactionDetailRel (one-to-many with instance selection)
- Three generic set relations for related import entities

**Conditions (5 business logic conditions):**
- DetailRecordsExists, IsReleased (data validation)
- GreenAlertStatus, YellowAlertStatus (status indicators)
- LineErrorExists (error aggregation)

**Actions (6 comprehensive actions):**
- ProcessData: Set Action with async processing and error handling
- Release: Instance Action for releasing processed receipts
- Delete: Purge Action for cleanup operations
- ValidateData: Instance Action for data validation
- ReprocessErrors: Set Action for error reprocessing
- UpdateStatus: Instance Action for status management

=== SANCREATEINVOICEROUTINGCATEGORY.USERACTION ANALYSIS ===

**User Action Structure:**
- Action Type: Set Action
- Purpose: Automated creation of invoice routing categories for employees
- Processing: Bulk operation on filtered employee records

**Instance Selection Criteria:**
- IsActive: Only active employees
- RelationshipToOrganization="EMPLOYEE": Employee relationship filter
- SanInvoiceSubmitter: Must be designated as invoice submitter
- SanPendingInvoiceCategoryBuild: Pending category build flag
- instance count of SanEmployeeToInvoiceRoutingCategoryRel = 0: No existing routing category

**Action Logic:**
1. **Finance Resource Creation:** Creates FinanceResource if not exists
   - Maps Employee to FinanceResource field
2. **Invoice Routing Category Creation:** Creates new routing category
   - VendorGroup = HROrganization
   - InvoiceRoutingCategory = Employee
   - Description = concatenated GivenName + FamilyName
   - Active = true
   - SanFromAutomation = true (automation flag)

**Key LPL Patterns:**
- **Conditional Entity Creation:** Creates FinanceResource only if missing
- **String Concatenation:** Name.GivenName + " " + Name.FamilyName
- **Automation Tracking:** SanFromAutomation flag for audit trail
- **Complex Instance Selection:** Multiple AND conditions with relation count check
- **Bulk Processing:** Set Action processes multiple employees efficiently

**Business Logic:**
- Ensures every invoice submitter has corresponding routing category
- Prevents duplicate routing categories through relation count check
- Maintains referential integrity by creating required FinanceResource
- Tracks automated creation for audit and troubleshooting purposes

=== SANSCANEMPLOYEESTATUS.USERACTION ANALYSIS ===

**User Action Structure:**
- Action Type: Set Action
- Purpose: Employee status synchronization for invoice routing categories
- Processing: Bulk status updates based on employee admission status

**Instance Selection Logic:**
- **ACTIVE Employees:** AdmissionNumber = "ACTIVE" AND routing category is inactive
- **TERMINATED Employees:** AdmissionNumber = "TERMINATED" AND (routing category is active OR has approval assignments)

**Action Processing by Status:**

**For ACTIVE Employees:**
1. **Activate Routing Category:** Updates SanEmployeeToInvoiceRoutingCategoryRel.Active = true
2. **Refresh Approvals:** Invokes SanRefreshApprovalAssignments for routing category

**For TERMINATED Employees:**
1. **Process Approval Assignments:** Iterates through SanEmployeeToFinanceResourceInvApprovalRel
2. **Refresh Each Assignment:** Invokes SanRefreshApprovalAssignments for each routing category
3. **Deactivate Routing Category:** Updates SanEmployeeToInvoiceRoutingCategoryRel.Active = false

**Key LPL Patterns:**
- **Complex OR Logic:** Handles both activation and deactivation scenarios
- **Conditional Processing:** Different logic paths based on employee status
- **Iterative Processing:** for each(Ln) loop with line variable
- **Cascading Updates:** Status changes trigger approval assignment refreshes
- **Bulk Synchronization:** Set Action processes multiple employees efficiently

**Business Logic:**
- Maintains invoice routing category status aligned with employee status
- Ensures approval assignments are refreshed when status changes
- Handles both activation (ACTIVE) and deactivation (TERMINATED) workflows
- Prevents orphaned approval assignments through proper cleanup

=== COMPLEX BUSINESS CLASS EXAMPLE - CONTRACTMANAGEMENT ===

**Generated Business Class Structure:**
- 25 Persistent Fields with complex data types and states
- 3 Transient Fields with derived calculations
- 6 Local Fields for processing and messaging
- 4 Derived Fields with conditional logic
- 5 Conditions for business validation
- 5 Relations with different mapping strategies
- 4 Sets with filtering and sorting
- Comprehensive Field Rules with validation
- 8 Actions including workflow and automation

**Advanced LPL Features Demonstrated:**
- **Complex States:** Multiple enumerated values for ContractType, Status, ApprovalLevel
- **International Currency:** InternationalAmount with Currency reference
- **PII Handling:** holds pii attribute for sensitive data
- **Audit Trail:** CreatedBy, CreatedDate, LastModifiedBy, LastModifiedDate
- **TimeStamp Usage:** Precise date/time tracking
- **XMLDocument:** Contract document storage
- **Conditional Field Rules:** if/else validation logic

=== COMPREHENSIVE BUSINESS CLASS DEFINITION SYNTAX ===

**BUSINESS CLASS STRUCTURE:**
```lpl
<BusinessClass> is a Business Class
	[deprecated]
	[owned by <ModuleName>]
	[<ClassicPrefix>]
	[<SqlName>]
	[<RpgName>]
	[<ClassicName>]
	[<DefaultLabel>]
	[framework type is (ConfigParam | LPLConfiguration | ProcessFlow | ReplicationSet | Security)]
	[untranslatable]
	[subject is <Subject>]
	[stored in [base] environment]
	[stored in product line]
	[store using <ClassName>]
	[contains environment data]
	[disable data area copy]
		[preserve target data]
	[representative text is <Message>]
	[representative image is (<RelatedValue> | <Icon>)]
		[display as (portrait | photo | full) image]
		[missing image is (<ImageName> | random background)]
			[foreground text is <Message>]
	[(restrict | enable) actions on lists]
	[default Alpha filter operator is (contains | starts with | equals)]
```

**SECTION ORDER:**
```lpl
Suppress Warnings
Ontology
Patterns
DataSource Mapping
Persistent Fields
Transient Fields
Dimensions
Measures
Cube Links
Context Fields
Field Groups
Audit Index Fields
Local Fields
Derived Fields
Conditions
Text Search Fields
Cube Relations
Columnar Relations
Relations
Form Invokes
Matrix Forms
Sets
Field Rules
SubType <RelatedCondition> Field Rules
Commit Rules
Audit Entry Rules
Create Rules
Create Exit Rules
Update Action Rules
Delete Rules
Attach Rules
Parent Attach Rules
Dynamic Creation Rules
Rule Blocks
StateCycles
Actions
```

**ONTOLOGY SECTION:**
```lpl
Ontology
	symbolic key is <KeyField>
		[name is <FieldName>]
		[classic set name is <Literal>]
		[sql set name is <Literal>]
		[not indexed]
		[<SqlName>]
		[<ClassicName>]
		[<ClassicNameForField>]
		[<SqlNameForField>]
		[protected]
		[name for <context FieldName> is <FieldName>]
		[type for <context FieldName> is a[n] <KeyField>]
	part of <BusinessClass>
		[connect via UniqueID [only]]
		[delete (cascades | restricted | ignored)]
		relative key is <FieldName> [<DataDefinition>]
			[<States>]
			[<SqlName>]
			[classic set name is <Literal>]
			[sql set name is <Literal>]
			[not indexed]
			[<ClassicName>]
			[<ClassicNameForField>]
			[<SqlNameForField>]
			[<DefaultLabel>]
			[protected]
			[(delete cascades | delete ignored)]
			[[exact] version is (<RelatedValue> | latest)]
			[data area is <RelatedValue>]
			[name for <context FieldName> is <FieldName>]
			[type for <context FieldName> is a[n] <KeyField>]
			[text searchable]
```

**PATTERNS SECTION:**
```lpl
Patterns
	[disable Auditing]
	[implements LightweightAuditing]
	[disable AuditIndex]
	[implements EffectiveDated]
		[bypass integrity rules]
	[disable EffectiveDated]
	[implements AuditLogEntryActions]
	[implements OnceUsedNeverDelete]
	[implements DeleteFlag]
	[disable RetroactiveEffectiveDating]
	[disable UniqueID]
	[disable AsOfDateProcessing]
	[disable DataTranslations]
	[disable StaticTranslations]
	[implements HistoryCorrection]
	[implements FutureCorrection]
	[implements ForceUIRefreshOnStale]
	[implements IncrementalReplication]
		[indicator field is <FullFieldName>]
			replicate when <Value>
				then (set to <Value> | invoke <ActionName> [<FullStateName>])
	[disable IncrementalReplication]
	[implements InlineUserFields]
		size is <Number>
	[implements StaticJava]
		[has attachments]
	[implements InMemoryCache]
	[implements WorkFile]
	[implements ForeignTable]
		[allow updates]
	[implements ReadOnly]
	[implements LazyUniqueID]
	[implements S3ClassicTable]
		[allow updates]
		[implements UniqueID]
		[has attachments]
			[<attachment FieldName> is comment of type <Literal>]
	[implements S3ClassicAttachments]
		[<attachment FieldName> is comment of type <Literal>]
	[implements M3ClassicTable]
		[allow updates]
	[implements Resequence on <FieldName>]
		new sequence field is <FieldName>
		set is <SetName>
	[implements DynamicCreation]
	[implements AnalyticCube]
		[label is <Message>]
		[columnar only]
		[(pre-calculate totals | dynamically calculate totals)]
		[(allow write to summary level | write to base level only)]
		[refresh using (audit log | message queue)]
		[beginning balance is period zero]
		[Instance Selection]
			where <Condition>
	[implements ChildHierarchy]
		[top node when <SimpleCondition>]
		[leaf node when <SimpleCondition>]
		(children are <RelatedLink>
		| child set is <RelatedLink>
			child is <KeyField>
			[aggregation percent is <FullFieldName>])
		[descendants are <RelatedLink>]
	[implements CreateStamp]
	[implements UpdateStamp]
	[implements Proxy for <RelatedLink>]
		[Additional Field Mapping]
			related.<FullFieldName> = <RelatedValue>
	[implements CompoundDocument]
		Document Components
			<RelatedLink>
	[implements BODId]
	[implements Encrypted]
		[when <Condition>]
	[implements ContextualParent]
	[implements SurrogateAuditLog for <FullFieldName>]
	[implements Template Driven by <BusinessClass>]
		[completion message is <Message>]
		[(create all instances | create instance when <Condition>)]
	[implements <DataSourceType> DataSource]
	[implements ExtendsExternalData]
		[using <ClassName>]
```

**PERSISTENT FIELDS SECTION:**
```lpl
Persistent Fields
	<FieldName> [<DataDefinition>]
		[<States>]
		[<SqlName> | <SqlPrefix>]
		[<ClassicName>]
		[<ClassicNameForField>]
		[<DefaultLabel>]
		[encrypt]
		[automate context]
		[enable alternate document location]
			[document is <RelatedField>]
			[existence is <RelatedField>]
		[allow images]
		[text searchable]
		[scannable]
		[holds pii]
		[translatable]
		[disable Auditing [when in background]]
		[disable EffectiveDated]
		[enable EffectiveDated]
		[restricted]
		[protected]
		[precision is <RelatedValue>]
			[round to precision]
		[primitive type is <RelatedValue>]
		[primitive size is <RelatedValue>]
		[primitive decimal size is <RelatedValue>]
		[create value is blank if no entry]
		[disable surrogates]
		[context of <FullFieldName>]
		[(delete cascades | delete ignored)]
		[as of <RelatedValue>]
		[within <RelatedValue>]
			[<Message>]
		[[exact] version is (<RelatedValue> | latest)]
		[data area is <RelatedValue>]
		[is (condition | related (link | value)) for <RelatedValue>]
			[(dimensions [with attributes] | measures) only]
		[<TextVariables>]
		[document template for <BusinessClass>]
		[store as BusinessObjectReference]
			[<SqlPrefix>]
		[Valid Business Classes]
			<BusinessClass>
	<FieldName> is a snapshot of <RelatedField>
		[when <Condition>]
	(<FieldName> | <FieldGroupName>) from <BusinessClass>
	(audit fields | <ActionAttribute>)
```

**TRANSIENT FIELDS SECTION:**
```lpl
Transient Fields
	<FieldName> [<DataDefinition>]
		[<States>]
		[<DefaultLabel>]
		[scannable]
		[holds pii]
		[precision is <RelatedValue>]
			[round to precision]
		[primitive type is <RelatedValue>]
		[primitive size is <RelatedValue>]
		[primitive decimal size is <RelatedValue>]
		[as of <RelatedValue>]
		[within <RelatedValue>]
			[<Message>]
		[disable surrogates]
		[[exact] version is (<RelatedValue> | latest)]
		[data area is <RelatedValue>]
		[is (condition | related (link | value)) for <RelatedValue>]
			[(dimensions [with attributes] | measures) only]
		[<TextVariables>]
		[document template for <BusinessClass>]
		[store as BusinessObjectReference]
		[derive value from <RelatedValue>]
```

**LOCAL FIELDS SECTION:**
```lpl
Local Fields
	<FieldName> [(<DataDefinition> | is a <BusinessClass> view)]
		[<DefaultLabel>]
		[value is <RelatedField>]
		[<States>]
		[holds pii]
		[precision is <RelatedValue>]
			[round to precision]
		[as of <RelatedValue>]
		[disable surrogates]
		[[exact] version is (<RelatedValue> | latest)]
		[data area is <RelatedValue>]
		[is (condition | related (link | value)) for <RelatedValue>]
			[(dimensions [with attributes] | measures) only]
		[<TextVariables>]
		[document template for <BusinessClass>]
		[store as BusinessObjectReference]
		[do not save in checkpoint]
```

**DERIVED FIELDS SECTION:**
```lpl
Derived Fields
	<FieldName> is a[n] <DerivedFieldType>
		[type (<DataDefinition> | is a[n] <BusinessClass> view | is MessageField)]
			[precision is <RelatedValue>]
		[is (condition | related (link | value)) for <RelatedValue>]
		[<SqlName>]
		[<ClassicName>]
		[<DefaultLabel>]
		[restricted]
		[holds pii]
		(<DerivedFieldExpression> | <optionally blank for NativeField and InstanceCount>)

	DerivedFieldType ::= (aggregation of <FullFieldName>
						| ConditionalField
						| ComputeField
						| MeasureField
						| InstanceCount
						| StringField
						| MessageField
						| LabelField
						| DerivedField)

	DerivedFieldExpression ::=
		aggregation of
			when <Condition>
		Conditional Field
			<ConditionalFieldControl>
		ComputeField
			<Parens><RelatedValue> [<MathOperator> <RelatedValue>]<Parens>
		MeasureField
			<Parens><MeasureValue> [<MathOperator> <MeasureValue>]<Parens>
		InstanceCount
			[where <Condition>]
		StringField
			<RelatedValue> <RelatedValue> <RelatedValue>
		MessageField
			<Message>
		LabelField
			<Message>
		DerivedField
			(<Rule> | return [<RelatedValue>])
```

**CONDITIONS SECTION:**
```lpl
Conditions
	<ConditionName>
		[<SqlName>]
		[<ClassicName>]
		[<DefaultLabel>]
		[restricted]
		when <Condition>

	Condition ::= <Parens><ConditionNode><Parens>
				[<Conjunction> <Parens><ConditionNode><Parens>]

	ConditionNode ::= (<ActorCondition>
					| <ChangedCondition>
					| <ComparisonCondition>
					| <FieldCondition>
					| <FieldWasCondition>
					| <IsABusClassCondition>
					| <RelatedCondition>
					| <RelationCondition>
					| <WithinBusClassGroupCondition>)

	ActorCondition ::= [authenticated] actor (has role | in group) <Text>

	ChangedCondition ::= (<RelatedLink> | <RelatedField> | [<RelatedLink>].<FieldGroupName>)
	changed between <RelatedValue> and <RelatedValue>

	ComparisonCondition ::= <RelatedValue> <ConditionOperator> <RelatedValue>

	FieldCondition ::= [<FieldOperator>](<RelatedField> | <FieldGroupName>)
					(entered | is numeric | is high value | changed | in context | is leap year | is last day in month | has audit change)

	FieldWasCondition ::= <FullFieldName> was [always] <RelatedValue>
						[between <RelatedValue> and <RelatedValue>]

	IsABusClassCondition ::= <RelatedField> is a[n] <BusinessClass>

	RelationCondition ::= [(first | no [t])] <RelatedLink> (exists | pending | has future changes)

	ConditionOperator ::= (= | != | >= | <= | > | < | !> | !< | like | contains | [not] within | [not] overlaps | [not] matches)

	WithinBusClassGroupCondition ::= <RelatedLink> [not] within <RelatedField>
```

**RELATIONS SECTION:**
```lpl
Relations
	(<RelationName> [is a[n] (<BusinessClass> | <KeyField>) set] | <KeyField> set)
		[<SqlName>]
		[<ClassicName>]
		[<DefaultLabel>]
		[(one-to-one | one-to-many) relation (to <BusinessClass> | using <RelatedLink>)]
		[valid when <Condition>]
		[<AsOfDate>]
		[required]
		[delete (restricted | cascades)]
		[(enable | disable) subset select on dependent relation]
		[disable filtering within db]
		[disable link cache]
		[include deleted record]
		[dynamic mapping is <RelatedValue>]
		[Field Mapping uses <Set>]
		[related.<FullFieldName> <RelationOperator> <RelatedValue>]
		[Instance Selection]
		[include [only] deleted records]
		where <Condition>

	Set ::= (<SetName>
			| [<BusinessClass>] part of key
			| [<KeyField>] (symbolic | level) key
			| bod key
			| update stamp key
			| unique id key)

	RelationOperator ::= (= | >= | > | <= | < | as of)

	<RelationName>
		[<SqlName>]
		[<ClassicName>]
		<ConditionalRelationControl>

	ConditionalRelationControl ::=
		if <Condition>
			(<RelationName> | <ConditionalRelationControl>)
		[else]
			(<RelatedValue> | <ConditionalRelationControl>)
```

**SETS SECTION:**
```lpl
Sets
	<SetName>
		[<SqlName>]
		[<ClassicName>]
		[primary]
		[override primary]
		[(no duplicates | duplicates)]
		[bypass no duplicates validation]
		[(indexed | not indexed)]
		[primary when importing]
		[filter instance selection]
		Sort Order
			<FullFieldName> [descending]
		[Instance Selection]
			where (<Parens><RelatedCondition><Parens> | <Condition>)
```

**FIELD RULES SECTION:**
```lpl
Field Rules
	[(merge | replace) specifications]
	<FieldRules>

	<FieldRules> ::=
		<FullFieldName>
			<Rule>

	Rule ::= (<ControlRule> | <GeneralRule> | <FieldRule> | <FieldCreateRule> | <GroupRule> | <ArrayRule> | <ActionRule> | <FormInvokeRule>)

	ControlRule ::=
		if <Condition>
			<Rule>
		[else]
			<Rule>

		for each[<Parens><LPLConstructName><Parens>] ([<Distinct> in] <otm RelatedLink> | <array RelatedField> | <iteration FullFieldName>)
			[while <Condition>]
			<Rule>
			[each[<Parens><LPLConstructName><Parens>].<RelatedField>]

		end for each

		while <Condition>
			<Rule>

		end while

	GeneralRule ::=
		confirmation required
			[<Message>]

		constraint <Condition>
			<Message>

		<RelatedField> <AssignmentOp> <RelatedValue>

		increment <RelatedField> [by <RelatedValue>]
			[when <Condition>]

		decrement <RelatedField> [by <RelatedValue>]
		[when <Condition>]

		initialize [(<FullFieldName> | <FieldGroupName>)]

		(display | log) <Message>

		add action tag <ActionTag>

		include <RuleBlockName>

		round <FullFieldName> [(up | down)] to nearest [exact] <RelatedValue>

		clear in-memory cache [for <BusinessClass>]

		synchronize on <RelatedLink>

	FieldRule ::=
		[(force | dynamic)] default [<FullFieldName>] to <RelatedValue>
			[(default as a group | default individual fields)]

		required
			[<Message>]

		cannot be entered
			[<Message>]

		cannot be changed
			[<Message>]

		must be numeric
			[<Message>]

		initial value is <RelatedValue>
			[when <SimpleCondition>]

		field size is <RelatedField>

	FieldCreateRule ::=
		autosequence [<FullFieldName>] [when blank] [using (<RelatedField> | <SetName>)]
			[manual range is <RelatedField>]
			[minimize contention [and gaps]]

	GroupRule ::=
		always default (individual fields | as a group)

		mutually exclusive
			[<Message>]

	ArrayRule ::=
		array size is <RelatedField>
		edit increasing sequence
		make increasing sequence
		edit decreasing sequence
		make decreasing sequence
		edit contiguous
		make contiguous
		no duplicates [on <FullFieldName> [,<FullFieldName>]]

	AssignmentOp ::= (= | += | -= | *= | /= | ^= | %=)
```

**ACTIONS SECTION:**
```lpl
Actions
	(<ActionDefinition> | <EventHandler>)

	ActionDefinition ::=
		<ActionName> is a[n] [<ActionType>] [Request]Action
			[<DefaultLabel>]
			[privileged]
			[action tag is <ActionTag>]
			[completion message is <Message>]
			[no records message is <Message>]
			[workflow event title is <Message>]
			[valid when <Condition>]
				[<Message>]
			[restricted]
			[(restrict | enable) action on lists]
			[(refresh and | lazily) lock this instance]
			[(enable | disable) ImmutableContextCache]
			[bod type is <Literal>]
			[bypass field rules]
			[bypass relational integrity rules]
			[use array insert]
			[manual update]
			[disable checkpoint]
			[subject is <Subject>]
			[effective date required]
			[reason code required]
			[action comment required]
			[request action process is <PFlowServiceName>]
			[request action linkback webapp is <WebAppName>]
			[disable RetroactiveEffectiveDating]
			[disable resume on error]
			[disable multiple instance selection]
			[confirmation required]
				[<Message>]
			[run in (foreground | background)]
				[[initial] schedule concurrency is (FullConcurrency | NoConcurrency | NoActionGroupConcurrency)]
				[[initial] misfire strategy is (DoNothing | RunOnce | RunAllProcessesScheduled)]
			[allow anonymous access]
			[allow user fields [from <BusinessClass>] as parameters]
			[synchronized [on <Message>]]
			[allow unlimited concurrency]

			Queue Mapping Fields
				<RelatedField>

			Set Is
				<RelatedValue>

			Parameters
				<FieldName> [<DataDefinition>]
					[<States>]
					[<DefaultLabel>]
					[holds pii]
					[scannable]
					[as of <RelatedValue>]
					[within <RelatedValue>]
						[<Message>]
					[[exact] version is <RelatedValue>]
					[precision is <RelatedValue>]
						[round to precision]
					[old value is <RelatedValue>]
					[<TextVariables>]
				<FieldName> is a[n] <BusinessClass> view

			Parameter Rules
				<parameter FullFieldName>
					<Rule>

			Local Fields
				// same definition as on Business Class

			Results
				(<FieldName> | <BusinessClass> view)

			Field Rules
				[(merge | replace) specifications]
				<FieldRules>

			SubType <ConditionName> Field Rules
				[(merge | replace) specifications]
				<FieldRules>

			Accumulators
				<FieldName> [<DataDefinition>]

			Instance Selection [<AsOfOperator>]
				[include [only] deleted records]
				where <Condition>

			Sort Order [is (<SetName> | primary)]
				<RelatedField>
					[is transaction boundary]

			Action Rules
				<Rule>
				Empty Set Rules
					<Rule>

				Set Rules
					Entrance Rules
						<Rule>

					Exit Rules
						<Rule>

				<sort FullFieldName> Set Rules
					Entrance Rules
						<Rule>

					Exit Rules
						<Rule>

				Instance Rules
					<Rule>

				Entrance Rules
					<Rule>

				Exit Rules
					<Rule>

				InitiateRequest Rules
					<Rule>

				UpdateRequest Rules
					<Rule>

				CancelRequest Rules
					<Rule>

				Rule Blocks
					<RuleBlockName>
						<Rule>

	ActionType ::= (Create | Update | Delete | Purge | Preview | Instance | Set | Import)

	EventHandler ::=
		on (<FullStateName>.<ActionName> | entrance to <FullStateName> | exit of <FullStateName>)
		Action Rules
			<Rule>
```

**ACTION RULES SYNTAX:**
```lpl
ActionRule ::=
	make transition to <FullStateName>

	commit transaction

	end set action instance loop

	build text search field <FullFieldName>
		Fields
			(<RelatedValue> | [<RelatedLink>.]<FieldGroupName>)

	initiate <RelatedValue> workflow
		[resume on error]
			[<ResumeOnErrorRule>]
		[Variables]
			[include [(persistent | auditable | user)] fields from <RelatedLink>]
			[<RelatedField>]
				[variable name is <LPLConstructName>]
		[assign message id to <FullFieldName>]

	cancel <RelatedValue> workflow
		message id is <FullFieldName>

	(initiate <PFlowServiceName> process | trigger <RelatedValue> PA service)
		[resume on error]
			[<ResumeOnErrorRule>]
		[title is <Message>]
		[Criteria]
			<RelatedField>
		[category filter is <RelatedField>]
			[variable name is <RelatedValue>]
		[Variables]
			[include [(persistent | auditable | user)] fields from <RelatedLink>]
			[<RelatedField>]
				[variable name is <LPLConstructName>]
		[URLs]
			(<HttpURL> | <LinkBack>)

	(cancel <PFlowServiceName> process | cancel <RelatedValue> PA service)

	invoke <InvocationTarget> [in (foreground | background [on <RelatedField>] | background group[<Parens>(<RelatedValue>)<Parens>])]
		[<InvokeRule>]
		[<Rule>]
		[<ControlRule>]
		(<InvokeRule> | <Rule>)

	invoke modify update stamp <RelatedLink>

	invoke method <NativeMethod>

	invoke script <RelatedValue>

	invoke derived field <RelatedValue>

	generate document <RelatedValue>
		set using action <ActionName>

	dbimport <RelatedField> into <BusinessClass>

	send ion bod
		bod is <RelatedValue>
		bod type is <RelatedValue>
		[assign message id to <FullFieldName>]
		[(expect | no) acknowledgement]
		[accounting entity is <RelatedValue>]
		[location is <RelatedValue>]
		[document id is <RelatedValue>]
		[variation id is <RelatedValue>]
		[revision id is <RelatedValue>]
		[source is <RelatedValue>]
		[instance count is <RelatedValue>]
		[custom property is <RelatedValue>]

	send notification
		to <RelatedValue>
		description is <Message>
		[priority is (very low | low | medium | high | very high)]
		[detail is <Message>]
		[<LinkBack>]
		[navigation is <NavigationName>]

	send email
		[to <RelatedValue>]
		[cc <RelatedValue>]
		[bcc <RelatedValue>]
		from <RelatedValue>
		[ignore invalid addresses]
		[subject <Message>]
		[<Attachment>]
		[Attachments]
			(<Attachment> | <ControlRule>)
		[<Appointment>]
		[Appointments]
			(<Appointment> | <ControlRule>)
		Contents
			(<Message> | <ControlRule where <Rule> is replaced by <Message>)

	link <RelatedValue> to this agent

	register new actor
		login name is <RelatedValue>
		password is <RelatedValue>
		webapp is <WebAppName>
		[registration key is <Message>]
		[role is <RelatedValue>]
		[person name is <RelatedValue>]
		[contact info is <RelatedValue>]

	update actor
		[person name is <RelatedValue>]
		[contact info is <RelatedValue>]
```

**INVOKE RULES:**
```lpl
InvokeRule ::=
	run outside of action background group

	run after (<FullFieldName> | current action background group | action background group <FullFieldName> | background group <Parens><RelatedValue><Parens>)
	on error
		invoke <InvocationTarget>
			[<Rule>]
			[<ControlRule>]
				(<InvokeRule> | <Rule>)

	assign async action request id to <FullFieldName>

	assign async [action] background group id to <FullFieldName>

	assign result to (<KeyField> | <ViewField> | <BusinessObjectReference>)

	assign message group id to <LawsonClassicMessageGroup KeyField>

	resume on error
	[<ResumeOnErrorRule>]

	fill in [blank] user fields from (parameters | <RelatedLink>)

	fill in [blank] audit fields from <RelatedLink>

	fill in [blank] fields from <RelatedLink>
		[except <InvokeRuleKeyword>.(<FullFieldName> | <FieldGroupName>)]

	<InvokeRuleKeyword>.<FullFieldName> <AssignmentOp> <RelatedValue>

	initialize <InvokeRuleKeyword>.<FullFieldName>

	<FullFieldName> <AssignmentOp> result.<FullFieldName>

InvokeRuleKeyword ::= (invoked | datasource)

InvocationAction ::= ([<FullStateName>].<ActionName> | audit create | audit update | change effective date | insert history | delete history | change create date | purge audit log entries)

InvocationTarget ::= <InvocationAction> [(<RelatedLink> | <BusinessClass> | <BusinessTask> | <LawsonClassicTransaction> | <M3Interface> | <WebserviceInterface> | <StaticJavaPD>)]
```

**TEXT VARIABLES:**
```lpl
TextVariables ::=
	Text Variables [<Parens>locale of <RelatedValue><Parens>]
		<TextVariable> [value is <RelatedValue>]
```

**DIMENSIONS AND MEASURES:**
```lpl
Dimensions
	<RelatedField>
		[dimension name is <Literal>]
		[label is <Message>]
		[suppress dimension when <SimpleCondition>]
		[caption is (representative text | <Message>)]
		[default total node is <RelatedField>]
		[top node is <RelatedField>]
		[disable hierarchy aggregation]
		[is a <PeriodType> period dimension [with year of <FullFieldName>]]
			[current year is <RelatedField>]
			[current period is <RelatedField>]
			[current date is <RelatedField>]
			[period set is <RelatedField>]
			[default label is <Message>]
			[current date period is <FullFieldName>]
			[year when <Condition>]
			[quarter when <Condition>]
			[month when <Condition>]
			[week when <Condition>]
			[day when <Condition>]
			[start date is <FullFieldName>]
			[end date is <FullFieldName>]
			[parent period is <FullFieldName>]
			[next period is <FullFieldName>]
			[previous period is <FullFieldName>]
			[beginning balance is <FullFieldName>]
			[ending balance is <FullFieldName>]
			[beginning ytd balance is <FullFieldName>]
			[ending ytd balance is <FullFieldName>]
		[valid for measure <FullFieldName>]
		[(allow write to summary level | write to base level only)]
		[Instance Selection]
			where <Condition>
		[Attributes]
			[child.]<FullFieldName>
		[Hierarchies]
			<HierarchyName>
				[base level (hidden | included)]
				[description is <Message>]
				Attributes
					[child.]<FullFieldName>

PeriodType ::= (monthly | weekly | daily | variable)

Measures
	<FullFieldName>
		[measure name is <Literal>]
		[calculate dynamically]
		[<DimensionField> value is <RelatedValue>]
		[cube rule is <Message>]
		[Dimension Based Measures]
			<FieldName>
				[<DefaultLabel>]
				Dimension Values
					<DimensionField> value is <RelatedValue>
```

**RULE BLOCKS:**
```lpl
Rule Blocks
	<RuleBlockName>
		<Rule>
```

**STATE CYCLES:**
```lpl
StateCycles
	<StateCycleDefinition>

StateCycleDefinition ::=
	<StateCycleName> is a StateCycle
		[state field is <persistent FieldName>]
		[initial state is <StateName>]
		<StateDefinition>

StateDefinition ::=
	<StateName> is a State
	Entrance Rules
		<Rule>
	Exit Rules
		<Rule>
	Field Rules
		[(merge | replace) specifications]
		<FieldRules>
	SubType <ConditionName> Field Rules
		[(merge | replace) specifications]
		<FieldRules>
	[<EventHandler>]
	[<ActionDefinition>]
	[<StateCycleDefinition>]
```

**ADDITIONAL RULE SECTIONS:**
```lpl
Commit Rules
	<Rule>

Audit Entry Rules
	<Rule>

Apply Pending Effective Rules
	<Rule>

Create Rules
	<Rule>

Create Exit Rules
	<Rule>

Update Action Rules
	<Rule>

Delete Rules
	<Rule>

Translation Rules
	<Rule>

Action Exit Rules
	<Rule>

Attach Rules
	<Rule>

Parent Attach Rules
	<Rule>

Dynamic Creation Rules
	<Rule>
```

**FORM INVOKES AND MATRIX FORMS:**
```lpl
Form Invokes
	<FormInvokeName>
		(<FormInvokeRule> | <ControlRule>)

FormInvokeRule ::=
	invoke <InvocationTarget>
		[fill in [blank] fields from <RelatedLink>]
			[except invoked.(<FullFieldName> | <FieldGroupName>)]
		[invoked.<FullFieldName> <AssignmentOp> <RelatedValue>]
		[<Rule>]

Matrix Forms
	<MatrixForm>
		rows are <RelatedLink>
		(column is <BusinessClass> | columns are <RelatedLink>)
		cell is <BusinessClass>
			[completion message is <Message>]
			[(create all instances | create instance when <Condition>)]
```

**CUBE AND COLUMNAR RELATIONS:**
```lpl
Cube Relations
	<CubeRelationName>
		(cell | matrix) relation to <BusinessClass>
		[allow dimension reordering]
		[period view is <PeriodOperator>]
		[dynamic mapping is <RelatedValue>]
		[dynamic preload measures are <RelatedValue>]
		[Dimension Mapping]
			related.<DimensionField> (= <RelatedValue> [and blank dimension] | where (<MeasureCondition>))
		[Preload Measures]
			<FullFieldName> [<PeriodOperator>]

Columnar Relations
	<ColumnarRelationName>
		(cell | matrix) relation to <BusinessClass>
		[period view is <PeriodOperator>]
		[dynamic mapping is <RelatedValue>]
		[dynamic preload measures are <RelatedValue>]
		[Dimensions]
			[related.<RelatedField> = <RelatedValue>]
		[Preload Measures]
			<FullFieldName> [<PeriodOperator>]
		[Instance Selection]
			where <Condition>
```

**FIELD GROUPS AND CONTEXT FIELDS:**
```lpl
Field Groups
	<FieldGroupName>
		[include [(persistent | auditable | derived)] user fields]
		<FullFieldName>

Context Fields
	<ContextField>
		[<DefaultLabel>]
		[is (condition | related (link | value)) for <RelatedValue>]
			[(dimensions [with attributes] | measures) only]

Audit Index Fields
	<FullFieldName>

Text Search Fields
	(<FullFieldName> | <FieldGroupName>)
		[is a facet]
		[(index words | index phrase)]
		[(index data translations | index base data only)]
```

**SUPPRESS WARNINGS:**
```lpl
Suppress Warnings
	(set size on <SetName> | all set size warnings)
```

**DATA SOURCE MAPPING:**
```lpl
DataSource Mapping
	<DataSourceCRUDType> is <DataSourceAction>
		<InvokeRule>

DataSourceType ::= (MI | WSI)

DataSourceCRUDType ::= (set | find | create | update | delete)

DataSourceAction ::= <WebserviceInterface>.<ActionName>
```

**Pattern Matching:** Regular expression validation using 'matches' syntax
- **Cross-Field Validation:** StartDate/EndDate consistency checks
- **Actor Integration:** actor.agent(Employee).Employee for user context
- **Complex Derived Fields:** Mathematical calculations and string concatenation
- **Set Relations:** Filtered collections with Instance Selection
- **Background Processing:** Set Actions with run in background
- **Parameter Validation:** Required parameters with constraints
- **Confirmation Dialogs:** User confirmation for critical operations
- **Cascade Operations:** Related entity creation and deletion
- **Workflow Integration:** Approval processes with history tracking
- **Notification Systems:** Automated expiration notifications
- **Bulk Processing:** Set Actions for renewal and notification processing

**Business Logic Complexity:**
- Contract lifecycle management (Draft  Active  Expired/Terminated)
- Approval workflows based on contract value thresholds
- Automatic renewal processing with configurable periods
- Expiration notification system with customizable lead times
- Amendment tracking with value aggregation
- Vendor relationship management with status validation
- Employee responsibility assignment with active status checks
- Document management integration
- Multi-currency support with international amounts
- Comprehensive audit trail and change tracking
- Release: Set Action with parameter validation and conditional release
- ImportRecords: Complex Set Action with create/delete operations and iteration
- Purge: Cleanup Set Action
- Create, Update: Standard CRUD operations
- Delete: Purge Action with cascade deletion

**Key LPL Patterns Observed:**
- Async action request integration with "run after" dependency
- Complex error handling with resume on error patterns
- Set relations with Instance Selection filtering
- Cascade deletion in Delete action entrance rules
- Conditional processing based on business rules
- Background processing with async ID tracking
- Import/export data processing workflow
- Parameter validation in Set Actions
- Complex iteration with for each loops
- Error message aggregation through derived fields

=== SANPURCHASEORDERRECEIPTLINEIMPORT ANALYSIS ===

**Business Class Structure:**
- Prefix: cfg
- Symbolic key: SanPurchaseOrderReceiptLineImport
- Line-level import processing for purchase order receipts

**Field Analysis (8 Persistent Fields):**
- RunGroup (key field)
- Location (Alpha size 15)
- EnteredReceivedQuantity (Quantity type)
- ReceivedUOM (UnitOfMeasure reference)
- OriginalUnitCost (Decimal size 17.3)
- CancelBackOrder (Boolean)
- RecComments, ErrorMessage (Text fields)

**Field Rules:**
- Required fields: SanPurchaseOrderReceiptImport, Company, RunGroup
- Simple validation structure focused on key field requirements

=== COMPREHENSIVE FIELD DEFINITION SYNTAX ===

**FIELD STRUCTURE:**
```lpl
<FieldName> is a (Field | KeyField)
	[owned by <ModuleName>]
	[(<SqlName> | <SqlPrefix>)]
	[<ClassicName>]
	[<DefaultLabel>]
	[text searchable]
	[scannable]
	[holds pii]
	[default filter operator is (contains | starts with | equals)]

	[extends <FieldName>]
		[member of <extended FieldName> peer group]
		[(delete cascades | delete ignored)]
		[name is <Literal>]

	Representation
	Ontology
	Patterns
	Display Fields
	Surrogate For
	Context Fields
	Transient Fields   // valid on group or array fields only
	Local Fields       // valid on group or array fields only
	Derived Fields     // valid on group or array fields only
	Conditions         // valid on group or array fields only
	Cube Relations     // valid on group or array fields only
	Columnar Relations // valid on group or array fields only
	Relations          // valid on group or array fields only
	Rule Blocks
	Field Rules
```

**REPRESENTATION SECTION:**
```lpl
Representation
	[<FieldRepresentation>]

FieldRepresentation ::= (<SimpleField> | <GroupField> | <ArrayField>)

SimpleField ::=
	type <DataDefinition>
		[precision is <RelatedValue>]
			[round to precision]
	[<States>]

GroupField ::=
	Group Fields
		<FieldName> [<DataDefinition>]
		[<States>]
		[<SqlName>]
		[<ClassicName>]
		[<ClassicNameForField>]
		[<SqlNameForField>]
		[<DefaultLabel>]
		[text searchable]
		[scannable]
		[encrypt]
		[holds pii]
		[enable alternate document location]
			[document is <RelatedField>]
			[existence is <RelatedField>]
		[disable Auditing [when in background]]
		[disable EffectiveDated]
		[enable EffectiveDated]
		[automate context]
		[disable surrogates]
		[allow images]
		[(delete cascades | delete ignored)]
		[translatable]
		[restricted]
		[protected]
		[precision is <RelatedValue>]
			[round to precision]
		[primitive type is <RelatedValue>]
		[primitive size is <RelatedValue>]
		[primitive decimal size is <RelatedValue>]
		[create value is blank if no entry]
		[as of <RelatedValue>]
		[within <RelatedValue>]
			[<Message>]
		[[exact] version is (<RelatedValue> | latest)]
		[data area is <RelatedValue>]
		[is (condition | related (link | value)) for <RelatedValue>]
			[(dimensions [with attributes] | measures) only]
		[<TextVariables>]
		[document template [for <BusinessClass>]]
		[store as BusinessObjectReference]
			[<SqlPrefix>]

ArrayField ::=
	<FieldName> [<DataDefinition>]
		occurs (<Literal> | sizeofarray <ArrayField> | unlimited) times
```

**ONTOLOGY SECTION (KeyFields only):**
```lpl
Ontology
	[stereotype is <Stereotype>]
	business class is <BusinessClass>
		[existence not required]

	Context
		<KeyField>
			[version is (latest | exact)]
			[value is <RelatedValue>]
			[delete (restricted | cascades | ignored)]
			[disable surrogates]
			[context of <FullFieldName>]
			[optional]
			[data area is <RelatedValue>]
			[(enable | disable) surrogate context]
			[within <RelatedValue>]
				[<Message>]

Stereotype ::= (Agent
				| Business Policy
				| Document
				| DocumentAccounting
				| DocumentDistribution
				| DocumentFulfillment
				| AccountingTransaction)
```

**PATTERNS SECTION:**
```lpl
Patterns
	[disable StaticTranslations]

	[implements AccessInitializer]
		initializer is <FieldName>

	[implements MutuallyExclusive]
		field determiner is <RelatedField>
			<StateName> field is <FieldName>

	[implements FieldRange]
	from is <FieldName>
	[exclusive]
	to is <FieldName>
	[exclusive]

	[implements CompactFormat]
	[delimiter is <Literal>]
	[format fields based on primary form]

	[implements UserDefinedStates]

	[implements ArrayHierarchy]

	[implements ParentHierarchy]
	[parent field name is <FieldName>]
	[<ClassicName>]
	[descendants are <RelatedLink>]

	[implements Versioning]
	version field is <FieldName>
	[<ClassicName>]

	[implements Specialization]
	[control valid key values]
	[effective date as a group]
	[set retrieval is inclusive]
```

**DISPLAY FIELDS SECTION (KeyFields only):**
```lpl
Display Fields
	<RelatedField>
```

**SURROGATE FOR SECTION (KeyFields only):**
```lpl
Surrogate For
	<FieldName> value is <RelatedField>
```

**CONTEXT FIELDS SECTION:**
```lpl
Context Fields
	<ContextField>

ContextField ::=
	<FieldName> [<DataDefinition>]
		[[exact] version is (<RelatedValue> | latest)]
		[<ContextRule>]

ContextRule ::=
	<RelatedField> <AssignmentOp> <RelatedValue>

	default to <RelatedValue>

	constraint <Condition>
		<Message>

	required
		[<Message>]

	if <Parens><FieldName> <ContextOperator><Parens>
		<ContextRule>
	[else
		<ContextRule>]

ContextOperator ::= (in context | entered)
```

**FIELD ADDRESSING RULES:**
- **KeyField:** '.' operator addresses all elements on the business class that the KeyField is centered on
- **Subtype KeyFields:** Use 'APCompany.Company.FieldName' to address parent fields, 'Company.APCompany.FieldName' for subtype fields
- **GroupField:** '.' operator reaches through GroupField to address nested fields unambiguously
- **ArrayField:** Similar to GroupField, allows reaching through to nested elements
- **Direct Addressing:** Rules can directly address nested fields (e.g., 'City' reaches through 'Address.PostalArea.City')

**FIELD EXTENSION PATTERNS:**
- **KeyField Extension:** Typically specifies additional business class for particular instances
- **Field Extension:** Usually sets context variables of the base field
- **Peer Groups:** Set of KeyFields that are surrogates of each other with identical surrogate values
- **Context Values:** Extended fields can set specific context values (e.g., PCOdeType.Location)

**FIELD TYPES AND ATTRIBUTES:**
- **SimpleField:** Basic data type with optional precision and states
- **GroupField:** Collection of related fields with individual attributes
- **ArrayField:** Repeating field structure with occurrence limits
- **Text Searchable:** Enables database text search indexing
- **Scannable:** Supports barcode/QR code scanning
- **Holds PII:** Marks personally identifiable information
- **Restricted:** Cannot be used in UI
- **Protected:** Application-controlled, no UI/webservice updates
- **Translatable:** Supports data translation
- **Encrypted:** Database-level encryption for Alpha fields

**PATTERN IMPLEMENTATIONS:**
- **AccessInitializer:** Initializes field access through derived field
- **MutuallyExclusive:** Dynamic field type based on determiner field
- **FieldRange:** From/to range validation with inclusive/exclusive options
- **CompactFormat:** Single string entry with delimiter separation
- **UserDefinedStates:** Dynamic state values from business class instances
- **ArrayHierarchy:** Hierarchical array structure with cascade deletion
- **ParentHierarchy:** Parent-child relationships with cascade deletion
- **Versioning:** Version control using designated version field
- **Specialization:** Hierarchical specialization with controlled key values

**CONTEXT FIELD FEATURES:**
- **Non-ontological:** Not required to be in context, evaluated each time
- **Assignment Rules:** Direct field value assignments
- **Default Chains:** Multiple fallback values with literal as last option
- **Constraint Validation:** Conditional validation with error messages
- **Required Fields:** Mandatory field validation
- **Conditional Logic:** if/else context evaluation
- **Context Operators:** 'in context' and 'entered' state checking

**ADVANCED FIELD FEATURES:**
- **Document Templates:** RTF templates with LPL variable replacement
- **Alternate Document Location:** External document storage
- **Business Object References:** Asynchronous operation support
- **Version Control:** Latest or exact version specification
- **Data Area Specification:** Environment-specific data storage
- **Cube Integration:** Dimensions and measures support
- **Primitive Type Override:** Custom primitive type specification
- **Audit Control:** Selective auditing enable/disable
- **Effective Dating:** Participation in effective dating patterns

**FIELD VALIDATION PATTERNS:**
- **Precision Control:** Numeric precision with rounding options
- **Size Constraints:** Primitive size and decimal size limits
- **Version Validation:** Exact or latest version matching
- **Range Validation:** Within clause for value range checking
- **Existence Validation:** Optional existence requirements
- **Context Validation:** Context-aware field validation
- **Surrogate Validation:** Surrogate field value validation
- **Delete Rules:** Cascade, restrict, or ignore deletion behavior

=== TYPE OPERATORS ===
TypeOperator ::= (decimals | type | size | uppercase | lowercase | year | month | month [short] name | day | day [short] name | week day | corporate week day | week day using <RelatedValue> | year day | week | week year | days in month | days in year | as years | as months | as days | hours | minutes | seconds | date | corporate date | system date | date using <RelatedValue> | time | anniversary | period | levels | level <#> | entries | compact format | version | label | [full] name | text | [exact] translation | mime type | in base64 | translations | document location | (local | external) document | select <SelectStatement> | select line <SelectLineStatement> | document [for <RelatedLink>] | compute value [for <RelatedLink>] | as of <RelatedValue> | (date | audit entry) (first | last | next) changed [(from | to) <RelatedValue>] | days was <RelatedValue> [while <Condition>] [between <RelatedValue> and <RelatedValue>] | weighted average [between <RelatedValue> and <RelatedValue>] | <PeriodOperator> | cube dimension value [using year of <RelatedValue>] | input value | plain text | split [on <Literal>] | using <JavaFormat> [using <RelatedValue>] | (short | medium | long) timestamp [with day [short] name] [(show | hide) time zone][(show | hide) seconds] [using <RelatedValue>] | (short | medium | long) date [with day [short] name] [using <RelatedValue>] | (short | medium | long) anniversary [with day [short] name] [using <RelatedValue>] | (short | medium | long) period [using <RelatedValue>])

**TYPE OPERATOR CATEGORIES:**

**Data Type Information:**
- decimals - returns number of decimal places in numeric field
- type - returns the data type of the field
- size - returns the size specification of the field

**Text Formatting:**
- uppercase - converts text to uppercase
- lowercase - converts text to lowercase
- text - converts field to text representation
- label - returns the field's display label
- name - returns the field name
- full name - returns the complete field name
- translation - returns translated text
- exact translation - returns exact translation match
- translations - returns all available translations

**Date/Time Components:**
- year - extracts year from date field
- month - extracts month number
- month short name - returns abbreviated month name
- day - extracts day from date
- day short name - returns abbreviated day name
- week day - returns day of week
- corporate week day - returns corporate calendar weekday
- week day using <RelatedValue> - weekday using specific calendar
- year day - returns day number within year (1-366)
- week - returns week number
- week year - returns year for week numbering
- days in month - returns number of days in month
- days in year - returns number of days in year (365/366)
- hours - extracts hours from time/timestamp
- minutes - extracts minutes from time/timestamp
- seconds - extracts seconds from time/timestamp

**Date/Time Conversions:**
- as years - converts duration to years
- as months - converts duration to months
- as days - converts duration to days
- date - formats as date
- corporate date - formats using corporate calendar
- system date - formats using system settings
- date using <RelatedValue> - formats using specified locale
- time - formats as time
- anniversary - formats as anniversary
- period - formats as period

**Formatting Options:**
- short timestamp - abbreviated timestamp format
- medium timestamp - medium timestamp format
- long timestamp - full timestamp format
- short date - abbreviated date format
- medium date - medium date format
- long date - full date format
- with day name - includes day name in format
- with day short name - includes abbreviated day name
- show/hide time zone - controls time zone display
- show/hide seconds - controls seconds display
- using <RelatedValue> - uses specified locale/format

**Document/Binary Operations:**
- mime type - returns MIME type of document/binary field
- in base64 - encodes binary data as Base64 string
- document location - returns document storage location
- local document - accesses local document content
- external document - accesses external document content
- document for <RelatedLink> - retrieves document for specific link

**Advanced Operations:**
- select <SelectStatement> - executes SQL select on XML/JSON
- select line <SelectLineStatement> - selects specific line from text
- compute value for <RelatedLink> - computes value for relation
- as of <RelatedValue> - retrieves value as of specific date/time
- cube dimension value - extracts cube dimension value
- input value - returns original input value
- plain text - extracts plain text from rich content
- split on <Literal> - splits text on delimiter
- using <JavaFormat> - formats using Java format pattern

**Audit/Change Tracking:**
- date first changed - first change date
- date last changed - last change date
- date next changed - next scheduled change
- audit entry first changed - first audit entry
- audit entry last changed - last audit entry
- days was <RelatedValue> - days field had specific value
- weighted average - calculates weighted average over time period

**Hierarchical/Structural:**
- levels - returns number of hierarchy levels
- level <#> - returns specific hierarchy level
- entries - returns number of entries
- compact format - returns compact string representation
- version - returns version information

**USAGE EXAMPLES:**
```lpl
// Data type information
FieldSize = SomeField size
FieldType = SomeField type
DecimalPlaces = NumericField decimals

// Text formatting
UpperName = CustomerName uppercase
LowerCode = ProductCode lowercase
FieldLabel = Description label

// Date/time components
CurrentYear = OrderDate year
CurrentMonth = OrderDate month
DayOfWeek = ShipDate week day
TimeHours = Timestamp hours

// Date conversions
AgeInYears = BirthDate as years
DaysOld = CreateDate as days
FormattedDate = OrderDate short date

// Document operations
FileType = Attachment mime type
EncodedDoc = Document in base64
DocPath = Attachment document location

// Advanced operations
XMLValue = XMLField select "//node/value"
PlainContent = RichTextField plain text
SplitValues = CodeField split on "-"
```

=== FIELD OPERATORS ===
FieldOperator ::= (not | ! | no | old | any | all | first | last | sum | avg | min | max | floor | ceiling | pending | instance count of | sizeofarray | (first | last) iteration of | next | previous | reference to | target of)

**FIELD OPERATOR CATEGORIES:**

**Logical/Negation Operators:**
- not - logical negation of field value
- ! - negation operator (alternative syntax)
- no - checks for absence/empty state

**Temporal/State Operators:**
- old - retrieves previous value before change
- pending - checks for pending changes

**Collection/Aggregation Operators:**
- any - checks if any instance exists in collection
- all - validates all instances match condition
- first - retrieves first instance from collection
- last - retrieves last instance from collection
- sum - calculates sum of numeric values
- avg - calculates average of numeric values
- min - finds minimum value in collection
- max - finds maximum value in collection

**Mathematical Operators:**
- floor - rounds down to nearest integer
- ceiling - rounds up to nearest integer

**Array/Collection Size Operators:**
- sizeofarray - returns size of array field
- instance count of - counts instances matching criteria

**Navigation Operators:**
- first iteration of - first iteration in loop
- last iteration of - last iteration in loop
- next - navigates to next instance
- previous - navigates to previous instance

**Reference Operators:**
- reference to - creates reference pointer
- target of - retrieves target of reference

**USAGE EXAMPLES:**
```lpl
// Aggregation operators
TotalAmount = sum LineItemsRel.Amount
AveragePrice = avg ProductsRel.UnitPrice
HighestValue = max ValuesRel.Amount

// Collection operators
HasActiveLines = any LineItemsRel where (Status = "Active")
AllApproved = all ApprovalsRel where (Approved = true)

// Navigation operators
FirstItem = first ItemsRel
LastEntry = last EntriesRel

// Mathematical operators
RoundedDown = floor CalculatedAmount
RoundedUp = ceiling EstimatedCost

// State operators
PreviousStatus = old Status
HasPendingChanges = pending ModifiedField

// Array operators
ItemCount = sizeofarray ItemArray
ActiveCount = instance count of ActiveItemsRel
```

=== COMPREHENSIVE GENERAL DEFINITIONS SYNTAX ===

**BASE DEFINITIONS:**
```lpl
LPLConstructName ::= <uppercase character>[<alphanumeric characters>] // up to 255 characters

ActionName ::= <LPLConstructName>
BusinessClass ::= <LPLConstructName>
FieldName ::= <LPLConstructName>
RelationName ::= <LPLConstructName>
SetName ::= <LPLConstructName>
StateName ::= (<LPLConstructName> | <#>)
ConditionName ::= <LPLConstructName>
RuleBlockName ::= <LPLConstructName>

ModuleName ::= <alphanumeric characters>
ClassicPrefix ::= prefix is <string of 2 to 5 alphanumeric characters>
ClassicName ::= classic name is <Literal>
SqlName ::= sql name is <Literal>
SqlPrefix ::= sql prefix is <string of 2 to 5 alphanumeric characters>
```

**DATA TYPES:**
```lpl
PrimitiveType ::= (Alpha | AlphaRight | AlphaUpper | Anniversary | BinaryDocument | BinaryObject | Boolean | BusinessObjectReference [to <BusinessClass>] | CSVText | Date | [Unsigned] Decimal | DocumentTitle | EmailAddressField [with multiple addresses] | MultiEmailAddressField | GroupField | Integer | Iteration of <BusinessClass> | JSONObject | MimeType | Numeric | Password | [Unsigned] Percent | Period | RichText | Signed | Text | TextDocument | Time | TimeStamp | UniqueID | URI | URL | XMLDocument | Year)

TypeDataDefinition ::= [us-ascii]<PrimitiveType> [[size (fixed | up to)] <FieldSize>[.<NbrDecimals>]]

DataDefinition ::= (is a[n] <FieldName> | is like <FieldName> | is a[n] <BusinessClass> group [in subject <Subject>] | is a[n] <BusinessClass> compute [in subject <Subject>] [measures only] | is <TypeDataDefinition>)
```

**FIELD REFERENCES:**
```lpl
FullFieldName ::= (<FieldOrArrayName>[.<FieldOrArrayName>] | <CreateStamp> | <CreateDate> | <UpdateStamp> | <RelevanceScore> | <ActionAttribute> | <BODId> | <CurrentAsyncId> | <CurrentActionBackgroundGroupId> | has future changes | user fields[<Parens><BusinessClass><Parens>])

FieldOrArrayName ::= (<FieldName> | <ArrayComponent>)

ArrayComponent ::= (<array RelatedField> | <array RelationName> | <ArrayRangeAddress> | <special index SingleValueArrayAddress>)

SingleValueArrayAddress ::= <ArrayComponent>'['<IndexVariable>']'
ArrayRangeAddress ::= <ArrayComponent>'['[<I>=]<from IndexVariable>:<to IndexVariable>']'
```

**OPERATORS:**
```lpl
FieldOperator ::= (not | ! | no | old | any | all | first | last | sum | avg | min | max | floor | ceiling | pending | instance count of | sizeofarray | (first | last) iteration of | next | previous | reference to | target of)

TypeOperator ::= (decimals | type | size | uppercase | lowercase | year | month | month [short] name | day | day [short] name | week day | corporate week day | week day using <RelatedValue> | year day | week | week year | days in month | days in year | as years | as months | as days | hours | minutes | seconds | date | corporate date | system date | date using <RelatedValue> | time | anniversary | period | levels | level <#> | entries | compact format | version | label | [full] name | text | [exact] translation | mime type | in base64 | translations | document location | (local | external) document | select <SelectStatement> | select line <SelectLineStatement> | document [for <RelatedLink>] | compute value [for <RelatedLink>] | as of <RelatedValue> | (date | audit entry) (first | last | next) changed [(from | to) <RelatedValue>] | days was <RelatedValue> [while <Condition>] [between <RelatedValue> and <RelatedValue>] | weighted average [between <RelatedValue> and <RelatedValue>] | <PeriodOperator> | cube dimension value [using year of <RelatedValue>] | input value | plain text | split [on <Literal>] | using <JavaFormat> [using <RelatedValue>] | (short | medium | long) timestamp [with day [short] name] [(show | hide) time zone][(show | hide) seconds] [using <RelatedValue>] | (short | medium | long) date [with day [short] name] [using <RelatedValue>] | (short | medium | long) anniversary [with day [short] name] [using <RelatedValue>] | (short | medium | long) period [using <RelatedValue>])

PeriodOperator ::= ([(prior | next) year [<#>]] [(prior | next)] (period[s] | week[s] | month[s] | quarter[s] | [all] year[s]) [<#> [thru <#>]] | [(prior | next) year [<#>]] [(prior | next)] (period | week | month | quarter | year) [<#>] (beginning | ending) [ytd] balance)
```

**DATE/TIME REFERENCES:**
```lpl
CurrentDateTime ::= (current [(corporate | user)] time | [system] current [(corporate | user)] date | [system] current [(corporate | user)] year | [system] current [corporate] period | [system] current timestamp | [system] current [(corporate | user)] anniversary)

**CURRENT DATE/TIME CATEGORIES:**

**Time References:**
- current time - current system time
- current corporate time - current corporate time
- current user time - current user time
- current date - current system date
- current corporate date - current corporate date
- current user date - current user date
- system current date - system current date
- current year - current year
- current corporate year - current corporate year
- current user year - current user year
- current period - current period
- current corporate period - current corporate period
- current timestamp - current timestamp
- current anniversary - current anniversary
- current corporate anniversary - current corporate anniversary
- current user anniversary - current user anniversaryrrent time - current system time
- current corporate time - current corporate calendar time
- current user time - current user timezone time

**Date References:**
- current date - current system date
- current corporate date - current corporate calendar date
- current user date - current user timezone date
- system current date - system-level current date
- system current corporate date - system corporate calendar date
- system current user date - system user timezone date

**Year References:**
- current year - current system year
- current corporate year - current corporate calendar year
- current user year - current user timezone year
- system current year - system-level current year
- system current corporate year - system corporate calendar year
- system current user year - system user timezone year

**Period References:**
- current period - current accounting period
- current corporate period - current corporate accounting period
- system current period - system-level current period
- system current corporate period - system corporate accounting period

**Timestamp References:**
- current timestamp - current system timestamp with date and time
- system current timestamp - system-level current timestamp

**Anniversary References:**
- current anniversary - current anniversary date (month/day only)
- current corporate anniversary - current corporate anniversary
- current user anniversary - current user anniversary
- system current anniversary - system-level current anniversary
- system current corporate anniversary - system corporate anniversary
- system current user anniversary - system user anniversary

**USAGE EXAMPLES:**
```lpl
// Field Rules - default assignments
Field Rules
    CreatedDate
        default to current date
    CreatedTime
        default to current time
    CreatedTimestamp
        default to current timestamp
    FiscalYear
        default to current corporate year
    AccountingPeriod
        default to current corporate period

// Derived Fields - dynamic calculations
Derived Fields
    CurrentSystemDate    is a DerivedField
        type is Date
        restricted
        return current date
    
    CurrentFiscalYear    is a DerivedField
        type is Numeric size 4
        restricted
        return current corporate year
    
    DaysFromCreation     is a DerivedField
        type is Numeric size 5
        restricted
        return current date - CreateDate

// Action Rules - timestamp assignments
Action Rules
    ProcessedDate = current corporate date
    ProcessedTime = current corporate time
    LastUpdated = current timestamp
    
// Conditions - date comparisons
Conditions
    IsCurrentYear
        when (TransactionDate year = current year)
    
    IsCurrentPeriod
        when (PostingPeriod = current corporate period)
```

**CALENDAR CONTEXT:**
- **System:** Uses server/system timezone and calendar
- **Corporate:** Uses organization's fiscal calendar and timezone
- **User:** Uses individual user's timezone and preferences

**DATA TYPE COMPATIBILITY:**
- Time references return Time data type
- Date references return Date data type
- Year references return Numeric data type
- Period references return Period data type
- Timestamp references return TimeStamp data type
- Anniversary references return Anniversary data type

CreateStamp ::= create stamp[.actor]
UpdateStamp ::= update stamp[.actor]
CreateDate ::= create date
CreateEffectiveDate ::= create effective date

TimeZoneVar ::= (user time zone | corporate time zone)
DurationVars ::= (duration begin date | duration end date)
```

**DATA LINKS:**
```lpl
DataLink ::= [<LinkOperator>] (<KeyField> [set] | <hierarchy KeyField> (parent | [and] children | [and] siblings | [and] descendants | [and] ancestors | ascendant) | <RelationName> | <CubeRelationName> | <ColumnarRelationName> | <BusinessClass>[<Parens>(<KeyField> | <BusinessObjectReference>)<Parens>] [set] | <BusinessObjectReference>[<Parens><BusinessClass><Parens>] | <BusinessClassTotal> | <Agent> | <SessionKey> | actor.context.<KeyField> | audit log records [descending] | [(draft | in process | completed | rejected)] [<BusinessClass>.Create] action requests | this instance | related | from | each[<Parens><LPLConstructName><Parens>] | invoked | result | child | cube[<Parens><BusinessClass><Parens>] | cube drill set | <TimeZoneVar>) [<AsOfOperator>] [<Parens>locale of <RelatedValue><Parens>] [<Parens>where <Condition><Parens>] [<Parens>level <#><Parens>]

RelatedLink ::= <DataLink>[.<DataLink>]

RelatedField ::= [<FieldOperator>] ([<RelatedLink>.]<FullFieldName> | <RelatedLink> (first | last) date within <RelatedLink> | instance count [where <Condition>] | <InlineEquation>) [<TypeOperator>] [<TotalOperator>]

RelatedValue ::= (<RelatedField>[.<StateName>] | <Value> | <ParentContext> | <Actor> | <CurrentDateTime> | <DurationVars> | <CreateStamp> | <UpdateStamp> | <ConfigVar> | <DocTemplate> | <Phrase> | <URLVar> | <SessionKey> | <SessionClaim> | <LinkBack> | <BaseURL> | error message [(key | field name | stack trace)] | page number | <NavigationName> as pdf [in (portrait | landscape)] [font offset is <Number>] | <PeriodLabel> | <CreateOrUpdateMode> | <TenantID> | <LogicalID> | <DocumentLocation> | <TotalVar> | <TimeZoneVar>)
```

**CONFIGURATION VARIABLES:**
```lpl
ConfigVar ::= [stack]config [<Parens><ConfigCategory><Parens>].<Literal>
SessionKey ::= session.key.<FieldName>
SessionClaim ::= session.claim.<Literal>
URLVar ::= url.<Literal>
TenantID ::= tenant id
LogicalID ::= logical id
```

**ACTORS AND ACTIONS:**
```lpl
Actor ::= [(authenticated | agent)] actor [(<ActorAttribute> | context.<FieldName> | context.<SecurityClaim>)]

ActorAttribute ::= (<actor FieldName> | initiator | approver | final approver)

Agent ::= [[authenticated] actor.]agent[<Parens><BusinessClass><Parens>]

ActionAttribute ::= (<Actor> | action | action comment | action type[.(Create | Update | Delete | Unknown)] | action tag | applied stamp | audit entry id | audit period[.(Past | Current | Future)] | correction | correction comment | effective date | effective time zone | effective through | effective stamp | entry stamp | initiating action | invoking action | reason code | subject | system stamp | action request id | changed field names | changed fields | purge date | audit transaction id | session | server identity | remote identity)

ActionTagValue ::= action tag.<ActionTag>
```

**MESSAGES AND TEMPLATES:**
```lpl
Message ::= ([(untranslatable: | configuration:)]<LiteralMessage> | <MessageID>) [<MessageTranslation>]

LiteralMessage ::= '"'(<Literal> | '<'<RelatedValue>'>')'"'
MessageID ::= '"'(<Literal> | '<'<RelatedValue>'>')'"'
MessageTranslation ::= translation for <IsoLocale> is <LiteralMessage>

DocTemplate ::= (template.<Literal> | template name.<RelatedField>)
Phrase ::= phrase[<Parens>locale of <RelatedValue><Parens>].<Literal>
```

**CONSTANTS AND VALUES:**
```lpl
Constant ::= (true | false | blank | high value)

Value ::= (<Text> | <Number> | <#> [(year[s] | month[s] | day[s])] | <Percent> | <Constant> | <ActionTagValue> | <StateFieldName>)

Number ::= [-]<numeric characters>[.<numeric characters>]
Percent ::= <Number>%
Text ::= '"'<alphanumeric characters>'"'
Literal ::= <any character except whitespace or angle brackets>
```

**STATES:**
```lpl
States ::=
States
	<StateName> value is <Literal> [with <Icon>]
	[<DefaultLabel>]
```

**LINKBACKS:**
```lpl
LinkBack ::= linkback<Parens>
	webapp is <WebAppName>
	navigation is <NavigationName>
	[allow anonymous access]
	[show form only]
	[text is <Message>]
	[session key <KeyField> is <RelatedValue>]
<Parens>
```

**ARRAY OPERATIONS:**
```lpl
I ::= (i | j | k)
IndexVariable ::= (<RelatedValue> | <I> | <SizeOfArray>)
SizeOfArray ::= sizeofarray <ArrayComponent>
Distinct ::= distinct (<FullFieldName> | <FieldGroupName>)
```

**INLINE EQUATIONS:**
```lpl
InlineEquation ::= [<Parens>]<RelatedValue> <MathOperator> <RelatedValue>[<Parens>]
```

**SPECIAL REFERENCES:**
```lpl
ParentContext ::= parentcontext.(isbusclass | name | locale | stereotype | istransaction | module | dataarea | <SymbolicKeyVar> | isbustask)

BusinessClassTotal ::= total<Parens><BusinessClass>.<RelatedValue>[,<DimensionField> = <RelatedValue>]<Parens>

BaseURL ::= base url<Parens>webapp is <WebAppName><Parens>

SelectStatement ::= <Message>
SelectLineStatement ::= that (starts with | contains | ends with) <Message>

JavaFormat ::= '"'(<Literal> | '<'<RelatedValue>'>')'"'

RelevanceScore ::= relevance score
PeriodLabel ::= period label
CreateOrUpdateMode ::= mode
DocumentLocation ::= document location.(Local | AWS S3 | External)
```

=== MENU DEFINITION SYNTAX ===

**MENU STRUCTURE:**
```lpl
<MenuName> is a Menu
	[show as springboard]
	[Search Terms]
		<Message>

	(<MenuItems> | <MenuPanel>)

	[<MenuName> is a Menu ]
		[Search Terms]
			<Message>
		<MenuItems>
```

**MENU ITEMS:**
```lpl
MenuItems ::=
	Menu Items
		<MenuItemName>
			[title is <Message>]
			[(icon is <Icon> | image is <ImageName>)]
			[(valid | visible) when <BusinessClass>.<SimpleCondition>]
			<MenuItem>
			[allow anonymous access]
			[Search Terms]
				<Message>
```

**MENU ITEM TYPES:**
```lpl
MenuItem ::=
	(page is <PageName>[.<PanelName>]
	| list is <BusinessClass>[<AsOfOperator>].(<ListName> | primary)
	| form is <BusinessClass>.(<FormName> | primary)
		[actor agent required]
		[create action is [<StateName>.]<ActionName>]
		[open action is [<StateName>.]<ActionName>]
		[(restrict | enable) action [<StateName>.]<ActionName>]
	| action is [<BusinessClass> | <BusinessTask>].<ActionName>
	| link is [<BusinessClass>.]<UILink>
	| menu is <MenuName>
	| image map is <ImageMapName>
	| webapp is <WebAppName>)
```

**MENU FEATURES:**
- **Springboard Display:** `show as springboard` brings up menu in springboard format
- **Search Terms:** Searchable keywords for menu items
- **Conditional Visibility:** `valid when` and `visible when` with business class conditions
- **Anonymous Access:** `allow anonymous access` for public menu items
- **Icon Support:** Icons or images for visual menu representation
- **Nested Menus:** Inline menu definitions within single file
- **Context-Aware:** Automatic context resolution for BusinessClass references

**MENU ITEM BEHAVIORS:**
- **Page Navigation:** Direct page access with optional panel specification
- **List Display:** BusinessClass list views with AsOf date support
- **Form Access:** BusinessClass forms with action customization
- **Action Execution:** Direct action invocation on BusinessClass or BusinessTask
- **Link Navigation:** UI links with optional BusinessClass context
- **Submenu Access:** Nested menu navigation
- **Image Map:** Interactive image-based navigation
- **WebApp Integration:** Internal webapp references for configuration

**CONTEXT RESOLUTION:**
Menu items with BusinessClass references automatically:
1. Look for linked agent of BusinessClass type with current actor
2. Fill primary keys with actor context variables and session.key variables
3. Find instance based on resolved keys

**FORM-SPECIFIC OPTIONS:**
- **Actor Agent Required:** Requires agent linkage for form access
- **Create Action:** Custom create action specification
- **Open Action:** Custom open action specification
- **Action Restrictions:** Enable/restrict specific actions on forms

=== PAGE DEFINITION SYNTAX ===

**PAGE STRUCTURE:**
```lpl
<PageName> is a SplashPage
	[title is <Message>]
	[allow anonymous access]
	[show panel control on left]

	[Context Form]
		Layout
			<FormLayout>

	<PanelName> is a Panel
		[title is <Message>]
		[mouse over text is <Message>]
		<MenuPanel>
		[show in column(1|2|3|4|5|6|7|8|9|10|11|12)]

<PageName> is a Page
	[title is <Message>]
	[allow anonymous access]
	[show panel control on left]
	[is report [for <WebAppName>[,<WebAppName>]]
		[category is <Message>]
	[orientation is (portrait | landscape)]
	[font offset is <Number>]

	[cart form is <BusinessClass>.<FormName>]

	[background is (<ImageName> | theme color)]
		[span header]
		[foreground is (dark | light)]

	[Context Form]
		[background is (<ImageName> | theme color)]
			[span header]
			[foreground is (dark | light)]
		Layout
			<FormLayout>

	<PanelName> is a Panel
		[title is <Message>]
		[mouse over text is <Message>]
		<PanelDefinition>

	<PanelName> is a DashBoardPanel
		[title is <Message>]
		[mouse over text is <Message>]
		[show (3 | 4) columns]
		[use 12 column grid]
		[background is (<ImageName> | theme color)]
		[print as dashboard]
			[compress columns]
		<PaneName> is a Panel
			[title is <Message>]
			[(double width | triple width | quad width)]
			[span (1|2|3|4|5|6|7|8|9|10|11|12) columns]
			[double height]
			[show in column (1|2|3|4|5|6|7|8|9|10|11|12)]
			<PanelDefinition>

	<PanelName> is a MultiPanePanel
		[title is <Message>]
		[mouse over text is <Message>]
		[vertical split is <Number>/<Number>]
		pane <PaneNumber>
			<PanelDefinition>

	<PanelName> is a MultiListPanel
		[title is <Message>]
		[mouse over text is <Message>]
		[(valid | visible) when <SimpleCondition>]
		<ListPanel>

	<PanelName> is a ColumnarPanel
		[title is <Message>]
		[mouse over text is <Message>]
		[left column]
			<PanelDefinition>
		main column
			<PanelDefinition>
		[right column]
			<PanelDefinition>
```

**PANEL DEFINITIONS:**
```lpl
PanelDefinition ::=
	[(valid | visible) when <SimpleCondition>]
	(<MenuPanel> | <ListPanel> | <SearchPanel> | <URLPanel>)

PaneNumber ::= (1 | 2 | 3 | 4)
WorkViewPaneNumber ::= (1 | 2 | 3)
```

**LIST PANEL:**
```lpl
ListPanel ::=
	business class is (<BusinessClass>[(<AsOfOperator> | .<RelatedLink>)] | pane<PaneNumber>.<RelatedLink> | <Agent>.<RelatedLink>)
		[visible when <SimpleCondition>]
		[panel text is <Message>]
		[show <#> lines]
		[list is (<ListName> | inline)]
			[title is <Message>]
			[display (list | <ChartName>)]
			[Row Dimensions]
				<DimensionField>
			[overview navigation is <NavigationName>]
				[label is <Message>]
			[<ListDefinition>]
		[helper list is <RelatedLink>.(<ListName> | primary)]
			[valid when <SimpleCondition>]
			[title is <Message>]
			[<Action>]
				[invoked.<FullFieldName> = <RelatedValue>]
		[Context]
			<FieldName>
		[Actions]
			(<CalledOutAction> | form is <RelatedLink>.<FormName> [<Label>])
```

**MENU PANEL:**
```lpl
MenuPanel ::=
	Layout
		[footer is <CardViewName>]
		<MenuLayout>

MenuLayout ::=
	(<FormText> | <MenuItem>
		[title is <Message>]
		[menu item name is <MenuItemName>]
		[description is <Message>]
		[(icon is <Icon> | image is <ImageName>)]
		[allow anonymous access]
	| <LayoutDirective>
	[<MenuLayout>])
```

**SEARCH PANEL:**
```lpl
SearchPanel ::=
	search form is <BusinessClass>.<FormName>
		[list is (<ListName> | inline)]
			[<ListDefinition>]
		[Context]
			<FieldName>
		[Actions]
			([action is] [<StateName>.]<ActionName> [<Label>] | form is <RelatedLink>.<FormName> [<Label>])
```

**URL PANEL:**
```lpl
URLPanel ::=
	url is [(<BusinessClass> | pane <PaneNumber>).]<HttpURL>
```

**WORK VIEW PANEL:**
```lpl
WorkViewPanel ::=
	(business class is (<BusinessClass>[.<RelatedLink>] | pane<PaneNumber>.<RelatedLink> | <Agent>.<RelatedLink>)
		[title is <Message>]
		[show <#> lines]
		[list is (<ListName> | inline)]
			[<ListDefinition>]
		[sort order is (<SetName> | primary)]
		[Context]
			<FieldName>
		[Instance Selection]
			where <Condition>
	| detail fields view of pane<PaneNumber>
	| link display view of pane<PaneNumber>)
```

**PAGE FEATURES:**
- **SplashPage vs Page:** SplashPage for simple layouts, Page for complex multi-panel layouts
- **Panel Types:** Menu, List, Search, URL, WorkView, DashBoard, MultiPane, MultiList, Columnar
- **Context Forms:** Shared context across all panels with FormLayout
- **Dashboard Layout:** 3-4 column grid with span controls and sizing options
- **Multi-Pane:** Up to 4 panes with configurable split ratios
- **Conditional Visibility:** Panel visibility based on SimpleCondition
- **Background Themes:** Image or theme color backgrounds with foreground control
- **Report Integration:** PDF generation with orientation and font offset
- **Cart Integration:** Shopping cart functionality with CompositeForm

**PANEL INTERACTIONS:**
- **Pane References:** Cross-pane data linking (pane1, pane2, etc.)
- **Helper Lists:** Additional lists relative to main pane
- **Context Sharing:** Ontological context fields shared across panels
- **Action Integration:** Form and action invocation from panels
- **Agent Integration:** Actor agent context resolution

**LAYOUT CONTROLS:**
- **Column Positioning:** 12-column grid system for precise layout
- **Panel Sizing:** Double/triple/quad width and double height options
- **Split Ratios:** Configurable vertical splits for multi-pane layouts
- **Line Limits:** Configurable display line counts for lists
- **Print Optimization:** Dashboard compression for print layouts

=== RULE BLOCK DEFINITION SYNTAX ===

**RULE BLOCKS STRUCTURE:**
```lpl
<RuleBlocks> is a RuleBlocks
	Rule Blocks
		<RuleBlockName>
			<Rule>
```

**RULE BLOCK FEATURES:**
- **Reusable Logic:** Named blocks of rules that can be included in multiple places
- **Parameter Replacement:** Support for replacement variables using curly braces {ParameterName}
- **Include Mechanism:** Rules copied in-line during compilation when 'include <RuleBlockName>' is used
- **Variable Substitution:** All replacement variables must be specified when including the Rule Block

**RULE BLOCK USAGE:**
```lpl
// In Rule Blocks file
ValidateAmount
	constraint (Amount > 0)
		"Amount must be greater than zero"
	constraint (Amount <= {MaxAmount})
		"Amount cannot exceed {MaxAmount}"

// In Business Class Action Rules
include ValidateAmount
	replace MaxAmount with 10000
```

**REPLACEMENT VARIABLES:**
- **Syntax:** {VariableName} within rule block definitions
- **Scope:** LPLConstructNames bounded by curly braces
- **Requirement:** All variables must be replaced when including the rule block
- **Usage:** 'replace VariableName with ActualValue' in include statement

**RULE BLOCK BENEFITS:**
- **Code Reuse:** Common validation and business logic shared across multiple entities
- **Consistency:** Standardized rule patterns across the application
- **Maintainability:** Single point of change for common business rules
- **Parameterization:** Flexible rule blocks with configurable values

=== SECURITY CLASS DEFINITION SYNTAX ===

**SECURITY CLASS STRUCTURE:**
```lpl
<SecurityClassName> is a SecurityClass
	[extends <SecurityClassName>]
	[description is <Message>]
	Access Rights
		<PolicyDefinition>
```

**POLICY DEFINITIONS:**
```lpl
PolicyDefinition ::= (<AccessPolicy> | <OntologicalPolicy>)

AccessPolicy ::=
	<SecurableObjectSpecification>
		<AccessRule>

OntologicalPolicy ::=
	<KeyField> KeyField
		<GrantRule>
```

**ACCESS RULES:**
```lpl
AccessRule ::=
	<Access> [in [past][,][current][,][future]]
	<SecurableActionSpecification>
	<Constraint>

Access ::= (is accessible [and attachable] | is (not | neither) accessible [nor attachable])

Constraint ::= (unconditionally | when <Condition>)
```

**GRANT RULES:**
```lpl
GrantRule ::=
	grants access [and attachability]
		<GrantedObjectSpecification>
		<SecurableActionSpecification>
		<Constraint>
```

**SECURABLE OBJECTS:**
```lpl
SecurableObjectSpecification ::= (<SecurableObjectName> <SecurableObjectType> | <SecurableObjectType> Type | <ContentSet> | <MenuItemSpecification>)

SecurableObjectType ::= (<LMObjectType> | <LMContainerType> | <LMContentType>)

LMObjectType ::= (BusinessClass | BusinessTask | Menu | MenuItem | WebApp)
LMContainerType ::= (DataArea | Module)
LMContentType ::= (Field | KeyField)

MenuItemSpecification ::= <MenuItemName> MenuItem for <MenuName> Menu
```

**ACTION SPECIFICATIONS:**
```lpl
SecurableActionSpecification ::=
	for <ActionList>
		[excluding <ActionList>]

ActionList ::= (<SecurableAction> | <ActionKeyword>)

SecurableAction ::= [<SecurableObjectName>.][<StateName>.]<ActionName>

ActionKeyword ::= (all actions | all audit views | all creates | all deletes | all inquiries | all functions | all updates | all global UI configuration | all security configuration | all personalization | limited list personalization | limited form personalization | all scheduled actions | all actor groups | data menu | future data indicator | UpdateEffectiveDatedData | ViewAuditLog | ViewFullAuditLog)
```

**GRANTED OBJECTS:**
```lpl
GrantedObjectSpecification ::=
	(to <GrantedObjectList> | all ontology [excluding <GrantedObjectList>])

GrantedObjectList ::= (<SecurableObjectName> <SecurableObjectType> | all business classes | all business tasks)
```

**CONTENT SETS:**
```lpl
ContentSet ::=
	All Fields for <LMObject>
		[excluding <FieldName [Field]>]

LMObject ::= <SecurableObjectName> <LMObjectType>
```

**SECURITY FEATURES:**
- **Inheritance:** Security classes can extend other security classes
- **Access Control:** Granular access control for objects and actions
- **Temporal Security:** Past, current, and future access control
- **Conditional Access:** Access rules based on conditions
- **Ontological Security:** KeyField-based security policies
- **Action-Level Security:** Specific action access control
- **Field-Level Security:** Individual field access control
- **Exclusion Lists:** Exclude specific objects or actions from broad grants

**ACCESS TYPES:**
- **Accessible:** Object can be accessed
- **Attachable:** Object can be attached to
- **Not Accessible:** Object access denied
- **Neither Accessible nor Attachable:** Complete access denial

**ACTION KEYWORDS:**
- **all actions:** All available actions
- **all creates:** All create operations (implies all inquiries)
- **all updates:** All update operations
- **all deletes:** All delete operations
- **all inquiries:** All read/inquiry operations
- **all functions:** All function executions
- **all audit views:** All audit log viewing
- **DataArea-specific:** UI configuration, personalization, scheduled actions

**TEMPORAL ACCESS:**
- **past:** Access to historical data
- **current:** Access to current data
- **future:** Access to future-dated data
- **Combined:** Multiple temporal scopes can be specified

**CONSTRAINT TYPES:**
- **unconditionally:** Always applies
- **when <Condition>:** Conditional access based on business logic

**SECURITY INHERITANCE:**
- Security classes can extend other security classes
- Inherited access rights are combined with local definitions
- More restrictive rules take precedence
- Description provides documentation for security class purpose

=== USER INTERFACE DEFINITION SYNTAX ===

**UI STRUCTURE:**
```lpl
(<BusinessClass> is a BusinessClass | <BusinessTask> | <FieldName> is a Field)
	[Drill Backs]
		[<DrillBackDefinition>]
	[Drill List]
		[(<DrillDefinition> | primary audit list | data translation list)]
	[<NavigationDefinition>]
	[<ListDefinition>]
	[<CardViewDefinition>]
	[<FormDefinition>]
	[<ActionFormDefinition>]
	[<CompositeFormDefinition>]
	[<MatrixFormDefinition>]
	[<SearchFormDefinition>]
	[<SummaryFormDefinition>]
```

**FORM DEFINITIONS:**
```lpl
FormDefinition ::=
	<FormName> is a Form
		[is primary [when <SimpleCondition>]]
		[is drill target [when <SimpleCondition>]]
		[propagate as a drill]
		[use for (<DisplayType> | action [<StateName>.]<ActionName>)]
		[title is <Message>]
		[suppress standard toolbar]
		[disable all actions]
		[called out actions only]
		[disable field options]
		[print form is <FormName>]
		[Actions]
			<CalledOutAction>
		[(restrict | enable) action [<StateName>.]<ActionName>]
			[when <Condition>]
		(Layout
			<FormLayout>
		| Manual Representation
			representation name is <Literal>
			Property Mapping
				<MessageProperty> = <RelatedValue>)
```

**FORM FIELDS:**
```lpl
FormField ::=
	(<RelatedField> | effective date | reason code | action comment)
		[(label is (<RelatedField> | <Message> | number) | no label)]
			[<TextStyle>]
		[mouse over text is <Message>]
		[suppress label] [<FieldStyle>]
		[align as label]
		[form is <FormName>]
		[indent]
		[display (only | as text)]
		[hidden entry]
		[allow update]
		[link is <UILink>]
		[compact format [(only | button of <Message>)]]
		[display as select]
		[select is [<RelatedLink>.]<ListName>]
		[default filter operator is (contains | starts with | equals)]
		[use text area [of <Literal> lines]]
		[show up to <Literal> characters]
		[keypad is (email | telephone | url)]
		[prompt for (image | video | audio | document)]
		[compare with <RelatedField>]
		[time zone is <RelatedField>]
		[limit to (5|10|15|20|30) minute increments]
		[display <Number> decimals]
		[currency symbol is <RelatedValue>]
			[first line and totals only]
		[show percent symbol]
			[first line and totals only]
		[display negative amount using (minus | parens)]
		[display as (hijri | gregorian) date]
		[display as [(portrait | photo | full)] image [up to <Literal> lines]]
			[missing image is (<ImageName> | random background)]
				[foreground text is <Message>]
			[image is <FullFieldName>]
			[title is <FullFieldName>]
		[display as switch]
		[display as tag]
			[color of <Color> [when <SimpleCondition>]]
		[display as rating]
		[display as slider]
			range is from <RelatedValue> to <RelatedValue>
			[step is <RelatedValue>]
			[<AlertType> alert range is from <RelatedValue> to <RelatedValue>]
				[mouse over text is <Message>]
				[link is <UILink>]
		[display as ((meter | thermometer) chart | progress bar) [up to <Literal> lines]]
			[meter range is <RelatedValue>]
			[<AlertType> alert range is from <RelatedValue> to <RelatedValue>]
				[mouse over text is <Message>]
				[link is <UILink>]
		[raise <AlertType> alert when <SimpleCondition>]
			[mouse over text is <Message>]
		[show as <StatusIcon> when <SimpleCondition>]
			[mouse over text is <Message>]
			[link is <UILink>]
		[display when blank]
		[display zero]
		[display blank when zero]
		[display as duration]
		[display as byte size]
		[display using <JavaFormat>]
		[display as [horizontal] radio buttons]
		[display (date | time | [date and] hours and minutes)]
		[display with time zone]
		[ignore daylight savings time]
		[<States>]
		[display as required [when <SimpleCondition>]]
		[hidden]
		[required]
		[initial value is <RelatedValue>]
		[constraint <Condition>]
			[<Message>]
		[depends on <RelatedField> [, <RelatedField>]]
			derived value is <RelatedValue>
		[when value changed]
			(validate (this field | <RelatedField>) | <RelatedField> = <RelatedValue> | refresh <RelatedField> | refresh dependent panels)
				[when <SimpleCondition>]
```

**LIST DEFINITIONS:**
```lpl
ListDefinition ::=
	<ListName> is (a List | a[n] <ListName> List | an AuditList)
		[is primary]
		[is drill target [for <FullFieldName>]]
		[propagate as a drill]
		[title is <Message>]
		[is report [for <WebAppName>[,<WebAppName>]]
			[category is <Message>]
		[show <#> lines]
		[show result set size]
		[default Alpha filter operator is (contains | starts with | equals)]
		[keyword search field is <RelatedField>]
			[label is <Message>]
			[(always | initially) display]
			[disable translation filtering]
		[(always | initially) display search]
		[(search form is (<FormName> | inline) | search field is <FullFieldName>)]
			[label is <Message>]
			[use as filter]
			[always display]
			[show search form on left]
			[disable translation filtering]
			[Layout]
				<FormLayout>
		[Required Search Parameters]
			<RelatedField>
				[initial value is <RelatedValue>]
		[implements LongRunningList]
		[implements InlineCreate]
		[allow form create]
		[copy mutable fields only]
		[implements FixedSizeList]
		[show <#> lines]
		[implements RepresentativeImageView]
		[implements AuditCompare]
			show changed values on right
		[implements GalleryView]
			card is <CardViewName>
				[allow horizontal paging]
		[implements TreeView]
			[show parent]
			[node icon is <RelatedField>]
			[max levels is <RelatedValue>]
			[show <RelatedValue> levels]
			[has children when <SimpleCondition>]
			[disable create within [when <SimpleCondition>]]
		[implements OrgChartView]
			card view is <CardViewName>
			[legend state is <RelatedField>]
			[has children when <SimpleCondition>]
			[disable create within [when <SimpleCondition>]]
		[implements ColumnarView]
			[union with <BusinessClass>]
			[show charts only]
		[implements CubeView]
			[suppress blank rows]
			[suppress current period]
			[period dimension is <DimensionField>]
			[show total node]
			[label is <Message>]
			[show <RelatedValue> levels]
			[Context]
				<FieldName>
			[Row Dimensions]
				<DimensionField>
					[caption is (representative text | <Message>)]
					[is fixed]
					[Periods]
						<PeriodOperator>
							[label is <Message>]
			[Pivot Views]
				<PivotViewName>
					[label is <Message>]
					[is default]
					Row Dimensions
						<DimensionField>
							[caption is (representative text | <Message>)]
							[is fixed]
							[Periods]
								<PeriodOperator>
									[label is <Message>]
			[Column Views]
				<ColumnViewName>
					[label is <Message>]
					[is default]
					Display Fields
						<ListDisplayField>
			[Period Views]
				<PeriodViewName>
					[label is <Message>]
					(all periods in (week | month | quarter | year) | Periods <PeriodOperator> [label is <Message>])
		[implements DashBoardView]
			[show (3 | 4) columns]
			[use 12 column grid]
			[print as dashboard]
				[compress columns]
		[implements HorizontalScrolling]
			[freeze first [<RelatedValue>] column[s]]
		[implements AttachmentList]
			attachment is <FullFieldName>
			[disable download]
			[create action is [<StateName>.]<ActionName>]
				[invoked.<FullFieldName> = <RelatedValue>]
		[auto refresh using <RelatedField>]
			[raise <AlertType> alert]
				[mouse over text is <Message>]
				[link is <UILink>]
		[Display Fields]
			(<ListDisplayField> | group label is <Message> <ListDisplayField>)
		[Summary Total Fields]
			<FormField>
		[Instance Selection]
			[include [only] deleted records]
			where <Condition>
		[Actions]
			<CalledOutAction>
		[Charts]
			[<ChartName> is a (BarChart | PieChart | LineChart | GapChart | CalendarChart | ScatterChart | AggregationTable | QuadrantChart)]
				[title is <Message>]
				[is default]
```

**UI FEATURES:**
- **Form Types:** Form, ActionForm, CompositeForm, WizardForm, MatrixForm, SearchForm, SummaryForm
- **List Types:** List, AuditList with multiple view implementations (TreeView, CubeView, GalleryView, etc.)
- **Card Views:** CardView and SectionedCardView for visual data presentation
- **Display Controls:** Rich field display options (slider, meter, rating, tag, switch, etc.)
- **Interactive Elements:** FormButton, CheckControl, CaptchaControl, MultiSelectField
- **Layout Management:** Column layouts, headers, sections, and responsive design
- **Chart Integration:** Multiple chart types (Bar, Pie, Line, Calendar, Scatter, etc.)
- **Navigation:** Drill-down capabilities, linkbacks, and context-aware navigation
- **Conditional Display:** Visibility and validation based on SimpleCondition
- **Responsive Design:** DisplayType support for different devices and screen sizes

**Relations (1 relation):**
- PurchaseOrderLineRel: one-to-one relation with complex field mapping
- Uses symbolic key with cross-entity field references
- Maps to parent PurchaseOrder through SanPurchaseOrderReceiptImport.PurchaseOrder

**Conditions (1 condition):**
- IsReleased: Status check through PurchaseOrderLineRel.Released

**Actions (5 actions):**
- BatchUpdatePurchaseOrderLine: Set Action with parameter validation
- UpdatePurchaseOrderLine: Instance Action with complex business logic
- Create, Update: Standard CRUD operations
- Delete: Purge Action

**Key Features:**
- Cross-entity field mapping in relations (parent.field references)
- Conditional field updates based on data comparison
- Error handling with resume on error patterns
- Quantity and UOM validation logic
- Cost update processing with conditional logic
- Parameter-driven Set Action processing

**Advanced Patterns:**
- Complex Field Mapping with parent entity references
- Conditional field assignment in Action Rules
- Resume on error with error message capture
- Multi-parameter Set Action with filtering
- Business rule validation before updates

=== SANPORECEIPTINVENTORYDETAILIMPORT ANALYSIS ===

**Business Class Structure:**
- Prefix: cfg
- Symbolic key: SanPOReceiptInventoryDetailImport
- Inventory detail import for purchase order receipts

**Field Analysis (5 Persistent Fields):**
- RunGroup (key field)
- Lot (Alpha size 50)
- Serial (Alpha size 50)
- Quantity (standard quantity field)
- LotExpirationdate (Alpha size 50)

**Field Rules:**
- Required fields: SanPurchaseOrderReceiptImport, Company, RunGroup
- Minimal validation structure for detail records

**Relations:**
- No explicit relations defined (inherits through parent entities)

**Conditions:**
- No conditions defined (simple detail entity)

**Actions (3 basic actions):**
- Create: Create Action
- Update: Update Action
- Delete: Purge Action

**Key Features:**
- Simple detail entity structure
- Lot and serial number tracking
- Expiration date management
- Basic CRUD operations only
- Minimal validation requirements

**Design Patterns:**
- Detail entity pattern (child of receipt line)
- Inventory tracking fields (lot, serial, expiration)
- Simple field structure for import processing
- Standard CRUD action pattern

**Statistics:**
- Total BusinessClass files: 4,761
- Files with Actions: 1,856 (39.0%)
- Files without Actions: 2,905 (61.0%)
- Total Actions found: 1,433
- Average actions per file (with actions): 0.8

**Action Types Distribution:**
- Instance Actions: 540 (37.7%) - Single entity operations
- Set Actions: 304 (21.2%) - Bulk operations on multiple records
- Delete Actions: 166 (11.6%) - Entity removal operations
- Update Actions: 157 (11.0%) - Entity modification operations
- Create Actions: 155 (10.8%) - Entity creation operations
- Purge Actions: 85 (5.9%) - Data cleanup and archival
- Generic Actions: 15 (1.0%) - Unspecified action types
- Import Actions: 6 (0.4%) - Data import operations
- AsyncActionRequest: 3 (0.2%) - Asynchronous processing
- IONConnectionAction: 2 (0.1%) - ION integration actions

**Action Characteristics:**
- Restricted Actions: 881 (61.5%) - Internal system operations
- Actions with Confirmation: 89 (6.2%) - Critical operations requiring user approval

**Most Complex Actions (by rule count):**
1. FSMBODConfiguration.EnableBODFlows: 831 rules - BOD flow configuration
2. ReportingChartAccount.CreateReconciliationAccounts: 512 rules - Account reconciliation
3. PurchaseOrderInterfaceInput.LoadInterfacedPurchaseOrderLines: 353 rules - PO interface processing
4. FSMBODConfiguration.EnableIntegration: 309 rules - Integration enablement
5. AuditLogEntry.ResetColumnarReplicationSetBC: 275 rules - Audit log management
6. CurrExchangeRate.TriggerCurrencyExchange: 271 rules - Currency exchange processing

=== SET ACTIONS WITH ASYNCHRONOUS EXECUTION ===

**Key Attributes for Async Set Actions:**
- **run in background** - Enables asynchronous execution
- **disable checkpoint** - Prevents automatic checkpointing for performance
- **checkpoint** - Manual checkpoint control within Instance Rules
- **resume on error** - Continues processing despite individual record errors
- **commit transaction** - Ensures data consistency per record

**Common Async Set Action Patterns:**

**1. Bulk Processing with Progress Tracking:**
```lpl
ProcessBatch is a Set Action
	restricted
	run in background
	Accumulators
		ProcessedCount
		ErrorCount
	Action Rules
		Instance Rules
			increment ProcessedCount
			invoke ProcessRecord
				resume on error
					increment ErrorCount
			commit transaction
			if (ProcessedCount mod 100 = 0)
				checkpoint
```

**2. Data Cleanup Operations:**
```lpl
CleanupExpiredRecords is a Set Action
	restricted
	run in background
	no records message is "No expired records found"
	Instance Selection
		where (ExpirationDate < PrmCutoffDate)
	Action Rules
		Instance Rules
			invoke Archive
				resume on error
			commit transaction
```

**3. Financial Period Close:**
```lpl
ClosePeriodTransactions is a Set Action
	restricted
	run in background
	confirmation required
		"This will close all transactions for the period. Continue?"
	Action Rules
		Set Rules
			Entrance Rules
				invoke Create PeriodCloseLog
			Exit Rules
				invoke Update PeriodCloseLogRel
		Instance Rules
			Status = Status.Closed
			commit transaction
```

**Best Practices for Async Set Actions:**
- Use Accumulators for progress tracking
- Implement manual checkpointing for large datasets
- Include error handling with resume on error
- Commit transactions per record for data consistency
- Use Set Rules for batch-level logging
- Include Empty Set Rules for no-data scenarios
- Add confirmation prompts for critical operations
- Implement email notifications for completion statusangeRateMasterNativeLPLBOD: 234 rules - Currency rate BOD
7. ReportingChartAccount.TriggerChartOfAccountsNativeLPLBOD: 219 rules - Chart of accounts BOD
8. FinanceDimension2-9.TriggerFinanceDimensionNativeLPLBOD: 218 rules - Financial dimension BODs
9. UnitOfMeasure.TriggerUnitOfMeasureNativeLPLBOD: 215 rules - UOM BOD processing
10. ReceiptAdjustmentInput.InterfaceAdjustmentsAndSubstitutions: 180 rules - Receipt adjustments

**Files with Most Actions:**
- 43 actions: 1 file (highest complexity)
- 39 actions: 1 file
- 34 actions: 1 file
- 28 actions: 4 files
- 25+ actions: Multiple files with extensive action frameworks

**Key Insights:**
- 39% of BusinessClass files implement Actions (1,856 files)
- Instance Actions dominate at 37.7% for entity-specific operations
- Set Actions at 21.2% enable efficient bulk processing
- 61.5% of actions are restricted for internal system use
- BOD integration actions show highest complexity (200+ rules)
- Financial and integration classes require most extensive action frameworks
- Most files have 1-5 actions, with complex entities having 20+ actions
- Confirmation requirements are selective (6.2%) for critical operations only

**Actions Usage Patterns Across All Files:**
- **Financial Systems:** Extensive BOD integration actions for external synchronization
- **Procurement:** Complex workflow actions for requisition and purchase order processing
- **Integration:** Native LPL BOD triggers for real-time data exchange
- **Data Management:** Purge and cleanup actions for system maintenance
- **User Interface:** Configuration actions for customizable user experiences
- **Audit & Compliance:** Specialized actions for regulatory and tracking requirements

Actions serve as the primary behavioral interface across all BusinessClass entities, enabling sophisticated enterprise operations through rule-based validation, parameter-driven flexibility, and extensive integration capabilities.

**ACTION TYPE USAGE GUIDELINES:**
- **Instance Actions:** Use for single-record operations, complex business logic, and entity-specific workflows
- **Set Actions:** Use for bulk operations, mass updates, and batch processing with filtering
- **Create Actions:** Use for entity creation with validation, defaults, and initialization logic
- **Update Actions:** Use for entity modification with change tracking and validation
- **Delete Actions:** Use for entity removal with referential integrity checks
- **Purge Actions:** Use for data cleanup, archival, and maintenance operations
- **Import Actions:** Use for data loading, file processing, and external data integration
- **AsyncActionRequest:** Use for long-running processes requiring background execution
- **IONConnectionAction:** Use for ION integration testing and connection management
- **BOD Integration:** Use for real-time synchronization with external systems
4. CloseTask (2,948 rules) - Period closing task validation
5. IIHItemLocation (2,673 rules) - Inventory item location management
6. ClosePeriodTask (2,667 rules) - Period closing validation
7. InvoiceLineFact (2,371 rules) - Invoice line fact validation
8. FSMAPInboundBODImport (2,363 rules) - Accounts payable BOD import
9. AsyncActionRequest (2,144 rules) - Asynchronous action processing
10. ContractImport (2,013 rules) - Contract import validation

**Constraint Type Distribution:**
- Required fields: 12,850 (41.9%) - Mandatory field validation
- Other constraints: 8,336 (27.2%) - Custom business logic
- Default values: 4,992 (16.3%) - Automatic value assignment
- Equality checks: 2,492 (8.1%) - Field value comparisons
- Existence checks: 1,936 (6.3%) - Data presence validation
- Pattern matching: 30 (0.1%) - Regular expression validation

**Error Message Patterns:**
- Static messages: 36,992 (85.7%) - Fixed error text
- Dynamic messages: 6,183 (14.3%) - Parameterized error text with field labels

**Field Rules Usage Patterns:**
- 80.4% of BusinessClass files use Field Rules for data validation
- Financial and integration classes show highest Field Rules complexity
- BOD import/export classes require extensive validation (3000+ rules)
- Period closing and task management classes have complex validation logic
- Invoice and payment processing classes require comprehensive field validation
- Most common validation: required field enforcement (41.9%)
- Default value assignment widely used for business logic (16.3%)
- Dynamic error messages provide user-friendly feedback with field context

**Field Rules vs Other Sections:**
- Field Rules: 80.4% of files (highest usage)
- Derived Fields: 37.3% of files
- Relations: 25.8% of files
- Sets: 21.9% of files
- Context Fields: 10.9% of files
- Field Rules are the most widely used validation mechanism in LPL BusinessClass files

**Key Insights:**
- Field Rules provide the primary data validation framework in LPL
- Complex business processes require extensive field validation (3000+ rules)
- Required field validation dominates at 41.9% of all constraints
- Integration and financial classes show highest validation complexity
- Dynamic error messages enhance user experience with contextual feedback
- Default value assignment automates business logic implementation
- 80.4% adoption rate indicates Field Rules are essential for data integrity

=== FIELD RULES SYNTAX SAMPLES ===

**BASIC FIELD RULES:**
```lpl
Field Rules
	FieldName
		required
		constraint (validation_logic)
		"ErrorMessage"
		default to "value"
```

**CONDITIONAL FIELD RULES:**
```lpl
Field Rules
	Account
	if (action type.Create)
		if (FinanceEnterpriseGroup.AccountRegularExpression entered)
			constraint (Account matches FinanceEnterpriseGroup.AccountRegularExpression)
			"InvalidFormatFor<FinanceEnterpriseGroup.AccountLabel>"
	
	ChartSection
		required
	
	AccountType
		required
		if (AccountType.Equity
		or  AccountType.Asset
		or  AccountType.Liability)
			constraint (ChartSection.BalanceSheet)
			"IncorrectAccountTypeForChartSection"
	
	TranslationCode
		if (ChartSection.BalanceSheet)
			default to "BS"
			constraint (TranslationCode != "IS")
			"CannotUseIncomeStatementTranslationCodeOnBalanceSheet<FinanceEnterpriseGroup.AccountLabel>"
		else
			default to "IS"
			constraint (!BalanceSheetTranslationCodes)
			"CannotUseBalanceSheetTranslationCodeOnIncomeStatement<FinanceEnterpriseGroup.AccountLabel>"
```

**COMPLEX VALIDATION RULES:**
```lpl
Field Rules
	SystemAccount
		LocalSystemAccount = SystemAccount
		constraint (!SingleSystemAccountsRel exists)
		"<SystemAccount>AlreadyExists"
	
		if (SystemAccount.TranslationGain
		or  SystemAccount.TranslationLoss)
			LocalSystemAccount = SystemAccount.TranslationGainAndLoss
			constraint (!SingleSystemAccountsRel exists)
			"<SystemAccount>AlreadyExists"
	
	AccountSubType
		constraint (AccountSubType.AccountType = AccountType)
		"<FinanceEnterpriseGroup.AccountLabel>TypeDoesNotMatch<FinanceEnterpriseGroup.AccountLabel>TypeOnSubType"
	
	ValidSubAccounts
		constraint (FinanceEnterpriseGroup.UseSubAccounts)
		"FinanceEnterpriseGroupDoesNotUseSubAccounts"
```

**FIELD RULES SYNTAX ELEMENTS:**

**1. CONSTRAINT TYPES:**
- `constraint (field matches pattern)` - Regular expression validation
- `constraint (field = value)` - Equality validation
- `constraint (field != value)` - Inequality validation
- `constraint (!relation exists)` - Existence validation
- `constraint (field.property)` - Property validation
- `required` - Mandatory field validation

**2. LOGICAL OPERATORS:**
- `or` - Logical OR operation
- `and` - Logical AND operation
- `!` - Logical NOT operation
- `=` - Equality comparison
- `!=` - Inequality comparison

**3. CONDITIONAL LOGIC:**
- `if (condition)` - Conditional validation
- `else` - Alternative validation
- `action type.Create` - Action-based conditions
- `field entered` - Field presence check

**4. DEFAULT VALUES:**
- `default to "value"` - Static default assignment
- `default to field.property` - Dynamic default from other fields

**5. ERROR MESSAGES:**
- `"StaticMessage"` - Fixed error text
- `"<FieldName>Message"` - Dynamic field name insertion
- `"<Field.Property>Message"` - Dynamic property insertion
- `"Message<Label>"` - Dynamic label insertion

**6. FIELD REFERENCES:**
- `FieldName.Property` - Field property access
- `RelatedEntity.Field` - Related entity field access
- `LocalFieldName = SourceField` - Local field assignment
- `RelationName exists` - Relationship existence check

**7. VALIDATION PATTERNS:**
- Chart section validation based on account types
- System account duplicate prevention
- Translation code consistency enforcement
- Regular expression pattern matching
- Cross-field validation and referential integrity
- Conditional requirements based on configuration settings
- Complex gain/loss account relationship validation

=== COMPREHENSIVE DERIVED FIELDS ANALYSIS (4,761 files) ===

**Statistics:**
- Total BusinessClass files: 4,761
- Files with Derived Fields: 1,776 (37.3%)
- Files without Derived Fields: 2,985 (62.7%)
- Total Derived Fields found: 31,055

**Field Type Distribution:**
- DerivedField: 15,633 fields (50.3%) - Complex business logic
- MessageField: 5,341 fields (17.2%) - User interface messages
- Create: 1,633 fields (5.3%) - Creation operations
- Set: 1,382 fields (4.5%) - Collection operations
- StringField: 1,375 fields (4.4%) - Display concatenation
- Delete: 1,250 fields (4.0%) - Deletion operations
- LabelField: 720 fields (2.3%) - UI labels
- ConditionalField: 568 fields (1.8%) - Conditional logic
- NativeField: 541 fields (1.7%) - Native operations
- Purge: 531 fields (1.7%) - Data purging
- ComputeField: 480 fields (1.5%) - Computed values

**Top 20 Complex Classes (Most Derived Fields):**
1. InventoryCompany (613 fields) - Inventory management
2. PayablesInvoicePayment (402 fields) - Invoice payment processing
3. PurchaseOrder (336 fields) - Purchase order management
4. IEFINPostUpgradeAction (314 fields) - System upgrade actions
5. CompanyCustomer (267 fields) - Customer management
6. CashLedgerPayablesPayment (249 fields) - Cash payment processing
7. FinanceEnterpriseGroup (236 fields) - Financial enterprise operations
8. SourcingEvent (214 fields) - Sourcing event management
9. Requester (199 fields) - Requisition requester management
10. Supplier (194 fields) - Supplier management
11. ClosePeriodTask (191 fields) - Period closing tasks
12. PayablesInvoiceDistribution (189 fields) - Invoice distribution
13. ContractLineError (185 fields) - Contract line error handling
14. ItemInformationError (185 fields) - Item information error handling
15. AsyncActionRequest (180 fields) - Asynchronous action processing
16. WarehouseShipment (177 fields) - Warehouse shipment operations
17. SupplierSourceId (171 fields) - Supplier identification
18. PurchaseOrderLine (168 fields) - Purchase order line processing
19. BankStatement (160 fields) - Bank statement processing
20. POReceiptAdjustmentAndInspectionLine (152 fields) - Receipt adjustments

**Key Insights:**
- 37.3% of BusinessClass files use Derived Fields for complex business logic
- DerivedField type dominates at 50.3% of all derived fields
- MessageField provides extensive UI feedback (17.2%)
- Operations fields (Create, Delete, Purge) handle data lifecycle (11.0%)
- Financial and procurement classes show highest complexity
- Error handling classes have extensive derived field support
- Inventory and payment processing require most derived logic

=== BUSINESS CLASS FOLDER ANALYSIS ===

**FOLDER STRUCTURE:**
- Location: C:\Visual Basic Code\LPL Library\References\business class
- Total Files: 6,693 .busclass files
- Comprehensive LPL BusinessClass library covering all Infor Landmark modules

**FILE DISTRIBUTION BY FIRST LETTER:**
- A: 963 files (Account, Asset, Allocation, Actor, etc.)
- B: 319 files (Budget, Bank, Business, etc.)
- C: 900 files (Customer, Cash, Contract, etc.)
- D: 134 files (Distribution, Document, etc.)
- E: 123 files (Employee, Equipment, etc.)
- F: 236 files (Finance, Fund, etc.)
- G: 377 files (GeneralLedger, GL, etc.)
- H: 23 files (HR, Health, etc.)
- I: 526 files (Invoice, Item, Inventory, etc.)
- J: 11 files (Journal, Job, etc.)
- K: 21 files (Key, etc.)
- L: 236 files (Labor, Location, etc.)
- M: 177 files (Master, Material, etc.)
- N: 25 files (Note, etc.)
- O: 272 files (Order, Organization, etc.)
- P: 940 files (Payables, Purchase, Project, etc.)
- Q: 6 files (Queue, etc.)
- R: 459 files (Receivables, Receipt, etc.)
- S: 364 files (System, Service, etc.)
- T: 184 files (Tax, Transaction, etc.)
- U: 66 files (User, etc.)
- V: 121 files (Vendor, etc.)
- W: 210 files (Work, Workflow, etc.)
- X, Y, Z: 0 files

**MAJOR MODULE CATEGORIES:**
1. **Financial Management (2,000+ files):**
   - General Ledger (Account, GeneralLedger*, GL*)
   - Accounts Payable (Payables*, AP*)
   - Accounts Receivable (Receivables*, AR*)
   - Cash Management (Cash*, Bank*)
   - Asset Management (Asset*)

2. **Supply Chain Management (1,500+ files):**
   - Purchasing (Purchase*, PO*)
   - Inventory Management (Inventory*, Item*)
   - Receiving (Receipt*, Receiving*)
   - Vendor Management (Vendor*)

3. **Project Management (500+ files):**
   - Project* (Project, ProjectContract, ProjectEmployee, etc.)
   - Labor Management (Labor*, Employee*)

4. **System Administration (800+ files):**
   - Process Flow Integration (Pfi*)
   - Security (Actor*, Role*, Security*)
   - Configuration (Configuration*, System*)

5. **Healthcare Specific (200+ files):**
   - Patient* (Patient, PatientCharge, etc.)
   - Provider* (Provider, etc.)
   - Medical procedures and billing

6. **Reporting and Analytics (300+ files):**
   - Report generation classes
   - Analytics* (Analytics, AnalyticsConsole, etc.)
   - Data processing workflows

**TRANSLATION FILES:**
- Many files have corresponding *_Translation.busclass files
- Support for multi-language implementations
- Separate translation management for international deployments

**WORK FILES:**
- Numerous temporary processing files (*Work*, *Sort*, *Temp*)
- Report generation intermediate files
- Batch processing support files

**SAMPLE BUSINESS CLASS STRUCTURE (Account.busclass):**
- 19 Persistent Fields with complex states and relationships
- 12 Transient Fields for UI and processing
- 11 Local Fields for internal operations
- 15+ Derived Fields with complex calculations
- 8 Conditions for business logic
- 12 Relations with various mapping strategies
- 1 Set (BySystemAccount) with sorting
- Comprehensive Field Rules with validation
- 10+ Actions including CRUD, requests, and BOD integration
- BOD (Business Object Document) integration for external systems
- Request/Approval workflow integration
- Complex financial business logic and constraints

**KEY PATTERNS OBSERVED:**
- Consistent naming conventions across modules
- Extensive use of States for enumerated values
- Complex relationship mappings between entities
- BOD integration for external system communication
- Workflow and approval process integration
- Multi-language support through translation files
- Comprehensive audit and security features
- Modular design with clear separation of concerns

**USAGE FOR LPL DEVELOPMENT:**
- Reference library for understanding existing business logic
- Template source for creating new business classes
- Relationship mapping examples for complex integrations
- Field definition patterns and validation examples
- Action implementation patterns for CRUD operations
- BOD integration examples for external system connectivity

=== PAYABLESINVOICE PURCHASEORDER RELATIONS ANALYSIS ===

**Existing PurchaseOrder Relations in PayablesInvoice BusinessClass:**

The PayablesInvoice business class already contains extensive relations to PurchaseOrder entities:

**Primary PurchaseOrder Relations:**
1. **MatchPurchaseOrderInvoicesRel** - one-to-many relation to MatchPurchaseOrderInvoice
2. **VendorPurchaseOrdersRel** - one-to-many relation to PurchaseOrder  
3. **LocalPurchaseOrderRel** - one-to-many relation to PurchaseOrder
4. **PurchaseOrderLineRel** - one-to-one relation to PurchaseOrderLine

**Purchase Order Line Relations:**
- PurchaseOrderLineSourceRel - one-to-many relation to PurchaseOrderLineSource
- PurchaseOrderLineInvoiceDetailRel - relation to PurchaseOrderLine
- PurchaseOrderLineAddOnChargeRel - one-to-many relation to PurchaseOrderAndLineAddOnCharge
- PurchaseOrderLinesToMatchRel - one-to-many relation to PurchaseOrderLine
- SCPurchaseOrderLineRel - one-to-many relation to PurchaseOrderLine

**Purchase Order Receipt Relations:**
- PurchaseOrderReceiptsRel - one-to-many relation to PurchaseOrderReceipt
- PurchaseOrderReceiptLineRel - one-to-many relation to PurchaseOrderReceiptLine
- PurchaseOrderReceiptInvoiceLinkRel - one-to-many relation to PurchaseOrderReceiptInvoiceLink

**Key Transient Fields:**
- FirstPurchaseOrder - derives from first MatchPurchaseOrderInvoicesRel.PurchaseOrder
- FirstPurchaseOrderFromDetail - derives from first PayablesInvoiceDetailRel.PurchaseOrder

**Important Notes:**
- PayablesInvoice uses MatchPurchaseOrderInvoicesRel as the primary relation for linking invoices to purchase orders
- The business class supports multiple purchase orders per invoice through various relation types
- Extensive support for purchase order matching, receipts, and add-on charges
- Relations use both symbolic key and custom field mappings depending on the specific relationship type

**Recommendation:** 
When creating new relations to PurchaseOrder from PayablesInvoice, consider the existing relation patterns and ensure compatibility with the current matching and processing logic.

=== EMPTY SET RULES ===

**Purpose:**
- Execute logic when Instance Selection criteria returns no matching records
- Handle edge cases where bulk operations find nothing to process
- Provide alternative processing when expected data set is empty

**Common Use Cases:**
- Create default records when none exist
- Set configuration parameters and system settings
- Log messages about missing data conditions
- Initialize processing states
- Update tracking fields for empty processing runs

**Syntax Pattern:**
```lpl
ActionName is a Set Action
	Instance Selection
		where (FilterConditions)
	Action Rules
		Instance Rules
			processing for each matching instance
		Empty Set Rules
			invoke Create DefaultEntity
				invoked.Field = DefaultValue
			invoke Update ConfigurationEntity
				invoked.LastProcessDate = system current date
			LocalMessage = "No records found for processing"
```

**Real-World Example:**
```lpl
SetAnalyticsConsoleParameter is a Set Action
	no records message is "Creating_\Records"
	Instance Selection
		where (false)
	Action Rules
		Empty Set Rules
			if (NotificationsEmailAddress entered)
				if (!AnalyticsConfigParaNotificationsEmailAddressRel exists)
					invoke Create
						invoked.AnalyticsConsoleConfigurations = "NotificationsEmailAddress"
						invoked.PropertyType = 8222
						invoked.Value = NotificationsEmailAddress
				else
					invoke Update AnalyticsConfigParaNotificationsEmailAddressRel
						invoked.Value = NotificationsEmailAddress
```

**Key Characteristics:**
- Only executes when Instance Selection finds zero matching records
- Provides graceful handling of "no data found" scenarios
- Ensures consistent system behavior with empty datasets
- Can create, update, or log when no processing instances exist
- Often used with configuration and parameter management actions

**Execution Flow:**
1. Instance Selection evaluates filter criteria
2. If records found: Instance Rules execute for each record
3. If no records found: Empty Set Rules execute once
4. Set Rules (Entrance/Exit) execute regardless of record count

**Best Practices:**
- Use for configuration initialization when no existing records
- Log processing attempts even when no data found
- Create default entities when business rules require them
- Update tracking fields to record empty processing runs
- Avoid complex logic - keep Empty Set Rules simple and focused

**Performance Considerations:**
- Empty Set Rules execute only once per action invocation
- More efficient than checking for empty sets in Instance Rules
- Reduces unnecessary processing when no data exists
- Provides clean separation between data processing and default handling

**Integration with Other Action Components:**
- **Set Rules:** Entrance/Exit Rules execute regardless of Empty Set Rules
- **Instance Rules:** Mutually exclusive with Empty Set Rules execution
- **Parameters:** Empty Set Rules can access all action parameters
- **Accumulators:** Can be updated within Empty Set Rules
- **Local Fields:** Available for temporary storage and processing

**Error Handling in Empty Set Rules:**
- Support "resume on error" patterns
- Can invoke other actions with error handling
- Error messages and status tracking available
- Transaction management applies to Empty Set Rules

**Business Logic Examples:**
- **Configuration Setup:** Create missing configuration records
- **Default Data:** Initialize required master data when missing
- **Audit Logging:** Record when no data was processed
- **Status Updates:** Update processing timestamps even for empty runs
- **Notification Systems:** Alert when expected data is missing

**Supplier Workflow Action with Email:**
```lpl
SubmitForSupplier is an Instance Action
	valid when (CanSubmitForSupplier)
	default label is "Submit"
	Action Rules
		constraint (RequisitionLinesOpenRel exists)
			"MustHaveAtLeastOneLineItemToSubmit"
		if (HasLinesWithNoLotOrSerialSupplier)
			confirmation required 
				"ComponentLinesExistThatHaveNoLotOrSerialNumberEntered;DoYouWantToContinue?"
		if (ForCapitatedProcedure)
			if (HasNoProcedures)
				confirmation required 
					"CapitatedRequisitionHasNoProcedures;DoYouWantToContinue?"
		if (SupplierSourceIdRel.AutoApprove = true
		and RequesterEntered)
			SupplierCreated = 3
		else
			SupplierCreated = 2
		if (Requester entered)
			send email
				to RequesterEmailAddress
				from SupplierSourceIdByActorRel.EmailAddress
				subject "SupplierRequisition<Requisition>HasBeenSubmitted"
				Contents
					"SupplierRequisition<Requisition>HasBeenSubmitted;ViewInSupplierRequisitions"
```

**Background Processing Action:**
```lpl
SupplierUpdate is an Update Action
	default label is "Update"
	valid when (CanUpdateForSupplier)
	Action Rules
		include DefaultDropShipInfo
		DefaultProcedureInformation.DefaultRequester			= Requester.FirstLastName
		DefaultProcedureInformation.DefaultSalesRepresentative = SupplierSourceIdRel.MainContact.FirstAndLastName
	Exit Rules
		if (TransientCopyAllLines)
			if (instance count of ProcurementTemplate.ValidProcurementTemplateLinesRel > 50)
				make transition to CreateInProgress
				RequisitionStatusValue = RequisitionStatusValue.CreateInProgress
				invoke CreateRequisitionLineFromTemplateLineSet ProcurementTemplateLine in background
					invoked.PrmProcurementGroup			= ProcurementTemplate.ProcurementGroup
					invoked.PrmProcurementTemplate		= ProcurementTemplate
					invoked.PrmInventoryCompany			= Company
					invoked.PrmRequisition				= Requisition
					invoked.PrmCopyAllLines 			= TransientCopyAllLines
			else
				invoke CreateRequisitionLineFromTemplateLineSet ProcurementTemplateLine in foreground
					invoked.PrmProcurementGroup			= ProcurementTemplate.ProcurementGroup
					invoked.PrmProcurementTemplate		= ProcurementTemplate
					invoked.PrmInventoryCompany			= Company
					invoked.PrmRequisition				= Requisition
					invoked.PrmCopyAllLines 			= TransientCopyAllLines
```

**Budget Integration Action:**
```lpl
RebuildCommitmentTotals is an Instance Action
	restricted
	Action Rules
		invoke Purge  GLCommitDrillRel
			invoked.PrmPurgeRecalculate = true
		invoke Delete HeaderBudgetEditErrorRel
		invoke Delete DistributionBudgetEditErrorRel
		invoke Delete BudgetTemplateGroupTotalRel
		for each RequisitionLineDistributionRel
			invoke CreateCommitmentOnly each
				invoked.FromBudgetRebuild = true
		invoke EditTotalsRoute BudgetTemplateGroupTotal
			invoked.PrmFinanceEnterpriseGroup    							= Company.ItemGroup.FinanceEnterpriseGroup
			invoked.PrmBudgetEditGroup           							= UniqueID
			invoked.PrmBudgetEditCallBack.BudgetEditCallBackRequisition.InventoryCompany 	= Company
			invoked.PrmBudgetEditCallBack.BudgetEditCallBackRequisition.Requisition 		= Requisition
			invoked.PrmBusinessClassName                                                    = "Requisition"
			invoked.PrmEditContext                                                          = "Release"
			if (TransientFromMassRQCreateAndRelease
			or  BudgetEditBatchRel exists)
				invoked.PrmIsBatch                                                          = true
```

**Complex Release Action with Validation:**
```lpl
Release is an Instance Action
	completion message is "<ReleaseMessage>"
	valid when (IsForRelease)
	Local Fields
		LocalTotalAmountPerContract			is an UnsignedInternationalAmount
		LocalTotalAmountPerContractLine		is an UnsignedInternationalAmount
		LocalTotalQuantityPerContractLine	is a Quantity
		LocalTotalQuantityPerLocation		is a Quantity
		LocalItem							is an Item
		LocalFromCompany					is a Company
		LocalItemLocation					is an InventoryLocation
		TransactionError					is Boolean
		TransactionErrorMessage				is Alpha 300
		FESFundingSourceTable
		FESCounter							is Numeric 4
	Action Rules
		constraint (RequisitionLinesUnreleasedRel exists)
			"NoRequisitionLinesAreAvailableToBeReleased"
		constraint (RequestingLocation.Active)
			"RequestingLocationIsInactive"
		if (RequestingLocation.ProcessLevel entered)
			constraint (RequestingLocation.ProcessLevel.Active)
				"ProcessLevel<RequestingLocation.ProcessLevel>IsInactive"
		if (ForCapitatedProcedure)
			if (HasLinesWithDuplicateSerial)
				confirmation required 
					"DuplicateSerialNumbersExistForLine<first LinesWithDuplicateSerialRel.RequisitionLine>;DoYouWantToContinue?"
		constraint (FromCompanyLocation.FromLocation.IsActive)
			"DeliverFromLocationIsInactive"
		constraint (Status.Unreleased
		or 			Status.InProcess)
			"RequisitionHasAlreadyBeenReleased"
		constraint (Requester entered)
			"MustEnterARequesterBeforeReleasingTheRequisition"
```

=== PROCESS FLOW INITIATION SYNTAX ===

**Correct Syntax for Process Flow Variables:**
```lpl
initiate ProcessFlowServiceName process
	Variables
		VariableName1 = Value1
		VariableName2 = Value2
		VariableName3 = Value3
```

**SET ACTION WITH PROCESS FLOW EXAMPLE:**
```lpl
InitiateProcessFlow is a Set Action
	restricted
	no records message is "No_Records_Found_Initiating_Process_Flow"
	Parameters
		PrmProcessGroup		is Numeric size 4
		PrmProcessType		is Alpha size 10
	Instance Selection
		where (ProcessGroup = PrmProcessGroup
		and   ProcessType = PrmProcessType
		and   ProcessStatus = ProcessStatus.NotStarted)
	Action Rules
		Instance Rules
			ProcessStatus = ProcessStatus.InProgress
			initiate StandardProcessFlow process
				Variables
					ProcessGroup = ProcessGroup
					ProcessType = ProcessType
					InitiatedBy = actor
			commit transaction
		Empty Set Rules
			display "No_Records_Found_Initiating_Alternative_Process"
			initiate EmptySetProcessFlow process
				Variables
					ProcessGroup = PrmProcessGroup
					ProcessType = PrmProcessType
					InitiatedBy = actor
					Reason = "NoRecordsFound"
```

**Key Points:**
- Use 'Variables' block to pass parameters to process flows
- Empty Set Rules execute when no records match Instance Selection
- Process flows can be initiated for both normal processing and exception handling
- Variables are passed by name-value pairs within the Variables block
=== ACKNOWLEDGEMENT ACTION ANALYSIS ===

**Business Logic:**
- Manual acknowledgement processing for purchase orders
- Supports two acknowledgement types: Accepted (MT) and AcknowledgedWithDetailChange (MC)
- Updates purchase order revision records and generates line-level acknowledgements
- Validates dates against purchase order date constraints

**Key Action Attributes:**
- `disable multiple instance selection` - Restricts action to single record processing
- `valid when (AllowManualAcknowledgement)` - Conditional availability based on business rule
- Parameters with States for enumerated values
- Required parameter validation with custom error messages

**Parameter Patterns:**
```lpl
Parameters
	PrmAcknowledgementType		is Alpha size 2
		default label is "AcknowledgementType"
		States
			Accepted						value is "MT"
			AcknowledgedWithDetailChange	value is "MC"
	PrmAcknowledgementDate		is Date
		default label is "AcknowledgementDate"
	PrmAcknowledgementMessage	is Alpha size 100
		default label is "AcknowledgementMessage"
```

**Parameter Rules with Validation:**
```lpl
Parameter Rules
	PrmAcknowledgementType
		initial value is PrmAcknowledgementType.Accepted
		default to PrmAcknowledgementType.Accepted
	
	PrmAcknowledgementDate
		initial value is current corporate date
		default to current corporate date
		constraint (PrmAcknowledgementDate >= PurchaseOrderDate)
			"AcknowledgementDateCannotBeLessThanPurchaseOrderDate"
	
	PrmAcknowledgementMessage
		required
			"AcknowledgementMessageIsRequired"
```

**Action Processing Pattern:**
```lpl
Action Rules
	invoke Update first NonEDIPurchaseOrderRevisionsRel 
		invoked.AcknowledgementDate 	= PrmAcknowledgementDate
		invoked.TransmissionMessage		= PrmAcknowledgementMessage
		
	for each PurchaseOrderLine set
		invoke GenerateLineAcknowledgements each
			invoked.PrmAcknowledgementType = PrmAcknowledgementType
			invoked.PrmAcknowledgementPOShipDate = PrmAcknowledgementPOShipDate
```

**Key LPL Patterns Observed:**
- Parameter States for enumerated values with meaningful codes
- Date validation with business rule constraints
- Header-line processing pattern (update header, process each line)
- Use of 'first' keyword for single record selection from relation
- Parameter passing to child action invocations
- Corporate date functions for business date handling
- Custom error messages for constraint violations
=== BATCH PROCESSING SET ACTION ANALYSIS ===

**Business Logic:**
- Mass purchase order issuance with batch processing capabilities
- Supports multiple issue methods (Paper, Fax, EDI, Email, XML)
- IDM batch management with configurable limits
- Error handling and reporting for failed operations
- Background processing for large batches

**Key Set Action Patterns:**

**Complex Parameter Structure:**
```lpl
Parameters
    PrmCompany          is a PurchasingCompany
    PrmIssueDraft       is Boolean
    PrmShipToLocation   is an InventoryLocation
    PrmVendorClass      is a VendorClass
    PrmVendor           is a Vendor
    PrmPurchaseOrder1   is a PurchaseOrder  // Multiple PO parameters
    PrmPurchaseOrder2   is a PurchaseOrder  // for specific selection
    // ... up to PrmPurchaseOrder8
    PrmPaperIssue       is Boolean
    PrmFaxIssue         is Boolean
    PrmEDIIssue         is Boolean
    PrmEmailIssue       is Boolean
    PrmXMLIssue         is Boolean
    PrmCommentCode1     is a StandardCommentCode  // Multiple comment codes
    // ... up to PrmCommentCode8
```

**Complex Instance Selection with OR Logic:**
```lpl
Instance Selection
    where   (Company = PrmCompany
    and     (PrmShipToLocation not entered or ShipToLocation = PrmShipToLocation)
    and     (PrmVendor not entered or Vendor = PrmVendor)
    and    ((PrmPurchaseOrder1 not entered and PrmPurchaseOrder2 not entered
             and PrmPurchaseOrder3 not entered and PrmPurchaseOrder4 not entered
             and IsToBePrinted)
    or     ((PrmPurchaseOrder1 entered and PurchaseOrder = PrmPurchaseOrder1)
    or      (PrmPurchaseOrder2 entered and PurchaseOrder = PrmPurchaseOrder2)
    or      (PrmPurchaseOrder3 entered and PurchaseOrder = PrmPurchaseOrder3)))
    and    ((PrmPaperIssue and IssueMethod.Paper)
    or      (PrmFaxIssue and IssueMethod.Fax)
    or      (PrmEDIIssue and IssueMethod.EDI))
    and     (PurchaseOrderLifeCycleState.Unreleased or PurchaseOrderLifeCycleState.Released)
    and     (not ApprovalStatus.NeedsApproval))
```

**Batch Management with IDM:**
```lpl
Set Rules
    Entrance Rules
        LocalBatchID = current timestamp
        if (PrmCompany.UseIDM)
            LocalUseIDM = true
            BatchIDCounter = 1
            LocalBatchIDArray.IDMPID[BatchIDCounter] = LocalBatchID
            if (config.PURCHASEORDER_IDMBATCHID_LIMIT > 0)
                LocalIDMBatchIDLimit = config.PURCHASEORDER_IDMBATCHID_LIMIT
            else 
                LocalIDMBatchIDLimit = 50
```

**Instance Processing with Error Handling:**
```lpl
Instance Rules
    if (LocalUseIDM)
        POCounter += 1
        if (POCounter > LocalIDMBatchIDLimit)
            LocalBatchID = current timestamp
            BatchIDCounter += 1
            LocalBatchIDArray.IDMPID[BatchIDCounter] = LocalBatchID
            POCounter = 1
    
    if (PrmIssueDraft)
        invoke IssueDraftBatch
            resume on error
                LocalErrorMessage = error message
                LocalHasError = true
            invoked.PrmIDMBatchID = LocalBatchID
    
    if (LocalHasError)
        LocalErrorCounter += 1
        invoke Create PurchaseOrderResultHeading
            invoked.ErrorMessage = LocalErrorMessage
```

**Background Processing Coordination:**
```lpl
Exit Rules
    if (LocalUseIDM)
        for each LocalBatchIDArray.IDMPID
            if (each entered) 
                invoke GetStatusByBatchID IDMJob in background group (LocalAsyncBackgroundGroup)
                    invoked.PrmIDMBatchID = each
                
                if (not PrmIssueDraft)
                    invoke IssueFinalCompletionSet in background
                        run after background group (LocalAsyncBackgroundGroup)
                        invoked.PrmIDMBatchID = each
```

**Key LPL Patterns Observed:**
- **Multiple Parameter Arrays** - PrmPurchaseOrder1-8, PrmCommentCode1-8
- **Complex OR Logic** - Flexible filtering with optional parameters
- **Batch Size Management** - Dynamic batch creation based on limits
- **Error Accumulation** - LocalErrorCounter for batch error reporting
- **Background Group Coordination** - Sequential background processing
- **Configuration-Driven Limits** - config.PURCHASEORDER_IDMBATCHID_LIMIT
- **Timestamp-Based Batch IDs** - current timestamp for unique identification
- **Resume on Error** - Graceful error handling with continued processing
- **Accumulators** - POCounter, BatchIDCounter for batch management
=== BATCH PROCESSING SET ACTION SYNTAX EXAMPLES ===

**Complex Set Action with Batch Management:**
```lpl
IssueFromBatch is a Set Action
	restricted
	Local Fields
		LocalBatchID 						is an IDMPID
		LocalSetMassIssue					is Boolean
		LocalErrorMessage					is Alpha 150
		LocalHasError						is Boolean
		LocalErrorCounter					is Numeric 9
		SavedPurchaseOrderResultResultView  is a PurchaseOrderResult view
		LocalBegin                          is Boolean
		LocalBatchIDArray                   is an IDMUniqueIDOccurs
		LocalIDMBatchIDLimit				is Numeric 4
		LocalUseIDM						    is Boolean
		LocalPurchaseOrderRange 		    is like PurchaseOrderRange
	
	Parameters
		PrmCompany          is a PurchasingCompany
		PrmIssueDraft       is Boolean
		PrmShipToLocation   is an InventoryLocation
		PrmVendor           is a Vendor
		PrmPurchaseOrder1   is a PurchaseOrder
		PrmPurchaseOrder2   is a PurchaseOrder
		PrmPurchaseOrder3   is a PurchaseOrder
		PrmPaperIssue       is Boolean
		PrmFaxIssue         is Boolean
		PrmEDIIssue         is Boolean
		PrmCommentCode1     is a StandardCommentCode 
		PrmCommentCode2     is a StandardCommentCode
	
	Parameter Rules
		PrmCompany
			required
	
	Instance Selection
		where   (Company = PrmCompany
		and     (PrmShipToLocation not entered or ShipToLocation = PrmShipToLocation)
		and     (PrmVendor not entered or Vendor = PrmVendor)
		and    ((PrmPurchaseOrder1 not entered
		and 	 PrmPurchaseOrder2 not entered
		and 	 PrmPurchaseOrder3 not entered
		and		 IsToBePrinted)
		or	   ((PrmPurchaseOrder1 entered and PurchaseOrder = PrmPurchaseOrder1)
		or		(PrmPurchaseOrder2 entered and PurchaseOrder = PrmPurchaseOrder2)
		or		(PrmPurchaseOrder3 entered and PurchaseOrder = PrmPurchaseOrder3)))
		and    ((PrmPaperIssue and IssueMethod.Paper)
		or      (PrmFaxIssue and IssueMethod.Fax)
		or      (PrmEDIIssue and IssueMethod.EDI))
		and		(PurchaseOrderLifeCycleState.Unreleased
		or		PurchaseOrderLifeCycleState.Released)
		and		(not ApprovalStatus.NeedsApproval))
	
	Accumulators
		POCounter
		BatchIDCounter
	
	Action Rules
		Set Rules
			Entrance Rules
				LocalBatchID = current timestamp
				if (PrmCompany.UseIDM)
					LocalUseIDM = true
					BatchIDCounter = 1
					LocalBatchIDArray.IDMPID[BatchIDCounter] = LocalBatchID
					LocalBegin = true
					if (config.PURCHASEORDER_IDMBATCHID_LIMIT > 0)
						LocalIDMBatchIDLimit = config.PURCHASEORDER_IDMBATCHID_LIMIT
					else 
						LocalIDMBatchIDLimit = 50
				
				invoke Create PurchaseOrderResult
					assign result to SavedPurchaseOrderResultResultView
					invoked.FinanceEnterpriseGroup	= PrmCompany.FinanceEnterpriseGroup
					invoked.ReportType				= PurchaseOrderResult.ReportType.MassPOIssueResult
					invoked.PrintTimeStamp			= current timestamp
					invoked.Status					= PurchaseOrderResult.Status.Processing
			
			Exit Rules
				if (LocalUseIDM)
					for each LocalBatchIDArray.IDMPID
						LocalAsyncBackgroundGroup = "IDMJobGetStatusByBatch_" + each
						if (each entered) 
							invoke GetStatusByBatchID IDMJob in background group (LocalAsyncBackgroundGroup)
								invoked.PrmActor   	  = actor
								invoked.PrmIDMBatchID = each
							
							if (not PrmIssueDraft)
								invoke IssueFinalCompletionSet in background
									run after background group (LocalAsyncBackgroundGroup)
									invoked.PrmCompany            = PrmCompany
									invoked.PrmPurchaseOrderRange = LocalPurchaseOrderRange
									invoked.PrmActor   	          = actor
									invoked.PrmIDMBatchID         = each
				
				if (LocalErrorCounter > 0)
					invoke SendPOMassIssueErrorNotification last PurchasingMassPOIssueErrorReportRel.PurchaseOrderResult in background
						invoked.PrmRecordsWithError = LocalErrorCounter
				else
					invoke TransitionToCompleted SavedPurchaseOrderResultResultView.PurchaseOrderResult
		
		Instance Rules
			initialize LocalHasError
			initialize LocalErrorMessage
			
			if (LocalUseIDM)
				POCounter += 1
				if (POCounter > LocalIDMBatchIDLimit)
					LocalBatchID = current timestamp
					BatchIDCounter += 1
					LocalBatchIDArray.IDMPID[BatchIDCounter] = LocalBatchID
					POCounter = 1
				
				if (LocalBegin)
					LocalPurchaseOrderRange.Begin = PurchaseOrder
					LocalBegin = false
				
				LocalPurchaseOrderRange.End = PurchaseOrder
			
			if (PrmCommentCode1 entered)
				StandardCommentCode = PrmCommentCode1
				include CreateCommentFromCommentCode
			if (PrmCommentCode2 entered)
				StandardCommentCode = PrmCommentCode2
				include CreateCommentFromCommentCode
			
			if (PrmIssueDraft)
				invoke IssueDraftBatch
					resume on error
						LocalErrorMessage = error message
						LocalHasError = true
					invoked.PrmIDMBatchID = LocalBatchID
			else
				TransientMassIssue = LocalSetMassIssue
				if (ValidForIssueFinal)
					invoke Released.IssueFinalBatch
						resume on error
							LocalErrorMessage = error message
							LocalHasError = true
						invoked.PrmIDMBatchID = LocalBatchID
			
			if (LocalHasError)
				LocalErrorCounter += 1
				invoke Create PurchaseOrderResultHeading
					invoked.FinanceEnterpriseGroup	= PrmCompany.FinanceEnterpriseGroup
					invoked.PurchaseOrderResult		= SavedPurchaseOrderResultResultView.PurchaseOrderResult
					invoked.PurchasingCompany		= PrmCompany
					invoked.PurchaseOrder			= PurchaseOrder
					invoked.ErrorMessage			= LocalErrorMessage
```

**Key Syntax Patterns:**
- **Complex OR Logic in Instance Selection** - Multiple parameter combinations
- **Accumulators** - POCounter, BatchIDCounter for batch tracking
- **Array Fields** - LocalBatchIDArray.IDMPID[BatchIDCounter] for batch management
- **Background Groups** - Coordinated asynchronous processing
- **Resume on Error** - Graceful error handling with continued processing
- **Configuration Access** - config.PURCHASEORDER_IDMBATCHID_LIMIT
- **Current Timestamp** - Unique batch ID generation
- **View Assignment** - assign result to SavedPurchaseOrderResultResultView
=== SINGLE INSTANCE PROCESSING SYNTAX ===

**Instance Action with Single Record Enforcement:**
```lpl
AcknowledgeManually is an Instance Action
	disable multiple instance selection
	valid when (AllowManualAcknowledgement)
	Parameters
		PrmAcknowledgementType		is Alpha size 2
			default label is "AcknowledgementType"
			States
				Accepted						value is "MT"
				AcknowledgedWithDetailChange	value is "MC"
		PrmAcknowledgementDate		is Date
			default label is "AcknowledgementDate"
		PrmAcknowledgementPOShipDate	is Date
			default label is "PO Ship Date"
		PrmAcknowledgementMessage	is Alpha size 100
			default label is "AcknowledgementMessage"
	Parameter Rules
		PrmAcknowledgementType
			initial value is PrmAcknowledgementType.Accepted
			default to PrmAcknowledgementType.Accepted
		
		PrmAcknowledgementDate
			initial value is current corporate date
			default to current corporate date
			constraint (PrmAcknowledgementDate >= PurchaseOrderDate)
				"AcknowledgementDateCannotBeLessThanPurchaseOrderDate"
		
		PrmAcknowledgementPOShipDate
			constraint (PrmAcknowledgementPOShipDate >= PurchaseOrderDate)
				"ShipDateCannotBeLessThanPurchaseOrderDate"
		
		PrmAcknowledgementMessage
			required
				"AcknowledgementMessageIsRequired"
	Action Rules
		invoke Update first NonEDIPurchaseOrderRevisionsRel 
			invoked.AcknowledgementDate 	= PrmAcknowledgementDate
			invoked.TransmissionMessage		= PrmAcknowledgementMessage
			
		for each PurchaseOrderLine set
			invoke GenerateLineAcknowledgements each
				invoked.PrmAcknowledgementType = PrmAcknowledgementType
				invoked.PrmAcknowledgementPOShipDate = PrmAcknowledgementPOShipDate
```

**Key Single Instance Patterns:**
- **`disable multiple instance selection`** - Forces action to work on single record only
- **`valid when (Condition)`** - Conditional action availability
- **Parameter States** - Enumerated values with meaningful codes
- **Parameter Validation** - Date constraints and required fields
- **Header-Line Processing** - Update header first, then process each line
- **Corporate Date Functions** - `current corporate date` for business dates
- **First Keyword** - `first NonEDIPurchaseOrderRevisionsRel` for single record selection

**Use Cases for Single Instance Processing:**
- Manual acknowledgement workflows requiring individual attention
- Critical operations needing one-by-one validation
- Actions with complex parameter collection requiring user input
- Operations that modify multiple related records per instance
- Workflows requiring audit trail for each individual action
=== STATE ENTRANCE RULES ANALYSIS ===

**Business Logic:**
- Purchase Order release state transition with complex approval routing
- Multiple approval types: ApprovalRequired, MatrixLineDistribution
- Budget and encumbrance processing for GL integration
- Invoice matching and obligation recalculation

**State Entrance Rules Pattern:**
```lpl
Released is a State
	Entrance Rules
		if  (PurchaseOrderApprovalType.ApprovalRequired
		and  Closed not changed
		and  not LocalCancelRemainingPurchaseOrder)
			ApprovalStatus = ApprovalStatus.NeedsApproval
			initiate PurchaseOrderApproval process
				title is "ApprovalRequest.PurchaseOrder<PurchaseOrder>|Vendor:<Vendor.VendorName>|Total:<CalculateTotalAmount>_<Currency>"
				Variables
					Company
					PurchaseOrder
				URLs
					"<linkback(webapp is Approver navigation is PFIViewPO text is \"ViewPurchaseOrder\")>"
		else
		if (PurchaseOrderApprovalType.MatrixLineDistribution
		and !FromStanding
		and !FromRequisitions)
			ApprovalStatus = ApprovalStatus.NeedsApproval
			for each PurchaseOrderLineLineDistributionsRel
				invoke UpdateFast each
					invoked.DistributionAggregation = blank
			if (PODistributionAggregationRel exists)
				invoke Purge PODistributionAggregationRel
			for each PurchaseOrderLineLineDistributionsRel
				invoke CalculateDistributionAggregation each
			for each PODistributionAggregationRel 
				invoke SubmitForApproval each
		
		if (GeneralLedgerSystemCodeRel.EncumbranceOption.TrackAndEdit
		or  GeneralLedgerSystemCodeRel.EncumbranceOption.Track)
			LocalExecute = false 
			for each PurchaseOrderLineRel
				if (each.PreviouslyReleased)
					LocalExecute = true 
					end for each 
			
			if (LocalExecute) 
				for each UnmatchedMatchPurchaseOrderInvoicesRel 
					for each each.PayablesInvoice.BudgetTemplateGroupTotalRel 
						invoke Delete each 
					
					invoke Delete each.PayablesInvoice.HeaderBudgetEditErrorRel
					invoke Delete each.PayablesInvoice.DistributionBudgetEditErrorRel
					
					for each each.PayablesInvoice.PayablesInvoiceDetailRel 
						if (!each.ItemType.Inventoried)
							invoke RecalculateUnreleasedObligations each
					
					for each each.PayablesInvoice.DistributionTypeIsDistributionRel 
						if (!each.IsNonLandedTaxDistribution)
							invoke RecreateBudgetTemplateGroupTotals each.GLCommitRel 
							invoke PerformBudgetEdit each
								invoked.PrmActionType = "C"
```

**Key State Entrance Patterns:**
- **Conditional Approval Routing** - Different approval types trigger different workflows
- **Process Flow Integration** - `initiate PurchaseOrderApproval process` with dynamic title
- **Dynamic URLs** - `linkback` syntax for approval workflow navigation
- **Matrix Approval Processing** - Distribution aggregation and line-level approvals
- **Budget Integration** - GL encumbrance tracking and budget editing
- **Nested Iteration** - Multiple levels of `for each` for complex data processing
- **Conditional Execution** - `LocalExecute` flag to control processing flow

**Process Flow Initiation with Dynamic Content:**
```lpl
initiate PurchaseOrderApproval process
	title is "ApprovalRequest.PurchaseOrder<PurchaseOrder>|Vendor:<Vendor.VendorName>|Total:<CalculateTotalAmount>_<Currency>"
	Variables
		Company
		PurchaseOrder
	URLs
		"<linkback(webapp is Approver navigation is PFIViewPO text is \"ViewPurchaseOrder\")>"
```

**Complex Nested Processing:**
```lpl
for each UnmatchedMatchPurchaseOrderInvoicesRel 
	for each each.PayablesInvoice.BudgetTemplateGroupTotalRel 
		invoke Delete each 
	
	for each each.PayablesInvoice.PayablesInvoiceDetailRel 
		if (!each.ItemType.Inventoried)
			invoke RecalculateUnreleasedObligations each
```

**Key LPL Patterns Observed:**
- **State Entrance Rules** - Execute logic when transitioning into a state
- **Conditional Approval Logic** - Multiple approval types with different processing
- **Dynamic Process Titles** - Template-based titles with field substitution
- **Linkback URLs** - Navigation links for approval workflows
- **Nested Relation Processing** - Deep traversal of related entities
- **Budget and GL Integration** - Encumbrance tracking and obligation management
- **Early Loop Exit** - `end for each` to break out of loops conditionally
=== STATE ENTRANCE RULES DETAILED ANALYSIS ===

**Business Process Flow:**
1. **Approval Routing Decision** - Determines approval type and initiates appropriate workflow
2. **Matrix Distribution Processing** - Aggregates line distributions for matrix approval
3. **Budget Integration** - Handles GL encumbrance and budget editing for previously released lines

**Key Syntax Patterns:**

**State Definition with Entrance Rules:**
```lpl
Released is a State
	Entrance Rules
		// Complex conditional logic executed when entering Released state
```

**Conditional Approval Initiation:**
```lpl
if  (PurchaseOrderApprovalType.ApprovalRequired
and  Closed not changed
and  not LocalCancelRemainingPurchaseOrder)
	ApprovalStatus = ApprovalStatus.NeedsApproval
	initiate PurchaseOrderApproval process
		title is "ApprovalRequest.PurchaseOrder<PurchaseOrder>|Vendor:<Vendor.VendorName>|Total:<CalculateTotalAmount>_<Currency>"
		Variables
			Company
			PurchaseOrder
		URLs
			"<linkback(webapp is Approver navigation is PFIViewPO text is \"ViewPurchaseOrder\")>"
```

**Matrix Approval Processing:**
```lpl
if (PurchaseOrderApprovalType.MatrixLineDistribution
and !FromStanding
and !FromRequisitions)
	ApprovalStatus = ApprovalStatus.NeedsApproval
	for each PurchaseOrderLineLineDistributionsRel
		invoke UpdateFast each
			invoked.DistributionAggregation = blank
	if (PODistributionAggregationRel exists)
		invoke Purge PODistributionAggregationRel
	for each PurchaseOrderLineLineDistributionsRel
		invoke CalculateDistributionAggregation each
	for each PODistributionAggregationRel 
		invoke SubmitForApproval each
```

**Budget Integration with Early Exit:**
```lpl
if (GeneralLedgerSystemCodeRel.EncumbranceOption.TrackAndEdit
or  GeneralLedgerSystemCodeRel.EncumbranceOption.Track)
	LocalExecute = false 
	for each PurchaseOrderLineRel
		if (each.PreviouslyReleased)
			LocalExecute = true 
			end for each 
	
	if (LocalExecute) 
		for each UnmatchedMatchPurchaseOrderInvoicesRel 
			for each each.PayablesInvoice.BudgetTemplateGroupTotalRel 
				invoke Delete each 
			
			invoke Delete each.PayablesInvoice.HeaderBudgetEditErrorRel
			invoke Delete each.PayablesInvoice.DistributionBudgetEditErrorRel
			
			for each each.PayablesInvoice.PayablesInvoiceDetailRel 
				if (!each.ItemType.Inventoried)
					invoke RecalculateUnreleasedObligations each
			
			for each each.PayablesInvoice.DistributionTypeIsDistributionRel 
				if (!each.IsNonLandedTaxDistribution)
					invoke RecreateBudgetTemplateGroupTotals each.GLCommitRel 
					invoke PerformBudgetEdit each
						invoked.PrmActionType = "C"
```

**Advanced LPL Syntax Elements:**

1. **Field Change Detection:** `Closed not changed` - Checks if field was modified
2. **Negation Operators:** `!FromStanding`, `!each.ItemType.Inventoried` - Boolean negation
3. **Early Loop Exit:** `end for each` - Breaks out of loop when condition met
4. **Deep Relation Navigation:** `each.PayablesInvoice.BudgetTemplateGroupTotalRel` - Multi-level traversal
5. **Dynamic Process Titles:** Template substitution with `<FieldName>` syntax
6. **Linkback URLs:** Navigation integration for approval workflows
7. **Conditional Execution Flags:** `LocalExecute` pattern for performance optimization

**Business Logic Patterns:**
- **Approval Type Routing** - Different approval workflows based on configuration
- **Matrix Aggregation** - Line-level distribution processing for complex approvals
- **Budget Cleanup and Rebuild** - GL integration with encumbrance management
- **Performance Optimization** - Early exit patterns to avoid unnecessary processing
- **Deep Data Processing** - Multi-level nested iterations through related entities

**Key Technical Features:**
- State Entrance Rules execute automatically on state transition
- Process flow initiation with rich metadata (title, variables, URLs)
- Complex conditional logic with multiple approval paths
- Sophisticated budget and GL integration patterns
- Performance-optimized processing with conditional execution
=== USEFUL LPL SYNTAX PATTERNS ===

**Field Change Detection:**
```lpl
if (FieldName changed)
    // Execute when field was modified
if (FieldName not changed)
    // Execute when field was not modified
```

**Early Loop Exit:**
```lpl
for each RelationName
    if (condition)
        LocalFlag = true
        end for each    // Exits loop immediately
```

**Deep Relation Navigation:**
```lpl
each.ParentEntity.ChildEntity.GrandChildEntity
related.Level1.Level2.Level3.FieldName
first RelationName.SubRelation.FieldName
```

**Negation Operators:**
```lpl
if (!BooleanField)              // Not true
if (not BooleanCondition)       // Not condition
if (FieldName !entered)         // Not entered
if (FieldName not entered)      // Not entered (alternative)
```

**Existence Checks:**
```lpl
if (RelationName exists)        // Relation has records
if (RelationName not exists)    // Relation has no records
if (RelationName !exists)       // Relation has no records (alternative)
```

**Process Flow Initiation with Metadata:**
```lpl
initiate ProcessFlowName process
    title is "Dynamic Title <FieldName> | Status: <StatusField>"
    Variables
        FieldName1
        FieldName2 = Value
    URLs
        "<linkback(webapp is AppName navigation is NavName text is \"LinkText\")>"
    Criteria
        CriteriaField1
        CriteriaField2 = Value
```

**State Definitions:**
```lpl
StateName is a State
    Entrance Rules
        // Execute when entering this state
    Exit Rules  
        // Execute when leaving this state
```

**Conditional Assignments:**
```lpl
if (condition1)
    FieldName = Value1
else
if (condition2) 
    FieldName = Value2
else
    FieldName = DefaultValue
```

**Record Selection Keywords:**
```lpl
first RelationName              // First record
last RelationName               // Last record
any RelationName                // Any record (typically first)
```

**Current Functions:**
```lpl
current date                    // Current system date
current corporate date          // Current business date
current timestamp               // Current timestamp
current time                    // Current time
system current timestamp        // System timestamp
```

**Configuration Access:**
```lpl
config.PARAMETER_NAME           // System configuration parameter
actor                          // Current user/actor
actor.context.FieldName        // Actor context information
```

**Error Handling:**
```lpl
resume on error
    ErrorField = error message
    ErrorFlag = true

constraint (condition)
    "ErrorMessage"
```

**Background Processing:**
```lpl
invoke ActionName in background
invoke ActionName in background group (GroupName)
run after background group (GroupName)
run after AsyncId
```

**Array and Occurrence Handling:**
```lpl
ArrayField.SubField[Index]      // Array element access
for each ArrayField.SubField    // Iterate array elements
instance count of RelationName  // Count records
```

**Field Initialization:**
```lpl
initialize FieldName            // Set to blank/zero
initialize LocalVariable       // Clear local field
force default FieldName to Value  // Override default
```

**Transaction Control:**
```lpl
commit transaction              // Commit current transaction
end set action instance loop    // Exit set action processing
```

**Invoke Patterns:**
```lpl
invoke ActionName EntityName
    assign result to LocalVariable
    fill in fields from SourceEntity
        except invoked.ExcludedField
    invoked.FieldName = Value
    resume on error
        ErrorHandling
```

**Include Patterns:**
```lpl
include RuleBlockName
    replace ParameterName with ActualValue
```

**Display and Logging:**
```lpl
display "Message with <FieldName> substitution"
log "LogMessage with <FieldName>"
log untranslatable:"English only message"
```

**Make Transition:**
```lpl
make transition to StateName    // Force state transition
```

**Constraint Validation:**
```lpl
constraint (ValidationCondition)
    "ErrorMessage with <FieldName> substitution"
```

**Confirmation Prompts:**
```lpl
confirmation required
    "ConfirmationMessage with <FieldName>"
```

**Email Integration:**
```lpl
send email
    to EmailAddress
    from SenderAddress  
    subject "Subject with <FieldName>"
    Contents
        "Email body with <FieldName> substitution"
        "Additional line"
```

**BOD Integration:**
```lpl
send ion bod
    bod is BODXmlField
    bod type is "Sync.EntityName"
```

**Reference Assignments:**
```lpl
FieldName = reference to this instance
FieldName = reference to EntityName
```
=== STATE ENTRANCE RULES EXAMPLE ===

**Complete State with Complex Business Logic:**
```lpl
Released is a State
	Entrance Rules
		if  (PurchaseOrderApprovalType.ApprovalRequired
		and  Closed not changed
		and  not LocalCancelRemainingPurchaseOrder)
			ApprovalStatus = ApprovalStatus.NeedsApproval
			initiate PurchaseOrderApproval process
				title is "ApprovalRequest.PurchaseOrder<PurchaseOrder>|Vendor:<Vendor.VendorName>|Total:<CalculateTotalAmount>_<Currency>"
				Variables
					Company
					PurchaseOrder
				URLs
					"<linkback(webapp is Approver navigation is PFIViewPO text is \"ViewPurchaseOrder\")>"
		else
		if (PurchaseOrderApprovalType.MatrixLineDistribution
		and !FromStanding
		and !FromRequisitions)
			ApprovalStatus = ApprovalStatus.NeedsApproval
			for each PurchaseOrderLineLineDistributionsRel
				invoke UpdateFast each
					invoked.DistributionAggregation = blank
			if (PODistributionAggregationRel exists)
				invoke Purge PODistributionAggregationRel
			for each PurchaseOrderLineLineDistributionsRel
				invoke CalculateDistributionAggregation each
			for each PODistributionAggregationRel 
				invoke SubmitForApproval each

		if (GeneralLedgerSystemCodeRel.EncumbranceOption.TrackAndEdit
		or  GeneralLedgerSystemCodeRel.EncumbranceOption.Track)
			LocalExecute = false 
			for each PurchaseOrderLineRel
				if (each.PreviouslyReleased)
					LocalExecute = true 
					end for each 

			if (LocalExecute) 
				for each UnmatchedMatchPurchaseOrderInvoicesRel 
					for each each.PayablesInvoice.BudgetTemplateGroupTotalRel 
						invoke Delete each 

					invoke Delete each.PayablesInvoice.HeaderBudgetEditErrorRel
					invoke Delete each.PayablesInvoice.DistributionBudgetEditErrorRel

					for each each.PayablesInvoice.PayablesInvoiceDetailRel 
						if (!each.ItemType.Inventoried)
							invoke RecalculateUnreleasedObligations each

					for each each.PayablesInvoice.DistributionTypeIsDistributionRel 
						if (!each.IsNonLandedTaxDistribution)
							invoke RecreateBudgetTemplateGroupTotals each.GLCommitRel 
							invoke PerformBudgetEdit each
								invoked.PrmActionType = "C"
```

**This example demonstrates:**
- **State Entrance Rules** - Complex logic executed when entering Released state
- **Conditional Approval Routing** - Different workflows based on approval type
- **Process Flow Initiation** - Rich metadata with dynamic titles and URLs
- **Matrix Distribution Processing** - Line-level aggregation for complex approvals
- **Budget Integration** - GL encumbrance and budget editing
- **Performance Optimization** - Early exit with `end for each`
- **Deep Relation Navigation** - Multi-level entity traversal
- **Field Change Detection** - `Closed not changed` syntax
- **Negation Operators** - `!FromStanding`, `!each.ItemType.Inventoried`
- **Nested Processing** - Multiple levels of `for each` loops
=== SIMPLE SET ACTION ANALYSIS ===

**SanRefreshAdmissionNumber Analysis:**
```lpl
SanRefreshAdmissionNumber is a Set Action
    Instance Selection
        where (AdmissionNumber != RelationshipStatus)
    Action Rules
        Instance Rules
            AdmissionNumber = RelationshipStatus
```

**Business Logic:**
- Data synchronization/refresh operation
- Identifies records where AdmissionNumber field doesn't match RelationshipStatus field
- Updates AdmissionNumber to match RelationshipStatus value

**Key Patterns Demonstrated:**
- **Simple Set Action** - Minimal structure with only essential components
- **Inequality Filter** - Uses `!=` operator to find mismatched records
- **Field Synchronization** - Direct field assignment for data alignment
- **Bulk Update Pattern** - Processes multiple records efficiently

**Use Cases for This Pattern:**
- Data cleanup operations
- Field synchronization after system changes
- Batch corrections for data inconsistencies
- Migration or conversion utilities
- Maintenance operations for data integrity

**Minimal Set Action Structure:**
```lpl
ActionName is a Set Action
    Instance Selection
        where (FilterCondition)
    Action Rules
        Instance Rules
            FieldAssignments
```

**Common Variations:**
```lpl
// Simple field copy
Instance Rules
    TargetField = SourceField

// Conditional assignment
Instance Rules
    if (Condition)
        TargetField = Value1
    else
        TargetField = Value2

// Multiple field updates
Instance Rules
    Field1 = Value1
    Field2 = Value2
    Field3 = current date
```

**Performance Considerations:**
- No Entrance/Exit Rules - minimal overhead
- Direct field assignment - efficient processing
- Simple filter condition - fast record selection
- No complex logic - optimal for bulk operations