Business Class Definition 
// Business Class files have an extension of .busclass  
 
Business Class Structure :: = 
 
<BusinessClass> is a Business Class 
	[deprecated]  
	[owned by <ModuleName>] // If not defined, this defaults to the module it is under  
	[<ClassicPrefix>]  // Requ ired for use in Cobol prog rams 
	[<SqlName>] 
	[<RpgName>] 
	[<ClassicName>] 
	[<DefaultLabel>] 
	[framework type is  (ConfigParam  
						| LPLConfiguration  
						| ProcessFlow  
						| ReplicationSet  
						| Security)] 
	[untranslatable]  // prevents any text or data from being trans lated 
	[subject is <Subject>] // default subject for all actio ns 
	[stored in [base] environment] // Store data in the environment database, IJ F framework only  
	[stored in product line] // Store data in the environment product line database (vs standard data area DB)  
	[store using <ClassName>] // Clas sName that i mplements  persistence, IJF framework only  
	[contains environment data] // Environment data is not copied in daexport, IJF framework only  
	[disable data area copy] // Prevent data from bein g copied in daexport, IJF framework only  
		[preserve target data] // default is to delete  target data 
	[representative text is <Message>]// Text that is the human readable form of the key to this business class (replaces Display Fields) 
	[representative image is (<RelatedValue> | <Icon>)] // Image that represents an instance of this  business class  
		[display as (portrait | photo | full) image] // default is ‘display as portrait’  
		[missing image is (<ImageName> | random background)] 
			[foreground text is <Message>] 
	[(restrict | enable) actions on lists]   // default is ‘enable’ 
	[default Alpha filter operator is (contains | starts with | equals)] // default is ‘contains’  
	
	Suppress Warnings  
	Ontology  
	Patterns  
	DataSource Mapping  
	Persistent Fields  
	Transient Fields 
	Dimensions  
	Measures  
	Cube Links 
	Context Fields  
	Field Groups 
	Audit Index Fields  
	Local Fields  
	Derived Fields  
	Conditions  
	Text Search Fields  
	Cube Relations  
	Columnar Relations  
	Relations  
	Form Invokes 
	Matrix Forms  
	Sets 
	Field Rules  
	SubType <RelatedCondition> Field Rules  
	Commit Rules 
	Audit Entry Rules  
	Create Rules 
	Create Exit Rules  
	Update Action Rules  
	Delete Rules 
	Attach Rules 
	Parent Attach Rules 
	Dynamic Creation Rules  
	Rule Blocks  
	StateCycles  
	Actions


Suppress Warnings  
	(set size  on <SetName> 
	| all set size warnings  
	)… 
	
	
Ontology  
	symbolic key is <KeyField>  // can  have multiple symbolic keys; t hese are synonyms  
		[name is <FieldName>]  // ove rrides the name of the sy mbolic KeyF ield on this class 
		[classic set name is <Literal>] // sets the classic name for the primary set that is ge nerated 
		[sql set na me is <Literal>]  // sets the sql nam e for the primary set that is generated  
		[not indexed]    // do not create a physical index for the symbolic k ey 
		[<SqlName>] 
		[<ClassicName>] 
		[<ClassicNameForField>] 
		[<SqlNameForField>] 
		[protected]  // application -controlled field;  cannot be updated from the UI, webser vices, or spreadsheet  
		[name for  <context FieldName> is <FieldName>] 
		// <ContextField> must be  a context field within <KeyField>. The context fields within a  KeyField  
		// automatically get put on the business class. The default name is the  highest level typ e name of th e 
		// context field. If APCompany is the c ontext field and APCompany extends Company, the name is Company. 
		// This phrase allows the field name  to be explicitly defined . 
		[type for <context  FieldNam e> is a[n] <KeyFie ld>] 
		// This ove rrides the type of the Context Field . The new  type must be a subtype of the original type, ADCompany 
		// ver sus Company. This ‘symbol ically key s’ the  business class. A bus iness cla ss can be keyed both symboli cally 
		// and relatively. A  business class that is not symbolically keyed  is considered to be ‘relatively’ keyed.  
		// When a KeyField is defined to be the s ymbolic key to a business class, the Onto logy Context variables 
		// are replicated  on the business c lass. When a KeyField is simpl y used on a busine ss cla ss, the Ontology 
		// Context variables must be resolved within the context of the business class or a com pile error occurs. The  
		// excep tions to this are those Ontology Cont ext variab les that are desig nated as optional. 
	part of <BusinessClass> 
		[connect via UniqueID [only]] 
		// BusinessClass must NOT implement the LazyUniqu eID pattern to use connect via UniqueID 
		[delete (cascades // default 
				| restricted 
				| ignored  
				) 
		] 
		relative key is <FieldName> [<DataDefinition>] 
			[<States>] 
			[<SqlName>] 
			[classic set name is <Literal>] // sets the classic name fo r the primary set that is generated 
			[sql set name is <Literal>] // sets the sql name for the primary  set that is generated  
			[not indexed]  // do not create a physical index for the sy mbol ic key 
			[<ClassicName>] 
			[<ClassicNameForField>] 
			[<SqlNameForField>] 
			[<DefaultLabel>] 
			[protected] // applicat ion-controlled fie ld; cannot be updated from the  UI, webservices, or spr eadsheet 
			[(delete cascades | delet e ignored)]  
			[[exact] version is (<RelatedValue> | latest)]  
			// This directive specifies the particular ver sion of a vers ioned ke y field to  retriev e. 
			// If the v ersion field on the k ey field is of type Date,  TimeStamp , or Time this will default to the current date,  
			// current timestamp , or current time  otherwise  it will default to the latest version.  
			// If there is no exact match on th e version it will return the  closest version  before the version specified.  
			// If ‘exact version is’ is specified there must be an exact match on the version. 
			// If ‘latest’ version is specifie d, it will find the last versio n even if that is a future v ersion. 
			[data area is <RelatedValue>] // valid only wh en in a ‘stored in environment’ busclass  
			[name for <context  FieldName> is <FieldName>] 
			// <Cont extField> must be a field in the context field chain of <BusinessCla ss>. The context field chain of 
			// <BusinessClass> automatically gets put on this business class. The default name is the highest level type n ame of the  
			// context field. I f APCompany is  the context f ield and APCompany extends Company, the name is Company.  
			// This phrase allows the f ield name to be explicitly defined. 
			[type for  <context FieldName> is a[n] <KeyField>] 
			// This  overrides the typ e of the Context Field . See above definition with symbolic key for full description  
			[text searchable] 
			// Only one relative key is  allowed. This keys the business class relative to another business class.  
			// The ‘re lative key’ construct will automatically  put the <BusinessClass> Sy mbolicKey  
			// field,  includ ing its Ontological Context fie lds, on this business class unless connect vi a UniqueID only 
			// is specified. It also automatically puts a one- to-one or one- to-many relation on <Busine ssClass> pointing back 
			// to this busin ess c lass. It names that r elatio n ‘<this business class>SetRel’. I f <BusinessClass> is itself 
			// relatively  keyed, a one- to-one required relation will be put on this business class. It names that relation  
			// ‘<Business Class>Rel’.  
			// The ‘parts’ of <Busi nessC lass> can be accessed from <BusinessClass> by specifying ‘ <this business class> set’ in  
			// a <RelatedL ink>  
			// The <BusinessClass> can be accessed from <this business class> by specifying ‘<BusinessClass>’ in a 
			// <RelatedLink> 


Patterns  
	[disable Auditing]  // By default non -’Class ic’ Business Classe s implement the Auditing pattern  
	// BinaryDocuments and BinaryObjects do not participate in this pattern 
	
	[implements LightweightAuditing] // Initial cre ate does not c reate the log; it is insta ntiated on the first update or delete 
	
	[disable AuditIndex]  // By default an AuditIndex (the ‘snapshot’ table) is creat ed when a Busine ssClass is Audited and  
	// AsOf DateProcessing is not disabled. The AuditIndex optimizes as of date queries at the expense of 
	//  crea tes and updates. 
	
	
	[implements EffectiveDated] 
		[bypass integrity rules] 
	
	[disable EffectiveDated]  // By default non- ‘Classic’ Busin ess Classes implement the EffectiveDated pattern 
	// Also by default BinaryDocument and BinaryObject  fields do not par ticipate in this pattern . They can 
	// be made to participate  in this pattern by specifying ‘enable EffectiveD ated’ on the fi eld definition  
	
	[implements AuditLogEntryActions]  // force AuditLogEntry record create for  actions (overri des co nfig param) 
	
	[implements OnceUsedNeverDelete] 
	
	[implements DeleteFlag]  // Valid only for business classes  that specify “store u sing” 
	
	[disable RetroactiveEffectiveDating]  
	
	[disable UniqueID] 
	
	[disable AsOfDateProcessing] 
	
	[disable DataTranslations]  // This  disables all data translation  for this business class.  
	
	[disable StaticTranslations] // All <Message> de finitions will not par ticipate in Translation pr ocesses 
	// There will b e no <BusinessC lass>Bundle.properties file for  the BL or the  UI in the reso urce language 
	// packs. Co nvers tion of <Liter alMessage> to re source string will still take place  
	
	[implements HistoryCorrection] // Allows past audit log ent ries to be adjusted  
	
	[implements FutureCorrection] // Allows future entries to  be adjus ted 
	
	[implements ForceUIRefreshOnStale] 
	
	[implements IncrementalReplication] // if no indicator field is specified the n must have a change s tamp me aning 
		[indicator field  is <FullFieldName>]… //    that it must be  audi ted or implemen ts UpdateStamp  
			replicate when  <Value> 
				then (set to <Value> | invoke <ActionName> [<FullStateName>]) 
				// CRITICAL NO TE - If the  indicator field  is included in an index, and the indicator field value is changed on a record during a 
				//  replication, it is possible to pick up the record twice due to the notion of laying tracks .  
				// There are ways to mitigate this . 
	
	[disable IncrementalReplication] // disables IncrementalRepli cation if implemen ted at the Produc t Line le vel 
	
	[implements InlineUserFields] // Puts user field values dir ectly on the busin ess cla ss in a VarChar fie ld 
		size is <Number>  // Must def ine h ow big the field is that contains all the user field valu es 
	// Field wil l contain  user field name plus actual value 
	
	[implements StaticJava]  // This pattern generates a StaticJava DB interface c lass 
		[has attachments] // Generates <BusClass>_URL and <BusClass_Comment tables  
	
	[implements InMemoryCache]  // This p attern stores and retrieve s business class instances from an in -memory cache. 
	// The cache is valid only w ithin a process and records can only be retrieved through the KeyField. 
	
	[implements WorkFile]  // This causes the business class to b e treated as a WorkFile  
	
	[implements ForeignTable]  // This pattern by default implements the ReadOnly pattern and the Lazy Uniq ueId pattern 
		[allow updates] 
	
	[implements ReadOnly]  // The ReadOnly pattern can be inhibited by spe cifying ‘allow updates’  
	
	[implements LazyUniqueID]  // All bu siness cla sses automatically get a UniqueId put o n them to support the a bility to address any  
	// LPL based business class  direc tly through a UniqueId. If the busi ness class is not created through 
	// the IJF runtime but is rather an 8.1 or third party database ta ble then it needs to implement 
	// this patter n. This pattern  will generate an outboard file and the appropriate  logic  in the business 
	// class to allo w the IJF runt ime to access th e outboard table via a UniqueId.  
	
	[implements S3ClassicTable] // This pattern by default implements the Rea dOnl y patter n and the LazyU niqueId pattern  
		[allow updates]  // The ReadOnly pattern can be inhibited by specifying ‘allow updates’  
		[implements Unique ID] // By default UniqueID is disabled and LazyUniqueId is enabled  
		[has attachments]  // Comment type attach ments are ac cessed thr ough a Text field name <Attac hmentField> 
			[<attachment  FieldName> is comment of type <Literal>…] 
			// All comments  of a particular comment type are concatenated into a single Text  field.  
			// Also disable s Auditing and Eff ectiveD ated 
	
	[implements S3ClassicAttachments] 
		[<attachment  FieldName> is comment of type <Literal>…] 
	
	[implements M3ClassicTable] 
		[allow updates]   // This patte rn by default imp lements the ReadOnly pattern and the LazyUniqueId patte rn 
		// The ReadOnly pattern can be inhibited  by speci fying ‘allow updates’ 
		// Also disable s Audting and Effe ctiveDated  
	
	[implements Resequence on <FieldName>] 
		new sequence field is <FieldName> 
		set is <SetName> 
		// ‘FieldName’  must be numeric. Resequence field and new sequence field must be different fields.  
		// SetName must contai n the Resequence field . Whene ver the new sequen ce field is entered with a  
		// diffe rent value from the resequence fiel d the reco rd will be moved to  the new sequence field posit ion 
		// and then the whole set as defined b y SetName will be resequenced  
		// Typi cally ne w sequence field would be a Transie nt Field 
		// This pattern  will also automatically generate an autosequence rule i f the sequence fiel d as long as 
		// it does not alr eady have an autosequence rule manually defined  
		// When doing mass import using an update actio n the new sequence field can be set to -1 to prevent 
		// rese quen cing, which will significantly improve pe rformance 
	
	[implements DynamicCreation] // Cause s an object to be created automatic ally if it does not exist when another business object  
	// ‘attac hes’ to  it or if an Updat e type action is called. T he cr eation  can be constrained or special 
	// action can be take n upon dynami c creati on by putting rule s in the Dynamic Creation Rules sec tion. 
	
	[implements AnalyticCube] 
		[label is <Message>)] // if not blank, this will be used as the cube name caption  
		[columnar only]  
		[(pre-calculate totals | dynamica lly calculate to tals)] // def ault is ‘ pre-calculate totals’  
		[(allow write to summary level | write to base level only)] 
		// default is ‘al low write to summary level’  
		[refresh using (audit log | message queue)] // default is audit log unless auditing is dis abled 
		[beginning balance is period z ero] // period operators will use period zero for beginning balance  
		// the default is  to calculat e the beginning balance as the sum of all the prior periods  
		// this requires the design er to expl icitly place the begin ning balance in period zer o 
		[Instance Selection] 
			where <Condition> // limits what fact rows a re put in the cube  
	
	// A ChildHier archy is a Hierarchy defined by its  children . It can have multiple pare nts, which m eans that the hier archy operators parent, siblings, 
	// ancestors, and ascendant are not v alid. When used as a Di mension ‘child set  is…’ is required and ‘top node when…’ is h ighly recommended. 
	[implements ChildHierarchy]  
		[top node when <SimpleCondition>] 
		[leaf node when <SimpleCondition>] 
		(children are <RelatedLink> 
		| child set is <RelatedLink>   // required if this KeyField is used in a Dimension  
			child is <KeyField>   // must be a KeyField to th is busines s class 
			[aggregation percent is <FullFieldName>] // must be a P ercent field 
		) // The ‘ children are’ Related Link must point back to this sa me business class and end i n a OTM relation  
		// The ‘child set is’ Relate dLink must point to the intermediate business class that determ ines the chi ldren 
		// The ‘child is’ KeyF ield must then point back to this b usiness class  
		
		[descendants are <RelatedLink>]  // similar to  ‘children are’ but for all descen dants 
	
	[implements CreateStamp] 
	[implements UpdateStamp] 
	
	[implements Proxy for <RelatedLink>] // must be OTO  relation or KeyFi eld 
		[Additional Field Mapping] 
			related.<FullFieldName> = <RelatedValue>… 
	
	[implements CompoundDocument]   // must have at leas t one RelatedLin k 
		Document Components  
			<RelatedLink>… 
	
	[implements BODId] 
	
	[implements Encrypted] 
		[when <Condition>] // can reference only mutable non- related fields 
	
	[implements ContextualParent] // extends Context search to ontological parent business cl ass 
	
	[implements SurrogateAuditLog for <FullFieldName>] 
	// causes the audit log of this  business clas s to really be t he audit log of Fu llFieldNa me 
	// FullField Name must be a Tex t field that contains a seriali zed DataV iew 
	// This is curre ntly only being used for environme nt business classes  
	
	[implements Template Driven by <BusinessClass>] 
		[completion  message is  <Message>] // <Mes sage> can contain text only  
		[(create all instances  // ‘create all insta nces’ is t he default 
		| create instance 
			when <Condition> 
		)    // can reference on ly mutable non- related fields 
		] // For ex ample, A nswer is a part of Response and extends Question. Answer is desig nated as being TemplateDriven by.  
	// Que stion. Question is a tem plate for adding, updating and deleting corresponding Answer ins tances. An Answer instance.  
	// cannot be cr eated with out a corresponding Question instance. 
	// This pattern works w ith a <Template> definition within a <NavigationDef inition> or a <PanelDefi nition> 
	// If cr eate all ins tances is specified,  an Answer inst ance will be created for every Question in the template list..  
	// If the create is conditional, an Answer instance wi ll be cre ated only if the condition evaluates to t rue. If the condition. 
	// is false any e xisting corresponding Answer ins tance will be d eleted.  
	
	[implements <DataSourceType> DataSource] 
	// This pattern defines an alternate data source to satisfy the business class cont ract. This  means the C RUD  pattern  
	// and additional ac tions are realiz ed by an ex ternal data sourc e. 
	
	[implements ExtendsExternalData] 
		[using <ClassName>] // ClassName is a JavaClass that provides access to the external data  
		// This pattern allo ws for the extens ion of an ext ernal data source. Wi th this patte rn external data is viewed as a business 
		// class and the use r is able  to logically add to or change that data. The actual underlying data is not changed. The 
		// underlying data might be a property file on disk or some other flat file format. 
		
		
DataSource  Mapping  
	<DataSourceCRUDType> is <DataSourceAction> 
		<InvokeRule> 
	
	DataSourceType :: = (MI // MI uses  a .mi inter face definition to ful fill the contract  
						| WSI // WSI uses a .wsi interface definition to  fulfill the contract  
						) 
	
	DataSourceCRUDType ::=  (set 
							| find 
							| create 
							| update  
							| delete  
							) 
	
	DataSourceAction ::= <WebserviceInterface>.<ActionName>
	
	
Persistent Fields 
	<FieldName> [<DataDefinition>] 
		[<States>] 
		[<SqlName> | <SqlPrefix>] 
		[<ClassicName>] 
		[<ClassicNameForField>] 
		[<DefaultLabel>] 
		[encrypt]  // causes the field to  be encryp ted in the database; valid on Alpha fields only  
		[automate context] // if the field is a K eyField this will ensure that all context variables are placed on this bus class  
		[enable alternate document location] // valid  for BinaryDocument, BinaryObje ct, CSVTex t, JSONObject,  
			[document  is <RelatedField>] //     RichText, Text, Text Document , and XMLDocum ent fields  only 
			[existence is <RelatedField>] // Must be a Boolean type field  
		[allow images]   // valid for RichText  fields only 
		[text se archable]  // mea ns thi s field will be search text indexed by the database  
		[scannable]  
		[holds pii] 
		[translatable]   // allows for da ta translati on for this field  
		[disable Auditing [when in background]]  // Field will not be audited  
		[disable EffectiveDated]  // Field will not part icipate in EffectiveDa ted pattern 
		[enable EffectiveDated]  // Field will participate in Effe ctiveDated pattern  (valid on BinaryDocument and BinaryObject only)  
		[restricted]   // cannot be used as field on UI  
		[protected]   // appli cation -contr olled field; cannot be  updated from the UI, webservices, or spreadsheet  
		[precision is <RelatedValue>] 
			[round to precision] 
		[primitive type is <RelatedValue>]// must be of type ‘PrimitiveT ype’; ca nnot be Tex t or BinaryDocument/Im age 
		[primitive size is <RelatedValue>] 
		[primitive decimal size is <RelatedValue>] 
		[create value is b lank if no entry]  
		// If a field is added after  a recor d is create d, typically  the firs t value in the audit log applies as the value from  
		// the point of create. With this pattern, the value from create will be considered blank 
		[disable su rrogates] 
		[context of <FullFieldName>]… 
		// This c an be used to disambiguate which field on this business class should be used as  the Context field  for this K eyField  
		[(delete cascades | delete ignored)]  
		// <FieldName> m ust be  a KeyFiel d. The default delete r ule for a KeyField is del ete res tricted  
		// Use  of a KeyF ield will cause an OTM back relation to be automaticall y genera ted 
		[as of <RelatedValue>] 
		// <FieldName> must be a KeyField, <RelatedVa lue> m ust be a TimeStamp or a Date  
		// this directive  will retrieve the busi ness c lass that this keyfield points to ‘as of’ the specified date and ti me 
		// an implication of this is th at the one- to-many r elation  from the keyfield’ s business class back to this  
		// business c lass wi ll be ‘de lete ignored’. If <RelatedV alue> is a Date  then the last entry on that date will be retrieved.  
		[within <RelatedValue>] 
			[<Message>] 
		// valid on a KeyF ield only ; <Rel atedValue> must be a fi eld reference via an  OTM  relatio n that defines a set of K eyFields  
		// of this KeyField’s type. <Message> is an optional error m essage.  
		[[exact] version is (<RelatedValue> | latest)] 
		// This directiv e specifies the par ticular v ersion of a ver sioned key f ield to retriev e. If the version field on the 
		// key field is of type Date, Tim eStamp o r Time  this will default to the current date, current t imestamp or current time  
		// otherwise it w ill default to the latest v ersion. If  there  is no exact match on the v ersion it will return  the closest version  
		// prior to the version specified.If ‘exact version  is’ is specified then there must be an exact match on the version. 
		// if ‘latest’ version  is sp ecified th en it will always find  the last version eve n if that is  a future v ersion. 
		[data area is <RelatedValue>] 
		// valid only when in a ‘stored in environment’ busclass 
		[is (condition | related (link | value)) for <RelatedValue>] 
			[(dimensions  [with attributes] | measures) only] // RelatedValue must be a BusinessClass name  
		[<TextVariables>] 
		// Text variab les can be defined  for any Alpha type field. This  allows th e user who is entering data in this  
		// field to  put in variable su bstitutio n syntax tha t references these defined variable names. The syntax to 
		// use a text v ariable is ‘{TextVariable}’. Notice t he curl y braces s pecial synt ax that 
		// surr ound s the Text Variable name. TextVariables can be one- to-many valued. If the va riable s tarts at 
		// the beginning of a line and ends with a ne w line character then it will be copied down – each OTM being a new line. 
		// If not then it will act as though it is in paragraph mode. 
		// A value d oes not have to be ascribe d to a TextVariable  definition. This will mean that no substitution ever 
		// takes place. This is useful when def ining text fields that are used as te mplates  for other  text field s. The only 
		// issu e is that the designer needs to make sure t he vari able nam e match on both the tem plate and the tar get. 
		// If a text variable uses a C ontext Field in its RelatedLink then the value of the Context Field must be speci fied 
		// as such ‘{TextVariable:<Cont extFieldValue> }’ 
		[document template for <BusinessClass>] 
		// This field must be of the type ‘BinaryDocument’. A document template is a ‘rtf’  file with standard  
		// Word Doc repl acement  variables which must be of LPL syntax. When the ‘document’ TypeOperator is used  
		// on thi s field the ‘rtf’ is  sent through a variable replacement transformation resulting in another ‘rtf’ file  
		// that can be assigned to a BinaryDocument field. This allo ws for Word Documents to be generated within LPL.  
		[store as BusinessObjectReference] // valid  on a KeyField only 
			[<SqlPrefix>] 
		// This is required when trying to assign thi s value from an asynchronous operation. LawsonClassi cTransactions 
		// are  an example of an as ynchronous operation. When creating a new r ecord via  an asynchronous operat ion 
		// only the Bu sinessObjectReference of the record is i mmed iately available and thus only th at aspect of the 
		// keyfield can ac tually b e stored. A BusinessO bjectReference i s internally a  GroupField and may have sql  
		// naming co nflicts. The ‘sql prefix’  state ment can be  used to overcome any naming conflict. 
		[Valid Business Classes]  // valid on a BusinessObjectReference only  
			<BusinessClass>… 
		
	<FieldName> is a snapshot of <RelatedField> 
		[when <Condition>] 
		// snapshot sets and keeps this field the same as R elatedField only when this business object is being updated. 
		// This can optionally be done based on a Condition  
	
	(<FieldName> | <FieldGroupName>) from <BusinessClass> 
	
	(audit fields | <ActionAttribute>…) // valid only  when Auditing and Effe ctiveD ated are disabled  
	
	TextVariables  ::= 
		Text Variables [<Parens>locale of <RelatedValue><Parens>] // RelatedValue must b e an IsoLocale 
			<TextVariable> [value is <RelatedValue>]… 
	// A TextVari able can be placed in a Text field surrounded by curly braces as such, {<TextVari able>}. When the  
	// TypeOperator text  is use d on thi s field,  the TextVar iable w ill be re placed i n the Text f ield with the designated  
	// Rel atedValue. RelatedValues can be directly used for variable replacemen t by pre fixing the  related va lue with  
	// lpl: , making the syntax {lpl:<RelatedVa lue>} . This allows  for Use rFields and other  dynam ic LPL constr ucts 
	// to be used at runtime without havin g to have a TextVariable. 
	
	AggregateOp ::= (aggregate  
					| instance co unt 
					) 
	// The aggregate operator can be used only in a bus iness class that is an  aggregate of the  
	// an aggregated <Busine ssClass>. If the op erator instance count is used, .<FullFie ldNa me> cannot be 
	//specified.If th e operator aggregate is used, .<FullF ieldNam e> must be specified and must be a fi eld in the  
	// aggregated <BusinessClass> that is capabl e of b eing aggregated. It  must be some form of numeric field.  
	// It can be a group field with non-aggregatable fields in it if there is at least one aggre gatable field.  


Transient Fields 
// Mutable but not persistent 
	<FieldName> [<DataDefinition>] 
		[<States>] 
		[<DefaultLabel>] 
		[scannable]  
		[holds pii] 
		[precision is <RelatedValue>] 
			[round to precision] 
		[primitive type is <RelatedValue>]// Must be of type ‘PrimitiveType’; ca nnot be Text or B inaryDocument/Image  
		[primitive size is <RelatedValue>] 
		[primitive decimal size is <RelatedValue>] 
		[as of <RelatedValue>] 
		[within <RelatedValue>] 
			[<Message>] 
		[disable surrogates] 
		[[exact] version is (<RelatedValue> | latest)] 
		[data area is <RelatedValue>]  // valid only when in a ‘stored  in environment’ busclass  
		[is (condition | related (link | value))  for <RelatedValue>] 
			[(dimensions  [with attributes] | measures) only] // RelatedValue must be a BusinessClass name  
		[<TextVariables>] 
		[document template for <BusinessClass>] 
		[store as BusinessObjectReference] // valid on a KeyField only  
		[derive value from <RelatedValue>] // value when field is not entered  


Dimensions  
	<RelatedField> // must be a KeyField or  a StateField  or designated as a ‘period’- ca n be only a one- to-one related field  
		[dimension  name is <Literal>] // default is business class prefix plus field name  
		// if the d efault exceeds the n ame limit of 50 characters, yo u must specify a name 
		[label is <Message>)] // if not b lank, this will be used as the cube dimension name caption  
		[suppress dimension when <SimpleCondition>] 
		[caption  is (representati ve text | <Message>)] // default text to display in cube; defaul ts to representative te xt 
		[default total node is <RelatedField>] // If a default total n ode is not specified , an All node , which  aggregate s all the 
		// dimension values, is generat ed and used when no dimension value  is sp ecifie d. 
		[top node is <RelatedField>]  // top or ‘start’ node when dimen sion is parent or chi ld hierarchy 
		[disable hierarchyag gregation]  // by default all hierarchy dimensions will agg regate based on the hierarchy  
		[is a <PeriodType> period dimension [with year of <FullFieldName>]] 
		// daily periods only roll up in to months based on a Gregorian calendar 
		// if the  RelatedField is a  date then it must b e a daily perio d dimension and does not need a year designation 
		// ‘with year…’ is req uired on all non date-based periods 
			[current year is <RelatedField>] 
			[current period is <RelatedField>] 
			[current date is <RelatedField>] // valid on a date-based period only; if no cu rrent perio d is defined, 
			// the current period wil l be dete rmined based on the ‘as of’ date 
			[period set is <RelatedField>] // valid on a date-based period only 
			
			// The following specificatio ns are required for PeriodOperators to w ork wi th the ‘variable’ PeriodType 
			// Con dition and FullFieldName below are in the cont ext of the dimen sion business class  
			[default label is <Message>] // period label  
			[current date period is <FullFieldName>] // period key field that corr esponds to the current date  
			[year when <Condition>]  // true when period is a year  
			[quarter when <Condition>] // true when period is a quarter  
			[month when <Condition>]  // true when period is a month  
			[week wh en <Conditio n>]  // true when period is a week  
			[day when <Condition>]  // true when pe riod is a day 
			[start date is <FullFieldName>] // Date field that retu rns peri od start date 
			[end date is <FullFieldName>] // Date field that return s per iod end date 
			[parent period is <FullFieldName>] // period k ey field for parent period  
			[next period is <FullFieldName>] // period key fi eld for next period  
			[previous period is <FullFieldName>] // per iod k ey field for previous period  
			[beginning b alance is <FullFieldName>] // per iod key field for ltd beginning balance  
			[ending balance is <FullFieldName>] // period key field  for ltd ending balance  
			[beginning ytd balance is <FullFieldName>] // period key field for ytd beginning balance  
			[ending ytd balance is  <FullFieldName>] // period key fi eld for  ytd ending bala nce 
		[valid for measure <FullFieldName>]… 
		[(allow write to summary level | write to base level only)] 
		// default is ‘allow write to summary level’ unless changed at the Anal yticC ube level  
		[Instance Selection] 
			where <Condition> // Valid when RelatedField  is a Ke yField  or a one- to-one rel ated field. The  Condition is 
		// defined in the context of the KeyField / OT O Business Class.  
		[Attributes] 
			[child.]<FullFieldName>… // Ful lFieldName is a field in the KeyField’s Busin essC lass. If the K eyField  is a ChildHierar chy 
		// then fields  in the child set BusinessClass can also be re ferenced using the ‘ child’ data link.  
		[Hierarchies]  
			<HierarchyName> // gen erates a rollup hierarchy using the spec ified attributes 
				[base level (hidden | included)] // default is included  
				[description is <Message>] // defaults  to Hierar chyN ame 
				
				Attributes
					[child.]<FullFieldName>… // must be a declared Attribute  
		
		PeriodType  ::= (monthly 
						| weekly 
						| daily 
						| variable 
						)
 
 
Measure Based Dimensions  
// A Measure Based Dimension is not an existing field value but rather takes on a value based on each measure. Each measure must specify the value for this field.  
	<FieldName> [<DataDefinition>]  // must be a KeyField o r a StateField  
		[dimension name is <Literal>]  // default is business class  prefix plus field name  
		// if the  default exceeds  the name lim it of 50 char acters, you mus t specify  a name 
		[label is <Message>)]  // if not blank, this  will be used as the cube dimens ion name caption  
		[caption is (representative text | <Message>)] // default text to display  in cube; defaults to re presentative te xt 
		[default total node is <RelatedField>] // If a  default total node is not specified, an All node , which aggregates all the  
		// dime nsion values, is generated and used when no dim ension value is specifie d 
		[Instance Selection] 
			where <Condition> // Valid when RelatedField is a  KeyField or a one- to-one relate d field. 
		// The Condition is defin ed in th e context of  the KeyField / OTO BusinessClass.  
		[Attributes] 
			[child.]<FullFieldName>… // Ful lFieldNa me is a field in the KeyField’s Busi nessClass.  If the Ke yField is a ChildHier archy, 
		// then fields  in the child se t Busi nessClass ca n also be referenced using the ‘chi ld’ data link. 
				[is aggregatable]  // generates a rollup hierarchy over this attribute in  the cube 
		[Hierarchies] 
			<HierarchyName>  // generates a r ollup hiera rchy using t he spe cified attributes  
				[base level (hidden | included)] // default is included  
				[description is <Message>] // defau lts to Hier archyName 
				Attributes
					[child.]<FullFieldName>… // must be a declare d Attr ibute, then fields in the child set BusinessClass  
				// can also be referenced using the ‘child’ data link. 


Measures
	<FullFieldName>  // must be a Persiste nt or Derived field that is num eric 
		[measure name is <Literal>] // default is busine ss class prefix plus field name; default max is 50, otherwise specify a name  
		[calculate dynamically]  // valid only when measure is a ComputeFie ld 
		[<DimensionField> value is <RelatedValue>] 
		// DimensionField must be a Me asure  Based Dimension 
		// When using a Meas ure Based Dimension, measure names can be duplicated  
		[cube rule is <Message>] // FullFieldNam e must b e a NativeFi eld 
		[Dimension Based Measures] 
			<FieldName>… 
				[<DefaultLabel>]
				Dimension Values 
					<DimensionField> value is <RelatedValue>… 


Cube Links  
// Link to another BusinessClass’s cube that automatically extends this cube’s measures to include all the measures of the linked cube 
	<CubeLinkName> 
		link to <BusinessClass> // BusinessClass must have a cube def ined 
		[Dimension Mapping]  
			related.<DimensionField> = (<Dimension Field> | top node)… 
			
			
Context Fields  
	<ContextField>… 
		[<DefaultLabel>] 
		[is (condition | related (link | value)) for <RelatedValue>] 
			[(dimensions  [with attributes] | measures) only] // RelatedValue must be a Busines sClass name 


Field Groups
// Arbitrary grouping of fields within this business class 
	<FieldGroupName> 
		[include [(persisten t | auditable | derived)] user fields] 
		<FullFieldName>… 


Audit Index Fields  
// List of fields to add to audit index (snapshot table) by default all fields in Sets are put in the audit index 
	<FullFieldName>… 


Local Fields  
	<FieldName> [(<DataDefinition> 
				| is a <BusinessClass> view 
				)] 
		[<DefaultLabel>] 
		[value is <RelatedField>] 
		[<States>] 
		[holds pii]  
		[precision is <RelatedValue>] 
			[round to precision] 
		[as of <RelatedValue>] 
		[disable surrogates]  
		[[exact] version is (<RelatedValue> | latest)] 
		[data area  is <RelatedValue>]  // valid only when  in a ‘sto red in environment ’ busclass 
		[is (conditi on | related (link | value)) for <RelatedValue>] 
			[(dimensions  [with attributes] | measures) only] // RelatedValue must be a BusinessClass name  
		[<TextVariables>] 
		[document template for <BusinessClass>] 
		[store as BusinessObjectReference] // valid on a KeyField only 
		[do not save in checkpoint]
 
 
Derived Fields  
	<FieldName> is a[n] <DerivedFieldType> 
		[type (<DataDefinition> | is a[n] <BusinessClass> view | is MessageField)] 
			[precision is <RelatedValue>] 
		// type is not required for all derived fields.  On some derived fields, such as Compute, the type defaults from the 
		// fields in the compute statement.  
		[is (con dition | related (link | value)) for <RelatedValue>] 
		// RelatedValue must be a BusinessClass name 
		[<SqlName>] 
		[<ClassicName>] 
		[<DefaultLabel>] 
		[restricted]  // cannot be used as field on UI  
		[holds pii]  
		(<DerivedFieldExpression> | <optionally blank for NativeField and InstanceCount>) 
	
	DerivedFieldType ::=	(aggregation of  <FullFieldName> 
							| ConditionalField 
							| ComputeField 
							| MeasureField 
							| InstanceCount 
							| StringField  
							| MessageField 
							| LabelField 
							| DerivedField) 
	
	DerivedFieldExpression  ::= 
		aggregation of
			when <Condition> // useful for cube measures - returns FullFieldName value or 0 on instance depending on condition  
		Conditional Field  
			<ConditionalFieldControl> 
		ComputeField 
			<Parens><RelatedValue> [<MathOperator> <RelatedValue>]<Parens>… 
		MeasureField  
			<Parens><MeasureValue> [<MathOperator> <MeasureValue>]<Parens>… 
		InstanceCount  
			[where <Condition>] // useful for cube measures - returns 1 or 0 on instance depending on condition  
		StringField  
			<RelatedValue> <RelatedValue> <RelatedValue>… 
		MessageField  
			<Message>  // language translat able string that is treated  as a Message (l owercase) 
		LabelField  
			<Message>  // language translata ble stri ng that is trea ted as a Label (upper and lowercase)  
		DerivedField  
			(<Rule> | return [<RelatedValue>])… 
	
	MeasureValue ::= ((sum | avg | min | max) <RelatedField> | instance  count) 
	
	Condition ::=	<Parens><ConditionNode><Parens> 
					[<Conjunctio n> <Parens><ConditionNode><Parens>…] 
	
	ConditionalFieldControl ::=  
		if <Condition> 
			(<RelatedValue> | <ConditionalFieldControl>)… 
		[else] 
			(<RelatedValue> | <ConditionalFieldControl>)… 
	
	MathOperator ::= 	(+ // You can use the ‘+’ oper ator to concatenate Alpha type fields  
						| -  // You can use the ‘- ’ operator t o remove strin gs from Alpha type fields  
						| * 
						| / 
						| ^ 
						| % 
						)
	
	
Conditions  
	<ConditionName> 
		[<SqlName>] 
		[<ClassicName>] 
		[<DefaultLabel>] 
		[restricted] // cannot be used as field on UI  
		when <Condition> 
	
	Conjunction ::= (and 
					| or 
					) 
	
	ConditionNode ::=	(<ActorCondition> 
						| <ChangedCondition> 
						| <ComparisonCondition> 
						| <FieldCondition> 
						| <FieldWasCondition> 
						| <IsABusClassCondition> 
						| <RelatedCondition> 
						| <RelationCondition> 
						| <WithinBusClassGroupCondition> 
						) 
	
	ActorCondition ::= [authenticated] actor (has role | in group) <Text> 
	// Text is either a role name or an actor group name 
	
	ChangedCondition  ::= (<RelatedLink> | <RelatedField> | [<RelatedLink>].<FieldGroup Name>) 
	changed between <RelatedValue> and <RelatedValue> 
	// ‘changed between’ RelatedValues must be Date or  TimeStamp 
	
	ComparisonCondition  ::= <Related Value> <ConditionOperator> <RelatedValue> 
	
	FieldCondition ::=	[<FieldOperator>](<RelatedField> | <FieldGroupName>) 
						(entered   // not yet implemented  with <FieldGroupName>  
						| is numeric  // not yet implemented with <Fi eldGroupName>  
						| is high value 
						| changed 
						| in context  // not yet implemented with <F ieldGr oupName> 
						| is leap year 
						| is last day  in month 
						| has audit change // valid only in conte xt of an audit entry  
						) 
						// You cannot use a <RelatedField> with ‘changed’ a nd ‘in context ’. These ca n take a <FullFieldName>. 
	
	FieldWasCondition  ::=	<FullFieldName> was [always] <RelatedValue> 
							[between <RelatedValue> and <RelatedValue>] 
							// between RelatedValues must be Date or TimeStamp 
	
	IsABusClassCondition ::= <RelatedField> is a[n] <BusinessClass> 
	
	RelationCondition ::= [(first | no [t])] <RelatedLink> (exists | pending | has future changes)  
	//’ pending’ is valid only with a BusinessObjectR eference field or a  KeyField that is designated as 
	// ‘sto re as BusinessObjectReference’.  It returns t rue if the  reference is filled out but the record  
	// does not actual ly exi st yet. Curren tly this ca n happen only when using the asynchronous AGS or other 
	// async third p arty inte rface.  
	// ‘has future c hanges’ returns true if there are futu re effective dated changes from th e current as of date 
	
	ConditionOperator ::=   (= 
							| != 
							|>= 
							| <= 
							|> 
							| <
							| !> 
							| !<
							| like 
							| contains 
							| [not] with in 
							| [not] overla ps 
							| [not] matches 
							) 
							// The like operator is similar to the ‘=’ op erator excep t that it w ill do wild -card searching 
							// The contains operator will do a te xt sear ch on the f ield; i t is valid only if the  field is text searchable  
							// The within operator i s valid with array key fields that implement the Hierarchy pattern  
							//       It ev aluates to true when the left operand’s occurring fields match up to the non-blank right 
							//       operand’s occurring fields. If the left operand has {5,3,9,10,20} as its oc curring values it will match  
							//       the following right operands: {5,,,,}, {5,3,,,},{5,3,9,,}, {5,3,9,10,}, {5,3,9,10,20}. The concept is that 
							//       the left operand is ‘wi thin’ the right operand’s hierarchical structure. 
							// The within operator is valid wi th a group field t hat im plements the FieldRange pattern as the ri ght operands.  
							// The within operator is valid with TimeStamp, Date, Period (month) , Year, and month and week operators 
							//      on both sides as long as the the left operand has more specifi city than the righ t operand.  
							//      So (<TimeStamp> within <Date>) is valid b ut (<Date> within <TimeStamp>) is not. 
							// The overlaps operator is valid only with two  group fields that implement the FieldRange pattern  
							// The m atches oper ator treats the right side operand as a r egular expression to determine i f the le ft side ope rand 
							//       completely matches the pattern on the right. The java doc for java.util.regex.Pat tern contains some  
							//       document ation  for a number o f the vario us regular expression strings. Anot her resources is  
							//       “Mastering  Regular Expressions, 2nd Edition,” Jeffrey E.F. Friedl, O’Reilly and Assoc iates, 2 002. 
	
	WithinBusClassGroupCondition ::= <RelatedLink> [not] within <RelatedField> 
	// RelatedField must be a B usinessClassGroup or an LPL Text fiel d that is a condition 


Text Search Fields 
// Fields to use in a Text Search f or this Business Class  
	(<FullFieldName> | <FieldGroupName>)… // will t ext se arch index pe rsistent fields only  
		[is a facet] 
		[(index words | index phrase)]  // default is index  words 
		[(index data translations | index base data only)] // default is index trans lations 

Cube Relations 
	<CubeRelationName> 
		(cell | matrix) relation to <BusinessClass> 
		[allow dimension reordering]  // allows for dynamic optimization on retrieval 
		[period view is <PeriodOperator>] 
		[dynamic mapping is <RelatedValue>] 
		[dynamic preload measures are <RelatedValue>] 
		[Dimension Mapping]  
			related.<DimensionField> (= <RelatedValue> [and blank dimension] 
										| where (<MeasureConditio n>) 
										)… 
		[Preload Measures] 
			<FullFieldName> [<PeriodOperator>]… // must be a valid Measure on <BusinessClass> 
	
	MeasureCondition ::= 	<Parens><MeasureConditionNode><Parens> 
							[<Conjunction> <Parens><MeasureConditionNode><Parens>…] 
	
	MeasureConditionNode  ::= <FullField Name> [not] empty // must be a val id Mea sure on <BusinessClass> 


Columnar Relations 
	<ColumnarRelationName> 
		(cell | matrix) relation to <BusinessClass> 
		[period view is <PeriodOperator>] 
		[dynamic mapping is <RelatedValue>] 
		[dynamic preload measures are <RelatedValue>] 
		[Dimensions] 
			[related.<RelatedField> = <RelatedValue>]… 
		[Preload Measures]  
			<FullFieldName> [<PeriodOperator>]… // must be a valid derived Measure Field  on <BusinessClass>  
		[Instance Selection] 
			where <Condition> 
			// Valid only with matrix relation. This exp ression can use the OTM object’s fields and the current object’s fields. 


Relations 
// By default, a relation is valid only if key fields are entered  
	(<RelationName> [is a[n] (<Business Class> | <KeyField>) set] 
	| <KeyField> set 
	)  // When KeyField set is used, th e RelationName i s ‘ <KeyField>Set’. A lternatively a one-to-many r elation 
	// based on a KeyField can be given a s pecific name by usin g ‘<Relation Name> is a <KeyFie ld> set’. 
	// A KeyField set is the p referred way to def ine a one- to-many relation. It is similar to a Relative 
	// Rela tion excep t that it automat ically  gene rates the relation to phrase bel ow. 
		[<SqlName>] 
		[<ClassicName>] 
		[<DefaultLabel>] 
		[(one-to-one | one-to-many) relation (to <BusinessClass> | using <Related Link>)] 
		// If RelatedLink is a Relative Relation, it is a further definition base d on the R elation given. 
		// This would typically be used only to further restrict a  one- to-many relatio n. This phrase is required when the  
		// Relation  is not a KeyF ield se t, othe rwise a KeyF ield set has the same rules as a Relative Relation. 
		[valid when <Condition>] 
		[<AsOfDate>] 
		[required] 
		[delete (restricted | cascades)] 
		[(enable | disable) subset se lect on dependent relation] 
		[disable filtering within db] 
		[disable link cache]  
		[include deleted record]  // Valid only  with one- to-one where business class has a del ete flag  
		// When bus clas s is “sto re using” must implement DeleteFlag and support including del eted records  
		[dynamic mapping is <RelatedValue>] 
		[Field Mapping uses <Set>] // Not required o n a Rel ative Relation but c an still be used to  alter the sort order  
		[related.<FullFieldName> <RelationOperator> <RelatedValue>…] 
		// Multiple depende nt OTMs  can be used in Rel atedValu e but only i f all o f the OTMs have a di rect OTO  
		// relation back to the targe t of this Rel ation  
		[Instance Selection] 
		[include [only] deleted records] 
		where <Condition> 
		// valid with one-to-many only. This expression can use the OTM  object’s fields and  the current object’s fields . 
		
	Set ::= (<SetName> 
			| [<BusinessClass>] part of key 
			| [<KeyField>] (symbolic | level) key  
			| bod key 
			| update stamp key  
			| unique id  key 
			) 
			// BusinessClass must be one of the ‘part of’ business classes and KeyField must be one of the symbolic key fields 
			// ‘level key’ is valid on ly on a key field that implements the Array Hierarchy pattern 
			// ’bod key’ is valid only when this business class implements BODId 
			// ‘update stamp key’ is valid when the update stamp exists and is  not virtual 
			// and only has the update stamp time stamp field on it.  
			// “unique id key” is valid as long as the business class does not have UniqueID disabled 
		
	RelationOperator  ::=	(= 
							|>= 
							|> 
							| <= 
							| <
							| as of 
							) 
							// non = operat ors a re val id on last key only 
							// ‘as of’ operator i s valid  on a date only  
		
	<RelationName> // A conditional relation must return the same underlying business object with the same cardinality (oto or otm)  
		[<SqlName>] 
		[<ClassicName>] 
		<ConditionalRelationControl> 
		
	Conditional RelationControl  ::= 
		if <Condition> 
			(<RelationName> | <ConditionalRelationControl>)… 
		[else] 
			(<RelatedValue> | <ConditionalRelationControl>)… 

Form Invokes  
	<FormInvokeName> 
		(<FormInvokeRule> | <ControlRule>)… 
 
	FormInvokeRule  ::= 
		invoke <InvocationTarget> 
			[fill in [blank] fields from <RelatedLink>] 
				[except invoked.(<FullFieldName> | <FieldGroupName>)…] 
			// <RelatedLink> cannot be the sa me as the invoke’s  <Related Link>  
			[invoked.<FullFieldName> <AssignmentOp> <RelatedValue>…] 
			[<Rule>…] 
			// the way to address fi elds in the <RelatedLink> that is being addresse d here is to use the 
			// invoked keyword 


Matrix Forms  
	<MatrixForm> 
		rows are <RelatedLink> 
		(column is <Business Class> 
		| columns are <RelatedLink> 
		) 
		cell is <Business Class> 
			[completion message is <Message>] 
			[(create all instances // if n either of these are specified then the matrix is v iew only 
			| create instance 
				when <Condition> 
			)] 


Sets 
	<SetName>  // NoKeyChange is no longer supported. All indexes can have keys changed.  
		[<SqlName>] 
		[<ClassicName>] 
		[primary]   // One index only must be pr imary and cannot have duplicates, if no Ontology section  
		[override primary] // Over rides the Set generated from the Ontology definition  
		[(no duplicates  // default 
			| duplicates)] 
		[bypass no duplicates validation]  
		[(indexed  // ‘indexed’ forces  the crea tion of a physical SQL index for faster retrieval  
			| not indexed)] // ‘no t indexed ’ prevents  a physical SQL inde x from bei ng created – it is a lways vir tual 
		// If neithe r of thes e are spe cified  then the build pr ocess w ill dynamically  create  
		// a physical index based on general implementation parameters. Indexes that have 
		// a related field in them cannot be phy sically in dexed by the database. 
		[primary when importing] // use this index as the  primary index whe n importing data  
		[filter instance selection]  // filter instance selection rather than building a subset index  
		Sort Order 
			<FullFieldName> [descending] 
			… 
		[Instance Selection] 
			where	(<Parens><RelatedCondition><Parens> 
					// for non- filter ed selections , you must define a condi tion with onl y primar y fields  
					| <Condition> 
					)

 
Rules
	AssignmentOp : :=	( = 
						| += 
						| -= 
						| *= 
						| /= 
						| ^= // exponentiation  
						| %= // is modulus operator  
						) 
 
	Rule ::=	(<ControlRule> 
				| <GeneralRule> // valid in  all contexts 
				| <FieldRule> // valid in Field con text only 
				| <FieldCreateRule> // valid in Field context with Create actio n 
				| <GroupRule> // valid in a Gr oupField only  
				| <ArrayRule> // valid in an ArrayField only  
				| <ActionRule> // valid in Action context only  
				| <FormInvokeRule> // valid in  the Form Invokes section only  
				) 
	
	ControlRule  ::= // A C ontrolRule  is a Rule that defines the contr ol of o ther rules. As with a stan dard Rul e, each has a recur sive 
	// nature, that is, the <Rule> under the ‘If  <Condition>‘ can be another ControlRule o r standard Rule. 
		if <Condition> 
			<Rule>… 
		[else] 
			<Rule>… 
		
		for each[<Parens><LPLConstructName><Parens>]	([<Distinct> in] <otm RelatedLink> 
														| <array RelatedField> 
														| <iteration FullFieldName> 
														) 
			[while <Condition>] 
			<Rule>… 
			[each[<Parens><LPLConstructName><Parens>].<RelatedField>] 
				// In the scope of the ‘for each’ the f ields of the <OTM Re lationName> and the occurring fie ld within  
				// <Array RelatedField> are addr essed through the ‘each’ key word. If the <OTM RelationName> is ‘Em ployees’  
				// and a f ield on  the Emplo yee b usiness class is ‘Name ’ then that field is addre ssed as ‘each.N ame’ wit hin the scope 
				// of the for eac h. If one ‘for each’ is nested within anothe r ‘for each’ a ‘f or each1’ can be specified that allows both  
				// the for each and the for each 1 var iables to be addressed through each.<Field> and each1.<Fie ld> 
				// If th is is for an array field, this structure dr ives a loop that goes through each occurren ce in the array.  
				// All other array fields are presumed to have the same in dex as the primary occu rring  field. T he RelatedField must be a field  
				// that has  a Representa tion with a field that occurs. The actual occurrin g field must be addres sed directly  (for example 
				// each.OccuringField) within the actual loop. 
				// If t he ‘each ’ qualif ier is not provided it will use the most inner for each context. 
				// If a n iteration fie ld is used it must first be initialized by doing a ‘ first iteration of…’ 
		
		
		end for each // Us ed to break out of a ‘for each’ loop. This rule is NOT a s yntactic al 
		// structure t o end a ‘f or each’ statement. Rather, it is  a control rule  
		// ending the execution of the ‘for each’ rule and causing executi on to go  
		// to the first  rule af ter th e ‘for each’. 
		
		while <Condition> 
			<Rule>… 
		
		end while // Used to break out of a ‘while’ loop. This  rule is NO T a syntac tical structure to end a ‘while’  statement. Rather, it is  
		// a control rule  ending  the execu tion of the ‘while’ rule and causing execution to go to the first rule  after the ‘ while ’. 
	
	GeneralRule  ::= // valid in all contexts  
		confirmation required  
			[<Message>] 
	
		constraint <Condition> 
			<Message> // Mess age required on con straint rule 
			
		<RelatedField> <AssignmentOp> <RelatedValue> // Assignment rule 
		// <Re latedField> valid only in scope of Business Object (not field rules)  
		// useful in a Fie ld Contex t Rul e 
		
		increment <RelatedField> [by <RelatedValue>] 
			[when <Condition>] 
		
		decrement <RelatedField> [by <RelatedValue>] 
		[when <Condition>] 
		
		initialize [(<FullFieldName> | <FieldGroupName>)] 
		
		(display | log) <Message> // display message on cons ole or write to standard log  
		// when running on a production system ‘display ’ is a noop 
		
		add action tag <ActionTag> // add an ActionTag to the execution path  
		
		include <RuleBlockName> // copy named block of rules in-line  
		
		round <FullFieldName> [(up | down)] to nearest [exact] <RelatedValue> 
		// if ‘exact’ is n ot specified then  this round s to the nearest m ultiple of 
		// ‘RelatedValue’otherwise it r ounds ‘exactl y’ to the specified RelatedValue  
		// Thus  if ‘exact .95’ is specified then the number wil l alwa ys end in ‘.95’ 
		// If non -exact ‘.01’ is spec ifiied the n the num ber will al ways en d in a mult iple 
		// of ‘.01’ – which  in this case is simply ro unding the number to th e hundredths place 
		
		clear in-memory cache [for <BusinessClass>] 
		// this will clear the in -memory  cache of all Busin essClass in stances  or a speci fic set of  
		// BusinessC lass instances if a Busine ssClass is sp ecified 
		
		synchronize on  <RelatedLink> 
		// this will caus e all the thr eads where RelatedLink points to the same record to single - 
		// thread from t his point until th e end of the trans action  
	
	FieldRule  ::=  // valid in Field context only  
		[(force | dynamic)] default [<FullFieldName>] to <RelatedValue> 
		// a force d efault rule  default s the fie ld whethe r it is entered or  not 
		// a dynamic defaul t rule leaves  the field  blank and dynamically defaults it when it is referenced  
		// a standard default fills  in the  field if it is blank  
			[(default as a gr oup // default 
			| default i ndividual fields 
			) 
			] 
		
		required 
			[<Message>]  // defaults to ‘Field is required’  
		
		cannot be entered 
			[<Message>]  // defaul ts to ‘Fie ld cannot be entered’  
		
		cannot be changed  
			[<Message>]  // defaults to ‘Field cannot be changed’  
		
		must be numeric  
			[<Message>]  // defaults t o ‘Fiel d must be numeric’  
		
		initial value is <RelatedValue> // valid on Field Rules and Parame ter Rules only 
			[when <SimpleCondition>] 
		
		field size is <RelatedField> 
		
	FieldCreateRule  ::= // valid in Fiel d cont ext with Create action when FullFieldName not used otherwi se valid  general rule 
		autosequence [<FullFieldName>] [when blank] [us ing (<RelatedField> | <Set Name>)] 
			[manual range is <RelatedField>] // must be a group field  that imp lements FieldRange  
			[minimize contention [and gaps]] 
			// if no field  specified find last instance in  context  and increment by 1 – field must be eith er sym bolic o r relative key  
			// if SetName specified then find l ast instance using SetName  – Se tName  must contain this field  
			// if RelatedField specifie d then increment Relate dField by 1 and use that value  
			// minim ize contention is not valid with a  Relat edField –this  option can result in gaps in the numeri cal sequence 
			// typically ‘mi nimize conte ntion ’ will retrieve a block of numbers, when gaps are minim ized as wel l, it retrieves one at a time  
			// ‘when blank’ is not valid with ‘minimize contentio n’ 
	
	GroupRule ::=   // valid in a GroupField only  
		always default	(individual fields  // prevents  grou p default rule  from being overridden  
						| as a group  
						) 
		
		mutually exclusive 
			[<Message>] 
	
	ArrayRule  ::= // valid in a n ArrayField  only 
		array size is <RelatedField> 
		edit increasing sequence 
		make increasing sequence 
		edit decreasing sequence 
		make decreasing sequence 
		edit contiguous  
		make contiguous  
		no duplicates [on <FullFieldName> [,<FullFieldName>…]] 
		// where Field  is a Memb erField within an occurring GroupField 
	
	ActionRule ::=  // valid  in Action co ntext or R ulesField only 
		make transition to <FullStateName> 
		
		commit transaction 
		// transactions are automat ic―this fo rces a commit in the  middle  of a transaction and starts a new transaction 
		// this operation  can cause data integ rity problems unless the application is carefully constructed to manage this. 
		// on a  SetAct ion this rule schedules a commit to take place at the next possible boundary―no data integrity p roblems 
		// will o ccur using this in a SetAction 
		
		end set action instance loop 
		// valid in instance rules in a SetAction only ―this ends the instance action loop but will continue to run Set Rules 
		
		build text search field <FullFieldName> // strings the given fields in to <FullFieldName>  
			Fields 
				(<RelatedValue> | [<RelatedLink>.]<FieldGroupName>)… 
		
		initiate <RelatedValue> workflow // RelatedVa lue must be a Workf lowDefinitionCode  
			resume on error]   // This will catch all error s thrown and then run the speci fied rules, if any  
				<ResumeOnErrorRule>…] 
			Variables]  
				include [(persistent | auditable | user)] fields from <RelatedLink>]… 
					include [(persistent | auditable | user)] fields from <RelatedLink>]… 
						include [(persistent | auditable | user)] fields from <RelatedLink>]… 
				<RelatedField>…] 
					variable name is <LPLConstructName>] // default is the last field n ame in the RelatedF ield 
			assign message id to <FullField Name>] // mu st be of type IONOutboxQueue  
		
		cancel <RelatedValue> workflow // RelatedValue must be an WorkflowDefinitionC ode  
			message id is <FullFieldName> // must be of type IONOutboxQueue  
		(initiate <PFlowServiceName> process 
		| trigger <RelatedValue> PA service)  // RelatedValue must be a literal or PfiServiceDefinition key field  
			[resume on error]  // This will catch  all errors th rown and then run the specified rules, if any  
				[<ResumeOnErrorRule>…] 
			[title is <Message>] 
			[Criteria]  
				<RelatedField>… 
			[category filter is <RelatedField>] 
				[variable name is <RelatedValue>]  // default is the last field name in th e Rel atedFi eld 
			[Variables]  
				[include [(persistent | auditable | user)] fields from <RelatedLink>]… 
					[include [(persistent | auditable | user)] fields from <RelatedLink>]… 
						[include [(persistent  | auditable | user)] fields from <RelatedLink>]… 
				[<RelatedField>…] 
					[variable name is <LPLConstructName>] // default is the last field name in the Rela tedFi eld 
			[URLs] 
				(<HttpURL> | <LinkBack>)… // list of u rls to show for a participant of the process  
		// Maps to the ‘Folders’ concept in ProcessFlow 
		
		(cancel <PFlowServiceName> process 
		| cancel <RelatedValue> PA service) // RelatedValue m ust b e a literal or PfiServiceDefinition key field  
		
		invoke <InvocationTarget>	[in (foreground 
									| background [on <RelatedField>] 
									| background group[<Parens>(<RelatedValue>) <Parens>] 
									) 
									] 
			// <CreateAction> must be a non-parameter Create Act ion 
			// invoking a Create action using [this instance] can be used only in the context of a Create or Im port act ion 
			// RelatedField must be of type Date or TimeStamp  
			[<InvokeRule>…] 
			[<Rule>…] 
			[<ControlRule>] 
			(<InvokeRule> | <Rule>)… 
		
		invoke modify update stamp <RelatedLink> 
		
		invoke method <NativeMethod> 
		
		invoke script <RelatedValue>  // RelatedValue  is a UserScri pt ke y field value 
		
		invoke derived field <RelatedValue> // RelatedV alue must be a derived field  
		
		generate document <RelatedValue> // RelatedValue must b e ‘<NavigationName> as pdf…’  
			set using action <ActionName> // Action must have a parameter of type BinaryDocument  
			// This will generate the document in the  background and use the Act ion specified to set it on the calling instance 
		
		dbimport <RelatedField> into <BusinessClass> // RelatedField  must be of type CSVText  
		// This has the same behavior as the dbimport command except that it c an also take the 
		// standard output format of a csv-based ReplicationSet (the  ability to create, update, and delet e) 
		
		send ion bod  
			bod is <RelatedValue>   // must be  an XMLDocument  
			bod type is <RelatedValue>  // <verb>.<noun>  
			[assign message id to <FullFieldName>] // must be of type ION Outbox Queue 
			[(expect | no) acknowledgement]   // default is “expe ct acknowledgement”  
			[accounting entity is <RelatedValue>] 
			[location is <RelatedValue>] 
			[document id is <RelatedValue>] 
			[variation id is <RelatedValue>] 
			[revision id is <RelatedValue>] 
			[source is <RelatedValue>] 
			[instance count is <RelatedValue>] 
			[source is <RelatedValue>] 
			[custom property is <RelatedValue>]  // must be an IONCustom erPrope rty 
		
		send notification  
			to <RelatedValue> // must be an Actor or ActorGroup  
			description is <Message> 
			[priority is (very low | low | medium | high | very high)] // default is medium 
			[detail is <Message>] 
			[<LinkBack>] 
			[navigation is <NavigationName>] // @deprecated 20180809 
		
		send email 
			[to <RelatedValue>…] // must enter a t least one to, cc, or bcc; email addresses cannot include spaces  
			[cc <RelatedValue>…] // can have multiple to, cc , bcc address lines, each having a single address, or can enter multiple  
			[bcc <RelatedValue>…] // addresses on one line using a valid deli miter, such as a c omma or semicolon (not a space)  
			from <RelatedValue>… // repeat is for <RelatedValue> only  
			[ignore invalid addresses] 
			[subject <Message>] 
			[<Attachment>…] 
			[Attachments] 
				(<Attachment> | <ControlRule>)… 
			[<Appointment>…] 
			[Appointments] 
				(<Appointment> | <ControlRule>)… 
			Contents  
				(<Message> | <ControlRule where <Rule> is replaced by <Message>)… 
		
		link <RelatedValue> to this agent // RelatedValue must be an Actor  
		
		register new actor  
			login name is <RelatedValue> 
			password is <RelatedValue> 
			webapp is <WebAppName> 
			[registration key is <Message>] 
			[role is <RelatedValue>…] 
			[person name is <RelatedValue>] 
			[contact info is <RelatedValue>] 
		
		update actor  
			[person name is <RelatedValue>] 
			[contact info is <RelatedValue>] 
		
		PFlowService ::= (<PFlowServiceName> | <RelatedValue>) // RelatedValue must be a PfiServiceDefinition key field 
		
		Attachment ::= 
			attachment <RelatedField> 
				[name is  <RelatedValue>] 
				[mime type is <RelatedValue>] 
		
		Appointment  ::= 
			appointment <RelatedValue> 
				[send as (meeting | [appointment] message | [appointment] attachment)] // message is default  
				[name is <RelatedValue>] 
				[location is <RelatedValue>] 
				[cancel] 
				date [range] is <RelatedValue>	[(to <RelatedValue> | 
												for <RelatedValue> days | hours | minutes)] 
				[reminder <RelatedValue> days | hours | minutes] before]  
				// Must supply a globally unique appointment RelatedValue  
				// Name is ignored for message types; become s attachment name for oth ers. 
				// ‘date is <RelatedValue>’ is required for all cases. All cases also require ‘to’ or ‘for’.  
				// Meeting is sent as an emai l attachmen t prepopulated with  attendees and is only sent to the originator who can send 
				//      invites from their calendar upon opening the attachment. Must be an attachment due to calendar client limitation s. 
				// Message is embedded in the email message and is sent to each attendee. This i s the default if nothing is specified.  
				// If there is more  than one appointment that is a messa ge, only the first is embedded. The rest become attachments 
				//      due to calendar client limitations.  
				// Attachment is  sent as an email attachment to each attendee and must be opened to get into the calendar. 
		
		ResumeOnErrorRule ::= (<Rule> | cancel resume | <FullFieldName> = error message)  
		
		InvokeRule ::=  // valid under invoke rule only  
			run outside of action backgrou nd group  
			// Every top level action creat es an implicit aciton background group that, by default, all invoked actions run in. This action 
			// background group is used to define what it means for the top level action to be complete d. This syntax allows for 
			// an action to be executed in the background that is not tied to the top lev el action such that the top level act ion will be  
			// considered to  be comple ted ev en if this action is still running. All sub-actions of a top level action dynamically become  
			// a part of the action background group of the  top level ac tion. This is not true for named background groups–they have 
			// to be explicitly joined when invoked. 
			
			run after	(<FullFieldName> // must be an AsyncActionRequest KeyField / UniqueID or a named background group id  
						| current action background group 
						| action background group <FullField Name> // must be an action background group id  
						| background group <Parens><RelatedValue><Parens> 
						) 
			on error  // valid o nly when action is run in background  
				invoke <InvocationTarget> 
					[<Rule>…] 
					[<ControlRule>] 
						(<InvokeRule> | <Rule>)… 
			
			assign async action request id to <FullFieldName> // valid only wh en run in background  
			// FullFieldName can be an AsyncActionRequest KeyF ield or a generic UniqueID 
			
			assign async [action] background group id to <FullFieldName> // valid only when run in background  
			// FullFieldName must be a generic UniqueID 
			
			assign result to (<KeyField> | <ViewField> | <BusinessObjectReference>) 
			// This defaults when th e InvocationTarget is a KeyField 
			// Not valid with ‘cre ate instance’ 
			// This must be a Business Objec tReference if  the InvocationTarget is an update type of 
			// Lawson Classic Transaction. 
			// This  can be used only on a Lawson Classic Transaction if it has a business class designation . 
			
			assign message group id  to <LawsonClassicMessageGroup KeyField> 
			
			resume on error // This will catch all erro rs thrown on this action invo cation and then run the specified rules, if any  
			[<ResumeOnErrorRule>…] 
			
			fill in [blank] user fields from (parameters | <RelatedLink>) 
			
			fill in [blank] audit fields from <RelatedLink> 
			// <RelatedLink> cannot be the sam e as the invoke’s <RelatedL ink> and must be either ‘this instance ’ or 
			// ‘each(<LPLConstru ctName>)’ whe re the t arget of th e each is an audit log entry 
			
			fill in [blank] fields from <RelatedLink> 
				[except <InvokeRuleKeyword>.(<FullFieldName> | <FieldGroupName>)…] 
				// <RelatedLink> cannot be the same as the invoke’s <RelatedLink>  
			
			<InvokeRuleKeyword>.<FullFieldName> <AssignmentOp> <RelatedValue>… 
			// the way to ad dress fields  in th e <RelatedLink> that is being addressed here is to use the invoked  keyword 
			
			initialize <InvokeRuleKeyword>.<FullFieldName>… 
			
			<FullFieldName> <AssignmentOp> result.<FullFieldName> … 
			// A LawsonClassicTransaction is capable of returning result fields. The result fields are accessed using the ‘result’ keyword . 
	
	InvokeRuleKeyword ::= 	(invoked  
							| datasource // datasource key word  valid o nly when using the ‘implement xxx DataSource’ pattern  
							) 
	
	InvocationAction ::=	([<FullStateName>].<ActionName> 
							| audit create 
							| audit update // must have a RelatedLink that is an audit log entry  
							| change effective date  // must have a RelatedLink tha t is an audit log ent ry 
							| insert history  
							| delete history  
							| change create date 
							| purge audit log entries 
							) 
	
	InvocationTarget ::=  <InvocationAction>	[ (<RelatedLink> 
												| <BusinessClass> // must be a Set Action (co nstruct also option in  
													// <RelatedLink>, but restated here for emphasis 
													// and Set Actio n exception  
												| <BusinessTask> // any action on a Busine ssTask 
												| <LawsonClassicTransaction> 
												| <M3Interface> 
												| <WebserviceInterface> 
												| <StaticJavaPD> 
												) 
												] 
	
	FieldRules ::= 
		<FullFieldName> // Field name ca n have tem plate operator in it '<A>'; if it does then ru les can have matching template  operator 
			<Rule>… 


Field Rules  
	[(merge | replace) specifications] // valid only for lhf LPL , merge is default  
	<FieldRules>… 


Translation Field Rules  
	[(merge | replace) specifications] // valid only for lhf LP L, merge is default  
	<FieldRules>… // Rules  that get ‘fired’ when this field’s translatio n is change d (this include s Create and Delete)  


SubType <RelatedCondition> Field Rules  
	[(merge | replace) specifications] // valid only for lhf LPL , merge is default  
	<FieldRules>… 


Commit Rules  
	<Rule>… // Rules that get ‘fired’ just before the final ‘commit’ p oint of any transaction.  
	// Commit Rules do not get fir ed when a RequestAction is initiated; th ey get  fired when i t is completed.  
	// Commit Rules do n ot get fired when a future ef fective -dated tra nsaction is initiated; they get fired w hen 
	// the  transaction be come s effective.  


Audit Entry Rules 
	<Rule>… // Rule s that get ‘fired’ just b efore a n audit log entry is created. Multiple audit log entries can be cr eated in a single  
	// transaction if the effective date has been changed in the lo gic of the transaction. 
	// Audit Entry Rules do not get fired when a Reques tAction is initiate d; the y get f ired when it is completed. 
	// Audit Entry Rules DO get fired wh en a future effective- dated transacti on is initiated; they  DO NOT get  fired  
	// when  the transaction becomes effect ive. 


Apply Pending Effective Rules  
	<Rule>… // Rules  that get ‘fired’ when a pending effe ctive -dated transaction is applie d (whe n it be comes ‘ effective ’) 


Create Rules 
	<Rule>… // Rules that get ‘fired’ when  any Create type a ction is executed  


Create Exit Rules  
	<Rule>… // Rules that get ‘fired’ after any Create type actio n is executed 


Update Action Rules  
	<Rule>… // Rules that ge t ‘fired’ when any Update type action is executed  


Delete Rules  
	<Rule>… // Rules th at get ‘fired’ when any Delete type action is executed  


Translation Rules  
	<Rule>… // Rules that get ‘fired’ when any translatable field’s translation is c hange d (this inclu des Cr eate and Delete)  


Action Exit Rules  
	<Rule>… // Rules that get ‘fired’ on the exit of all actio ns (except  Set Ac tions) defined on this business class  


Attach Rules  
	<Rule>… // Rules th at ge t ‘fired’ whe n another business obj ect is seeking to ‘attac h’ itself to this object  
	// Only rules that are v alid in all contexts. Any con straint ru le mean s that attachment of calling object is not allowed. 
	// No  <Field Rules> 


Parent Attach Rules 
	<Rule>… // Valid o n Parent Hierarchy only. R ules that get ‘fired’ when a child attempts to a ttach to a parent.  
	// Only rules that are val id in all contexts . Any constraint rule means that attachm ent of calling object is not allowed. 
	// Rules within P arent Attach Rules can use the ‘child’ related  link to access the attaching child business class. 
	// No <FieldRules>  


Dynamic Creation Rules  
	<Rule>… // Rules that get ‘fired’  when a Dyn amic Creation is about to occur  
	// Any const raint rule means that Dynam ic Creation d oes not occu r and an exception does occur. 
	// Both Atta ch Rules and Dynamic Creation Rules can addres s contextual infor mation about the busi ness class  
	// that is causing  these rules to fire throug h the special vari able datacontext. 


Rule Blocks 
	<RuleBlockName>… // Blocks of r ules that can be included (copied) in m ultiple  places in the LPL code  
		<Rule>… // The block of rules is copied into place during compilation when an ‘include <Rul eBlockName>‘ rule is used . 
	// Rule Blocks can contain replacement variables; these are LPLConstructNames bounded b y curly braces.  
	// If a Rule Block contains repla cement variables, all of those variables must be re placed when including the Rule Block 
	

States and Actions  
	// State definitions are optional. If States are defined, Actions can be define d within States o r outside of the State definitions (mea ning for al l States). If n o 
	// Actions are defined, the action s Create, Update, and Delete are au tomat ically genera ted. I f any actions are defined, one of them must be a C reate type  
	// of action (it is ok to not be able to update or delete a business objec t but if it can nev er be created, there isn’t much point in de fining it in the first place).  


StateCycles 
	<StateCycleDefinition> 
	
	StateCycleDefinition ::= 
		<StateCycleName> is a StateCycle 
			[state field is <persistent FieldName>] // default is <Stat eCycl eName> + State  
			[initial state is <StateName>]  // default is first state definition  
			<StateDefinition>… 
	
	StateDefinition ::= 
		<StateName> is a State  
		Entrance Rules 
			<Rule>… 
		Exit Rules  
			<Rule>… 
		Field Rules  
			[(merge | replace) specifications] // valid only for lhf LPL , merge is default  
			<FieldRules>… 
		SubType <ConditionName> Field Rules 
			[(merge | replace) specifications] // valid only for lhf LPL , merge is default  
			<FieldRules>… 
		[<EventHandler>…] 
		[<ActionDefinition>…] 
		[<StateCycleDefinition>…] 
		
		// A StateName must be unique within another St ate. StateCycles do NOT p articipate in  the nam e scoping of States. Therefore, if there is a state ‘Open’ that has two 
		// StateCycles (‘Appro valCycle’ and ‘NotificationCycle’) the StateNames within those tw o StateCycles must be unique. This allows a State to be fully identifie d 
		// via its upper StateNa me. In this  example if ApprovalCycle has a State ‘NeedsApproval’ then it can be address ed usin g ‘Open.NeedsApproval’. A StateName 
		// address need not be fully qualified as long as it can be unambiguously resolved. 


Actions 
	(<ActionDefinition> | <EventHandler>)… 
	
	ActionDefinition ::= // When you specify any actions in the action  block, you mus t also SPECIFICALLY include the following action if you 
	// want them available:Create is an Action, Update is an Action, Delete  is an Action  
		<ActionName> is a[n] [<ActionType>] [Request]Action 
		// A blank ActionType means Instance Action unless  ActionName is the same as ActionT ype. 
		// If Action Name == ActionType, ActionType = ActionName 
			[<DefaultLabel>] 
			[privileged] 
			[action tag is <ActionTag>]… 
			// When an audit log entry is created all the action t ags of all th e actions in  the execution path 
			// are  put on the audi t log entry. This is useful for determining a re ason for why an audit log entry 
			// exists.  
			[completion message is <Message>] 
			[no records message is <Message>] // valid on Set actio ns only 
			[workflow event title is <Message>] // valid on Reques t actions  only 
			[valid when <Condition>] 
				[<Message>] 
			[restricted]    // can be invoked  only; cannot be executed via UI  
			[(restrict | enable) action on lists] // overrides business class default  
			[(refresh and | lazily) lock this instance] // valid on Instance, Update, Delete, and Purge acti ons only 
			[(enable | disable) ImmutableContextCache] // disabled by default unless enabled in Product Line Definition  
			[bod type is  <Literal>]  // valid on Import actions onl y ‘<verb>.<noun>’  
			[bypass field rules]  // valid on  Create and Update action s only 
			[bypass relational  integrity rules]  // valid o n Delete  and Purge actions only  
			[use array in sert]  // valid o n Create actions only  
			[manual update]  
			[disable checkpoint]  // Set Actions only―disables restart logic; implies allo w unlimited concurrency  
			[subject is <Subject>] 
			[effective date required] 
			[reason code required]  
			[action comment required]  
			[request action process is <PFlowServiceName>] 
			[request action linkback webapp is <WebAppName>] 
			// The main <LinkBack> syntax declares a linkback with its associated parameters (in parens). 
			// This statement modifies an implicit ‘linkback w ebapp is’ statement. 
			[disable RetroactiveEffectiveDating]  
			[disable resume on error]  
			[disable multiple instance selection]  // Do not allow multiple records to be selected on a list for this action 
			[confirmation required]   // Causes the user to conf irm they want to execute this action  
				[<Message>] 
			[run in (foreground | background)]   // Overrides default run mode – valid on Instance and Set Action only  
				[[initial] schedule concurrency is	(FullConcurrency // valid only on run in background  
													| NoConcurrency  
													| NoActionGroupC oncurrency)] 
				[[initial] misfire strategy is	(DoNothing  // valid only on run in background  
												| RunOnce  // default is DoNothing  
												| RunAllP rocessesScheduled)] 
			[allow anonymous access]   // Allows th e ‘an onymous’ user to execute this action  
			[allow user fields  [from <BusinessClass>] as parameters]… 
			// Allows user fields to be placed on the ActionForm during configuration. 
			// User fields from multiple business classe s may be used as parameters 
			// These user field paramet ers can be used in the inv oke rule ‘ fill in user fields from parameters’ 
			[synchronized [on <Message>]] // enforced only on actions run in the background  
			// If using a tra nslatable field in the message , must force the locale to  be blank 
			[allow unlimited concurrency] // valid on Set actions only―implicit with ‘disa ble chec kpoint’ 
			
			Queue Mapping Fields 
				<RelatedField>…  // can have up to two Queue Mapping Fields  
			
			Set Is   // valid on Set actions only  
				<RelatedValue>… 
	
			Parameters   // valid on  Create, Instance, and Set actio ns 
				<FieldName> [<DataDefinition>]… 
					[<States>] 
					[<DefaultLabel>] 
					[holds pii]  
					[scannable]  
					[as of <RelatedValue>] 
					[within <RelatedValue>] 
						[<Message>] 
					[[exact] version is <RelatedValue>] 
					[precision is <RelatedValue>] 
						[round to precision] 
					[old value is <RelatedValue>] 
					[<TextVariables>] 
				<FieldName> is a[n] <BusinessClass> view 
	
			Parameter Rules 
				<parameter FullFieldName> 
					<Rule>… 
	
			Local Fields 
				// same definition as on Business Class  
	
			Results   // valid on Set actions only 
				(<FieldName> | <BusinessClass> view)… 
 
			Field Rules   // valid on Create and Update actions only  
				[(merge | replace) specifications] // valid only for lhf LPL , merge is default  
				<FieldRules>… 
			
			SubType <ConditionName> Field Rules // valid on Create and Update actions only  
				[(merge | replace) specifications] // valid only for lhf LPL , merge is default  
				<FieldRules>… 
			
			Accumulators 
				<FieldName> [<DataDefinition>] 
			
			Instance Selection [<AsOfOperator>] // valid on  Set actions only  
				[include [only] deleted records] 
				where <Condition> 
			
			Sort Order [is (<SetName> | primary)]  // valid on  Set A ctions only 
				<RelatedField>… 
					[is transaction boundary] 
			
			Action Rules   // Rules for entire set if a Set Action – otherwise just the rules for this instance 
				<Rule>…  // valid on a non Set Action only - constraint type rules as well as action  rules 
				// can be placed here – constraint rules constrain whether the action takes place or not 
				Empty Set Rules // valid on Set actions only  
					<Rule>… 
			
				Set Rules  // valid on Set actions only  
					Entrance Rules  
						<Rule>… 
 
					Exit Rules 
						<Rule>… 
 
				<sort FullFieldName> Set Rules…  // valid on Set actions only  
					Entrance Rules 
						<Rule>… 
				
					Exit Rules  
						<Rule>… 
 
				Instance Rules // valid on Set actions only  
					<Rule>… 
				
				Entrance Rules // Rules to be e xecuted prior to the Action  Rules – this is primarily use ful for delete actions  
					<Rule>…  // because in a delete action the reco rd is deleted bef ore the Acti on Rules fire 
				
				Exit Rules  // Rules to be executed up on exit of the Action  – this is primarily useful for create actions  
					<Rule>…  // because in a create action the record is created after the Action Rules fire  
 
				InitiateRequest Rules  // valid on RequestAction only  
					<Rule>…  // Rules are executed when  the action request is initiated 
				
				UpdateRequest Rules // valid on RequestAction only  
					<Rule>…  // Rules are executed when the action request is updated  
				
				CancelRequest Rules // valid on RequestAction only  
					<Rule>…  // Rules are executed when the action request is canceled (rejected or withdrawn)  
				
				Rule Blocks  
					<RuleBlockName>… 
						<Rule>… 
 
ActionType  ::=	(Create // Creates new record s and fires all field  rules 
				| Update // Updates record and fi res all field rules  
				| Delete // Virtual delete. Marks record as ‘deleted’. Does not physic ally remove recor d from database.  
				| Purge // Physical delete. Removes record from  database. 
				| Preview // Similar to an update but it does not fire field ru les and does no t actually updat e record 
				| Instance // Does not run field rules but does update rec ord 
				| Set // Run s rules on a set of records  
				| Import // Implicitly runs in the context of a new insta nce but does not impl icitly  save that instance  
				) 
 
EventHandler  ::= 
	on	(<FullStateName>.<ActionName> 
		| entrance to <FullStateName> 
		| exit of <FullStateName> 
		) 
		Action Rules 
			<Rule> 
 
ActionOverride  ::=  // valid on configuration only  
	[<FullStateName>.]<ActionName> is an ActionOverride 
		[<DefaultLabel>] 
		[effective date required] 
		[reason code required] 
		[action comment required]