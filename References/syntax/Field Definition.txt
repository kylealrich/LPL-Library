Field Definition  
// Field files have an extension of .field or .keyfield  
 
Field Structure ::=  
<FieldName> is a (Field | KeyField)  
	[owned by <ModuleName>] 
	// if not defined then field is g lobal and put in the ‘field’  package 
	[(<SqlName> | <SqlPrefix>)] 
	// SqlPrefix is for Group Field onl y; SqlName not valid on a Group F ield 
	// Every dup licate group field type instantiation in a B usiness Class or GroupField requires a ‘prefix is’  
	// predicate.  This lets us add the prefix to all th e group field names. Currently, the kludge for the prefix  
	// on a GroupField instantiation in  a Business Class is sql prefix is XXX  
	[<ClassicName>] 
	[<DefaultLabel>] 
	[text searchable]  
	[scannable] 
	[holds pii] 
	[default filter operator is (contains | starts with | equals)]  
	// valid  only on a SimpleField (not a GroupField or ArrayField) and alpha field types 
	
	[extends <FieldName>] 
		[member of <extended FieldName> peer group] 
	// ‘extended FieldName’ must be a super key fi eld of this key field – that is, this key field must extend it.  
	// A ‘ peer g roup’ of KeyFields is a set of KeyFields that are all su rrogates of each other where the surrogate 
	// values are all identical. If ICCompany extends GLCompany and POCom pany exten ds GLC ompany, and if ICCompany 
	// and POCompany are members of the GLCompany peer group, then ICCompany acts as a surrogate for POComp any, 
	// where  the POCompany value is equal to the ICCompany value. 
		[(delete cascades | delete ignored)] 
	// valid on a K eyFiel d with a business class only - defaults to delete restricte d 
		[name is <Literal>] 
	// If a field exte nds another field, it cannot specify a new repre sentation. Both KeyFields and Fields can be 
	// extended . An extended Key Field typically specifie s an additional business class that contains  the part icular  
	// instances of the new KeyField although this i s not re quired. An extended Field typical ly sets some context  
	// variable of the base Field.  
	// An example of a  KeyField being extended with a new business class is Company. Company might b e extended 
	// as a new field called APCompany with a business clas s of A pCompany. If the business class for Company is  
	// Glsystem, each instance of an ApCompany must also be an instance of a Glsy stem, whereas each instance of 
	// a Glsystem might not be an instance of an ApCompany. 
	// An example of a KeyField being extended without a new business class being defined is PersonnelCode. 
	// PersonnelCode has a Context variable called PCode Type a nd it might be extended as a new field called 
	// LocationC ode with PCo deType set to P CodeType.Location (one of its states). 
	// An exa mple of a Field being extended is Currency Value. CurrencyValue has a context variable called IsRate 
	// and might be extended as a new field called CurrencyAmount with IsRate set to false.  
	Representation  
	Ontology  
	Patterns  
	Display Fields  
	Surrogate For  
	Context Fields  
	//The syntax definitions for  the following s ections in the Field structure are  the same as their counterparts in the Business Class st ructure . 
	//Refer to the Business Class Definition section for their syntax.  
	Transient Fields   // valid on group or array fields only  
	Local Fields   // valid on group or array fields only  
	Derived Fields   // valid on group or array f ields only 
	Conditions   // valid  on group or array fields only  
	Cube Relations   // valid on group or array fields only  
	Columnar Relations   // valid on group or array fields only  
	Relations   // valid on group or array fields only  
	Rule Blocks  
	Field Rules
	
Representation  
	[<FieldRepresentation>] 
	// A KeyField migh t not have a representation. This is usef ul when the KeyField is the  symbolic key of a business 
	// class that implements the  Specialization pattern. The field  can still be put as a Persistent field in a business cl ass 
	// to dynami cally refe rence the appr opriate rela ted Specialization. 
 
	FieldRepresentation ::= 
		( <SimpleField> 
		| <GroupField> 
		| <ArrayField> 
		) 
	
	SimpleField ::= 
		type <DataDefinition> 
			[precision is <RelatedValue>] 
				[round to precision]  
		[<States>] // <States> is  not indented under type because indentation implies som e form of ownership or deta il declaration . 
		// In this case, <States> describes the F ield’s de fintion a nd not the Representation’s defintion. 
	
	GroupField ::= 
		Group Fields 
			<FieldName> [<DataDefinition>] 
			[<States>] 
			[<SqlName>] 
			[<ClassicName>] 
			[<ClassicNameForField>] 
			[<SqlNameForField>] 
			[<DefaultLabel>] 
			[text searchable]  
			[scannable] 
			[encrypt]  
			[holds pii]  
			[enable alternate document location] // valid for BinaryDocum ent, BinaryObject, CSVText, JSONObject,  
				[document is <RelatedField>]  //     RichText, Text, TextDocument , and XMLDocument fields only  
				[existence is <RelatedField>]  // Must be a Boolean type field  
			[disable Au diting [when in background]]  // Field will not be audited  
			[disable EffectiveDated]  // Field will not pa rticipate in EffectiveDated pattern  
			[enable EffectiveDated]   // Field will participate in EffectiveDated pattern  
			[automate context] 
			[disable surrogates] 
			[allow images]   // valid for RichText fields only  
			[(delete cascades | delete ignored)]  
			[translatable]    // allows for data translation for this field  
			[restricted]   // cannot be used as field on UI  
			[protected]  // application -controlled field;  cannot be updated from the  UI, webservices, or spreadsheet  
			[precision is <RelatedValue>] 
				[round to precision] 
			[primitive type is <RelatedValue>]// must be of  type ‘PrimitiveType’; cannot be Text or BinaryDocument/Image  
			[primitive size is <RelatedValue>] 
			[primitive decimal size is <RelatedValue>] 
			[create value is blank if no entry] 
			// If a field is added after a record is cre ated, typically  the fir st value in the audit log applies as the value from  
			// the point of cre ate. With this pattern, the value from create will be considered blank 
			[as of <RelatedValue>] 
			[within <RelatedValue>] 
				[<Message>] 
			[[exact] version is (<RelatedValue> | latest)] 
			[data area is <RelatedValue>]  // valid only when stored in an environment  busclass 
			[is (condition | related (link | value)) for <RelatedValue>] 
				[(dimensions  [with attributes] | measures) only] // RelatedValue must be a BusinessClass name 
			[<TextVariables>] 
			[document template  [for <BusinessClass>]] 
			// if within a Gr oup the n just ‘document template’ c an be specified genericall y. Thi s will re quire 
			// that wherever this  group field is used a specific document template for BusC lass is specified  
			[store as BusinessObjectReference] 
				[<SqlPrefix>] 
	
	ArrayField ::= // Arra yField is valid on both keyfield and fields  
		<FieldName> [<DataDefinition>] 
			occurs (< Literal> | sizeofarray <Arr ayField> | unlimited) times 
				// unlimited is valid for local fields only
	
Ontology 
// valid on key fields only  
	[stereotype is <Stereotype>] 
	business class is <BusinessClass> 
	// This  is the  business class that contains the instances of this KeyField . 
	// This busines s class must spec ify this KeyField as its symbolic key.  
		[existence not required] 
	
	Context 
		// The ontological context def ines the affor dance structure. Typically there is only a sing le KeyField in a n 
		// affordance structure. If the  singl e Keyfiel d itself has an affordance c ontext KeyField, that KeyField  is also  
		// implicitly part of this KeyField ’s affordanc e structure. If  there are two  KeyFields in  an affordance context, it  
		// mea ns that the seco nd one is not afforded by the firs t one, therefor e there i s a dual affordan ce structure. The 
		// first key can be a surrogate for the higher level context o f the se cond key. 
		<KeyField> 
			[version is (latest | exact)] 
			// A versioned Context field will automatically have its version fie ld included in the ontology unless 
			// ‘version is latest’ is specified  
			[value is <RelatedValue>] 
			// A Context key can be set to a speci fic value. Typically th is only happen s when the key is extend ing another 
			// key that  has this Context key. An example is BargainingUnit, which extends Pcode and sets Pcode’s  
			// Pcod eType co ntext to ‘BU’.  
			[delete ( restricted  // default 
				| cascades 
				| ignored 
				) 
			]
			[disable surrogates] [context of <FullFieldName>]… 
			// This can be used to disambiguate which field on this business class should be used as the Context field for this KeyField  
			[optional] // If one of the Conte xt Keys  is optional, there must be a higher level Context Key specified even  though 
			// the first Context Key implicitly refers to it.  This make s it clear that th is KeyField can b e afforded at both  
			// leve ls and allows for the de lete rule of the higher Context K ey to be specified. This highe r level Context  
			// Key that is not opt ional is the group level k ey; this is the key level at which effecti ve dating is done when 
			// effectiv e date as a group is specified in a Specialization pat tern. 
			[data area is <RelatedValue>] // valid only when in a ‘stored in environment’ busclass  
			[(enable | disable) surrogate context]  
			// enable is the default  
			// If a c ontext KeyFi eld has a surrogate, by default this surro gate field is put on th e business class 
			// and a secondar y inde x is created so that this field can  be validated from either th e primary context  
			// or the s urrogate c ontext.  
			// If a K ey Field extends anot her key field the default name of that key field i s the highest level fie ld name in the  
			// exte nds chain. Thi s can be overridden with a ‘name is’ cl ause. I would like to nuance this situation such that when 
			// a key  field extends another key field but ha s a cont ext value set, then that field should have a default ‘name is’ of the  
			// key field name  itself.  
			[within <RelatedValue>] 
				[<Message>] 
			// valid on a KeyField only; <RelatedValue> mus t be a field  referenced via  a OTM relation that def ines a set of KeyFields  
			// of this KeyField’s ty pe. <Message> is a n optional error message. 
	
	Stereotype ::= ( Agent 
		| Business Policy 
		| Document 
		| DocumentAccounting 
		| DocumentDistribution 
		| DocumentFulfillment  
		| AccountingTransaction  
		) 
		// Stereotypes are grouped into two classes:  transaction and non -transac tion. The Transaction ster eotypes are  
		// Document, DocumentDistribution, DocumentFulfillment, and AccountingTransaction. 
		
Patterns 
	[disable StaticTranslations] 
	// All <Message> definitions will not participate in Translation pr ocesses  
	// There will be no  <Fiel d>Bundle.properties file for the BL or the U I in the resource language packs 
	// Conversion of <LiteralMessage> to resour ce string will still take pla ce 
	
	[implements  AccessInitializer] 
		initializer is <FieldName> 
		// Val id for Group and Array fields only  
		// FieldName must be a DerivedF ield within this Field  
	
	[implements MutuallyExclusive] 
		field determiner is <RelatedField> 
			<StateName> field is <FieldName>… 
	// valid in a GroupField only. This pattern causes the GroupField to behave as though it is onl y a 
	// single field that has a dynamic type . The single field within the Group Field is determined by th e 
	// defined ‘field deter mine r’ <RelatedField> which mu st be a s tate field.<StateName> mus t be a defined 
	// state on <RelatedField>. All states on RelatedField must b e specified.  
	// For some u nknown reason MutuallyEx clusive fields get a default delimite r set (see C ompactFormat ). 
	
	[implements FieldRange] 
	from is <FieldName> 
	[exclusive]  
	to is <FieldName> 
	[exclusive] 
	// This  pattern is valid in a GroupField only. A from value of blank means low- value and a to value of blank 
	// high-value. To must always be greater than from. Inclusive is the default.This designation al lows 
	// the ‘within’ operator and the ‘overlaps’ operator to be used wi th this field.  
	
	[implements CompactFormat] 
	[delimiter is <Literal>] 
	[format fields  based on primary form] 
	// This pattern allows a GroupField or an ArrayF ield to be  entered as a single string, each f ield 
	// being delimited by the designated delimite r. An implication of this is that the  delimiter is not 
	// allo wed as a character within any of the me mber or o ccurring fields. Th e default delimiter is a double-hat ‘^^’. 
	// The format (order, visibility , and so on)  of the fields can be based on the prim ary form  
	
	[implements User DefinedStates] 
	// This  pattern tre ats this key field as though it has a list of States – only the state  values are not hard-coded 
	// but rathe r defined within the instances of the business class. There ar e two key implications of this: one is that 
	// the number of instances i s expected t o be s mall and the field s hould be treate d just as a hard-coded fie ld 
	// that has states on it is in the UI – that is – it sho uld use a drop-down s elect to  allow the user to choose a 
	// value rath er than a larger select window. 
	
	[implements ArrayHierarchy]  
	// This pattern causes an Ar ray KeyFi eld to be treated as a Hie rarchy of Keys  
	// This is valid  only on an Array KeyField a nd currently all Arra y KeyFields must implement this pattern.  
	// Wh en a node in an Array Hier archy i s deleted all su b-nodes will  be de leted as well – it is an i mplicit 
	// delete  cascades. 
	
	[implements ParentHierarchy] 
	[parent field name  is <FieldName>] 
	[<ClassicName>] 
	[descendants are <RelatedLink>] 
	// Related Link m ust point back to this BusinessClas s and end in a OTM relation 
	// A ParentHi erarchy is a Hiera rchy managed by havin g a ‘par ent field’ (which is a KeyField referen ce of 
	// this symbolic ke y) put on the business class that thi s symbolic key is define d for. 
	// The parent field name defaults to ‘Parent<KeyField>‘. 
	// When  a node in a Parent Hierarch y is deleted all sub-nodes wi ll be deleted as well – it is an implicit 
	// delete cascades.  
	// descendants operator can be optim ized by overrid ding it with ‘descendants are… ’ - this requires you to  create a ‘shadow’ 
	// table that flatte ns the structure 
	
	[implements Versioning] 
	version field is <FieldName> 
	[<ClassicName>] 
	// This pattern cause s the symbolic key’s bus iness class to be versioned using the designated version field.  
	// The versi on field is often  of type Dat e but can also be other field types, fo r example a Number. 
	// A field of ty pe FieldName will be add ed to the business class and also be put at the bottom of the  
	// primary index. 
	
	[implements Specialization]  
	[control valid key values]  
	// When the valid key values are controlled then there must exist a key value at th e non-optio nal 
	// key level before i t can be specialized. If the highest ke y value i s deleted then al l of the specializations  
	// are  also dele ted (delete cascades). Delete restr icted and delete ignored ar e not supported.  
	// If this is not specified then  the key va lues of the specializations are uncontrolled. A ke y valu e can  
	// be added at some specializa tion level without a higher le vel value being present. 
	[effective date as a group] 
	// Valid only when EffectiveDated pattern is implemented. 
	// This o ption cause s the set of specializat ions to be effective dated  as a group. 
	[set retrie val is inclusive] 
	// Exclusive is the default. Inclusive m eans that the higher level ‘special izations’ are included as part of the  
	// lower level specializations. An example of this is JobQual ifications. Th e company level qualific ations are  
	// considered to be part of the job -specific qualifications.  
	// If any  Context Key is op tional, the Speci alization pattern can be specified. The specialization  pattern  
	// allows a single r eference to the KeyField to se arch the business class for th e appropr iate business object. 
	// The appropriate business object is the one that is the most ‘specialized’ based on what k eys are optional.  
	// The least specialize d object is one where all the optional keys are blank. The m ost specialized object is 
	// one where all the optional keys are f illed in. It searches most specialized to least specialize d. If the optional 
	// keys a re strictly hie rarchically related based on their ontology, the search algorithm blanks optional key 
	// values starting from the lowest optional key and moving toward the highest optional key. If the optional 
	// keys are not hierarchically relate d, the search algorithm will similarly work fro m lowest to highest key, 
	// howe ver it will put values back into the lower keys. For example, given keys k1, k2, k3 with k2 and k3 optional 
	// and not hierarc hically re lated, the search pattern is (k1, k2, k3), (k1, k2, blank), (k1, blank, k3), 
	// (k1, bla nk, blank). 

Display Fields 
// valid on key fields only 
	<RelatedField> // These are the ‘des cription’ or ‘name’ fields for t his key. T hey are the ‘human’ names we give t hings, such 
 // as company name, employee name, and so on 

Surrogate For  
// valid on key fields only  
	<FieldName> value is <RelatedField> 
 
// The Cont ext Fields  section declares a new ’non-ontological’ context field. Non -ontological context field s are not required to be in the context. They are also  
// evaluated  newly each time the field  is used. Context rules are not automatically arranged for execution as are Field Rules. The order they are in i s the order 
// in which the y are executed.  
 
// Special considerations for fie ld addr essing, or what does the ‘.’  operator do when used with a Ke yField, G roupField, or ArrayField. 
// On a KeyField – the ‘.’ operator automatically addresses all the elements on the business class that the KeyField is centered  on. 
 
// If KeyField APCom pany is a subtype of another KeyField  Com pany then in order to addr ess field s on the business class Co mpany from APCompany you 
// say ‘APCompany.Company.FieldName’ 
// Similarly in  order to address fields on  APCompany from Company you say Company.APCompany.FieldNa me. 
 
// On a Gro upField – th e ‘.’ operator or any Fiel d refe rence in a busines s class can reach  through a GroupField or an ArrayField and address a Field 
// on the GroupFie ld if the re ference results  in an unambiguous targe t. If Address is a GroupFi eld that ha s a GroupFie ld called Po stalArea, which in turn 
// contains City,  State, and Zip, the Refer ence Address.City reaches through the GroupField PostalArea to find its target. It also r eaches through an 
// ArrayField. It d oes not reach through KeyF ields to th e KeyField’s  business class. If Address is on the busine ss class Vendor, any rule on Vendor can 
// directly address ‘City’ and it does reach through both Address and PostalArea to find ‘City’.  

Context Fields  
// These are ‘non-ontological’ context variables 
	<ContextField>… 
	
	ContextField ::= 
		<FieldName> [<DataDefinition>] 
			[[exact] version is (<RelatedValue> | latest)]  
			[<ContextRule>…] 
	
	ContextRule ::= 
		<RelatedField> <AssignmentOp> <RelatedValue>  //Assignment Rule  
		
		default to <RelatedValue>… // Multiple fields ca n be put on a default. If the first one is blank the second one is used and so on.  
		// Only the last one can be a literal value. 
		constraint <Condition> 
			<Message> 
		
		required 
			[<Message>]  // defaults to ‘Field is  required’ 
		
		if <Parens><FieldName> <ContextOperator><Parens> 
			<ContextRule> 
		[else 
			<ContextRule>]
		
	ContextOperator ::= ( in context
						| entered
						)