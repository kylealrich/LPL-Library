WorkOrderItem is a BusinessClass
	owned by wo
	prefix is WOI
	classic name is WOITEM

	Ontology
		symbolic key is WorkOrderItem
			classic set name is WOISET1
			classic name is COMPONENT-SEQ
			classic name for InventoryLocation is LOCATION
			classic name for WorkOrder is WORK-ORDER

	Patterns
		implements StaticJava
		disable AuditIndex

	Persistent Fields
		ComponentType
		Item
		Location					is an InventoryLocation
		PlanQuantity				is a Quantity
		ActualQuantity              is a Quantity
			classic name is ACTUAL-QTY
		ActualCatchWeightQuantity   is a Quantity
			classic name is ACT-CTW-QTY
		PickedQuantity              is a Quantity
			classic name is PICKED-QTY
		DetailQuantity              is a Quantity
			classic name is DETAIL-QTY
		CatchWeightQuantity         is a Quantity
			classic name is CATCH-WT-QTY
		DetailCatchWeightQuantity   is a Quantity
			classic name is DTL-CTW-QTY
		WasteAccount                is a FinanceCodeBlock
			classic name for WasteAccount.AccountingUnit is WST-ACCT-UNIT
			classic name for WasteAccount.GeneralLedgerChartAccount is WST-ACCOUNT


		WasteQuantity               is a Quantity
			classic name is WASTE-QTY
		WasteCatchWeightQuantity    is a Quantity
			classic name is WST-CTW-QTY
		EstimatedComponentCost		is an InternationalCost
			classic name is EST-COMP-COST
			protected
		ActualComponentCost			is an InternationalCost
			classic name is ACT-COMP-COST
			protected
		PickedCost                  is an InternationalCost
			protected
		TotalActualCost             is an InternationalCost
			classic name is TOT-ACT-COST
			protected
		TotalWasteCost              is an InternationalCost
			classic name is TOT-WASTE-COST
			protected
		QuantityTolerancePercentage
			classic name is QTY-TOL-PCT
			protected
		ZeroQuantity                is Boolean
			classic name is ZERO-QTY-FL
			protected
		WalkThruRequired			is Boolean
			classic name is WALK-THRU-REQ
			protected
		MaterialExpenseAccount      is a FinanceCodeBlock
			classic name for MaterialExpenseAccount.AccountingUnit is ME-ACCT-UNIT
			classic name for MaterialExpenseAccount.GeneralLedgerChartAccount is ME-ACCOUNT
		MeSubAcct                   is Numeric size 4


	Local Fields
		LocalUnitCost							is like UnitCost
		TempUnitCost							is like UnitCost
		LocalOutputUnitCost						is like UnitCost
		LocalEstimatedComponentCost				is like UnitCost
		LocalOriginalEstimatedComponentCost		is like UnitCost
		LocalOriginalEstimatedPackingCost		is like UnitCost
		LocalEstimatedPackingCost				is like UnitCost
		LocalOldBurdenCost						is like UnitCost
		LocalNewBurdenCost						is like UnitCost
		LocalInputCost							is like UnitCost

		LocalOldLocation						is like InventoryLocation
		LocalOldPlanQuantity			    	is like Quantity
		InventoryCostHistoryRemainingQuantity 	is like Quantity
		InventoryCostHistoryQuantity    	  	is like Quantity
		LocalQuantityChange			    		is like Quantity
		LocalQuantity			    			is like Quantity
		LocalPlanQuantity			    		is like Quantity
		LocalOutputQuantity						is like Quantity
		LocalPrintedQuantity		         	is like Quantity
		LocalBackorderedQuantity   			    is like Quantity
		LocalOldUsedQuantity					is like Quantity
		LocalPlanExpQuantity					is like Quantity
		LocalInputQuantity						is like Quantity
		LocalPlanAllocatedQuantity				is like Quantity
		LocalUsedQuantity						is like Quantity
		LocalUsedOldQuantity					is like Quantity
		LocalTolerance							is like Quantity
		LocalPrintChange    					is like Quantity
		LocalInProcessQuantity					is like Quantity
		UOMCalculation
		LocalWarn								is Boolean
		LocalCompError							is Boolean
		LocalUpdateWarehouseDemand				is Boolean
		LocalCreateWarehouseDemand				is Boolean
		LocalBackordered						is Boolean
		LocalActualCost							is like  InternationalCost
		InventoryCostHistoryCost              	is like  InternationalCost
		TotalInventoryHistoryCost				is like  InternationalCost
		LocalWorkOrderBurdenPercentage			is Percent size 5.2
		LocalOldItem							is like Item
		LocalSubstituteItem						is like Item
		LocalReverseByWorkOrder					is Boolean
		NewWorkOrderItem						is a WorkOrderItem view
		LocalWorkOrderItem						is like WorkOrderItem
		LocalInventoryTransaction				is like InventoryTransaction
		LocalInventoryTransactionLine			is like LineNumber	
		NewInventoryTransactionLine				is an InventoryTransactionLine view
		LocalDistributionAccount				is like TransactionCodeBlock
		LocalAmount								is an InternationalAmount
		LocalPostingType						is AlphaUpper size 2
		LocalActualQuantity						is like Quantity
		LocalWasteQuantity						is like Quantity
		InventoryCostDefault
		LocalDetailQuantity						is like Quantity
		LocalInputUOM							is a UnitOfMeasure
		LocalCatchWeightQuantity				is like Quantity
		LocalOldActualCatchWeightQuantity		is like Quantity
		LocalSecondaryQuantity					is like Quantity
		LocalConfigurationParameter				is Alpha size up to 200
		
	Derived Fields
		DerivedWorkOrderItem is a DerivedField
			type is Text
			if (WorkOrderItem exists)
				return WorkOrderItem
			else
				return blank

		DerivedQuantity									is a DerivedField
			type is like Quantity
			if (WorkOrder.IsExplodedOrInProduction)
				if (ActualQuantity entered)
					return ActualQuantity
				else
					if (PickedQuantity entered)
						return PickedQuantity
					else
						if (PlanQuantity entered
						and !ComponentType.Offsite)
							if (WarehouseDemandLineRel exist)
								return WarehouseDemandLineRel.AllocatedQuantity

		OffsiteMessage									is a MessageField
			restricted
			"IncomeStatementsAccountsNotRequiredForOffsiteComponents"

		NotOffsiteMessage								is a MessageField
			restricted
			"MaterialExpenseAccountMustBeSpacesForNonIncomeStatementAccounts"

		ExpenseAccountErrorMessage						is a DerivedField
			type is MessageField
			restricted
			if (ComponentType.Offsite)
				return OffsiteMessage
			else
				return NotOffsiteMessage

		ToleranceMessage								is a MessageField
			restricted
			"QuantityOutsideOfTolerance"
		MismatchMessage									is a MessageField
			restricted
			"PlanAndActualQuantityDoesNotMatch"

		DisplayMessage								is a DerivedField
			type is MessageField
			LocalUsedQuantity = ActualQuantity + WasteQuantity
			if (QuantityTolerancePercentage entered
			or  ZeroQuantity)
				if (ZeroQuantity)
					if (LocalUsedQuantity != PlanQuantity)
						LocalCompError	= true
						return ToleranceMessage
				LocalTolerance = PlanQuantity * QuantityTolerancePercentage
				if (LocalUsedQuantity > (PlanQuantity + LocalTolerance)
				or  LocalUsedQuantity < (PlanQuantity - LocalTolerance))
					LocalCompError	= true
					return ToleranceMessage

			if (ActualQuantity != PlanQuantity)
				LocalWarn = true
				return MismatchMessage

		DerivedUOM										is a DerivedField
			type is like UnitOfMeasure
			if (Item.IsCatchWeightItem)
				return Item.SecondaryUOM
			else
				return Item.StockUOM


		DerivedDelimiter is a DerivedField
			type is Alpha size 5
			restricted
			LocalConfigurationParameter = "Generic_Delimiter"
			if (FSMBODConfigurationParameterRel exists)
				return FSMBODConfigurationParameterRel.Value
		
		DerivedStatusCode is a DerivedField
			type is Alpha size 22
			restricted
			return WorkOrder.DerivedStatusCode

		BODFormattedCurrentTimeStamp is a DerivedField
			type is Alpha size 25
			restricted
			return WorkOrder.BODFormattedCurrentTimeStamp

		DerivedFinanceEnterpriseGroup is a DerivedField
			type is AlphaUpper size 4
			restricted
			return Company.FinanceEnterpriseGroup

		DerivedAE is a DerivedField
		 	type is AlphaUpper size 12
		 	restricted
		 	return Company.AccountingEntity

		DerivedItemUOM is a DerivedField
			type is AlphaUpper size 4
			restricted
			return Item.StockUOM

		DerivedCurrency is a DerivedField
			type is AlphaUpper size 5
			restricted
			return Company.Currency

		DerivedAccountingEntity is a DerivedField
			type is Alpha size 100
			restricted
			return DerivedFinanceEnterpriseGroup + DerivedDelimiter + DerivedAE

		DerivedLawsonCompany is a DerivedField
			type is Alpha size 4
			restricted
			return Company using "%d"

		DerivedDocumentID is a DerivedField
			type is Alpha 75
			restricted
			return DerivedLawsonCompany + DerivedDelimiter + WorkOrder

		DerivedStartDate is a DerivedField
			type is Date
			restricted
			return WorkOrder.StartDate

		DerivedLocation is a DerivedField
			type is AlphaUpper size 50
			restricted
			return WorkOrder.DerivedLocation

		DerivedItemGroup is a DerivedField
			type is AlphaUpper size 5
			restricted
			return Company.ItemGroup

		DerivedItemID is a DerivedField
			type is Alpha size 100
			restricted
			return Company.FinanceEnterpriseGroup + DerivedDelimiter + Company.ItemGroup + DerivedDelimiter + Item
			
		DerivedItemID2 is a DerivedField
			type is Alpha size 100
			restricted
			return Company.FinanceEnterpriseGroup + DerivedDelimiter + Company.ItemGroup + DerivedDelimiter + WorkOrder.Item

		DerivedAddress1 is a DerivedField
			type is Alpha size 50
			restricted
			return InventoryLocation.PostalAddress.DeliveryAddress.AddressLine1

		DerivedAddress2 is a DerivedField
			type is Alpha size 50
			restricted
			return InventoryLocation.PostalAddress.DeliveryAddress.AddressLine2

		DerivedAddress3 is a DerivedField
			type is Alpha size 50
			restricted
			return InventoryLocation.PostalAddress.DeliveryAddress.AddressLine3

		DerivedAddress4 is a DerivedField
			type is Alpha size 50
			restricted
			return InventoryLocation.PostalAddress.DeliveryAddress.AddressLine4

		DerivedPostalCode is a DerivedField
			type is Alpha size 20
			restricted
			return InventoryLocation.PostalAddress.PostalCode

		DerivedILStatus is a DerivedField
			type is Alpha size 15
			restricted
			return "Location Status"
		
		DerivedEstimatedCost is a DerivedField
			type is Decimal size 21.8
			restricted 
			return WorkOrder.EstimatedComponentCost
		
		DerivedActualQty is a DerivedField
			type is Decimal size 13.4
			restricted 
			return WorkOrder.ActualQuantity
								
		DerivedTotalDetailCatchWeightQuantity	is a DerivedField
			type is like Quantity
			restricted
			return sum WorkOrderItemBinLotSerialRel.CatchWeightQuantity 



    Conditions
		IsComponentTypeNotOffsite
			restricted
			when (not ComponentType.Offsite)

		IsWalkThroughRequired
			restricted
			when (WalkThruRequired)

		InProductionAllocation
			restricted
			when (PlanQuantity > WarehouseDemandLineRel.AllocatedQuantity
			and !InventoryLocation.AllowUnallocatedInProduction.InProdUnrestrictedByAlloc)

		IsBinTrackedAndNotLotOrSerialTracked
			restricted
			when (ItemLocationRel.IsNotLotTracked
			and ItemLocationRel.IsNotSerialTracked
			and ItemLocationRel.BinTracked)

		IsBinTracked
			restricted
			when (ItemLocationRel.BinTracked)

		IsDetailRequired
			restricted
			when (WarehouseDemandLineForProductionFeedbackRel.DetailRequired)

		IsSerialTracked
			restricted
			when (ItemLocationRel.IsSerialTracked)

		IsSerialTrackedAtIssue
			restricted
			when (ItemLocationRel.SerialTracked.SerialRequiredAtIssue)

		IsLotTrackedAndNotSerialTracked
			restricted
			when (ItemLocationRel.IsLotTracked
			and ItemLocationRel.IsNotSerialTracked)

		IsLotTrackedAtReceipts
			restricted
			when (ItemLocationRel.LotTracked.LotRequiredAtReceipt)

		IsLotRequiredAtIssue
			restricted
			when (ItemLocationRel.LotTracked.LotRequiredAtIssue
			and !ItemLocationRel.BinTracked)

		UnitOfMeasureTracked
			restricted
			when (ItemLocationRel.IsNotLotTracked
			and   ItemLocationRel.IsNotSerialTracked
			and   !ItemLocationRel.BinTracked)

		IsPickingFeedbackInProcess
			restricted
			when (WorkOrder.PickingFeedbackStatus.InProcess)

		IsProductionFeedbackInProcess
			restricted
			when (WorkOrder.ProductionFeedbackStatus.InProcess)

		IsOnlySerialTracked
			restricted
			when (ItemLocationRel.IsSerialTracked
			and  !ItemLocationRel.BinTracked)

		IsPlainItem
			restricted
			when (!ItemLocationRel.BinTracked
			and   !ItemLocationRel.IsLotTracked
			and   !ItemLocationRel.IsSerialTracked
			and   !Item.IsTrackedInAlternateUOM)

		DetailTracked
			when (!IsPlainItem)

		HasDemand
			when (WarehouseDemandLineRel exists)

	Rule Blocks

		ConversionOfQuantityAndCostFromSecondaryToStock
			initialize UOMCalculation
			UOMCalculation.InputUOM							= Item.SecondaryUOM
			UOMCalculation.InputQuantity					= LocalInputQuantity
			UOMCalculation.InputToUOM						= Item.StockUOM
			UOMCalculation.InputUnitCost					= LocalInputCost
			UOMCalculation.Method							= UOMCalculation.Method.ConvertToStock
			LocalOutputQuantity								= UOMCalculation.OutputQuantity
			LocalOutputUnitCost								= UOMCalculation.OutputUnitCost

		ConvertQuantity
			initialize UOMCalculation
			UOMCalculation.InputQuantity					= LocalActualQuantity
			UOMCalculation.InputUOM							= LocalInputUOM
			UOMCalculation.Method							= UOMCalculation.Method.ConvertToStock
			LocalOutputQuantity								= UOMCalculation.OutputQuantity
		
		CalculateWorkorderEstimatedComponentCost
			if (Item.IsCatchWeightItem)
				LocalInputCost = EstimatedComponentCost
				include ConversionOfQuantityAndCostFromSecondaryToStock
				LocalEstimatedComponentCost = LocalOutputQuantity * EstimatedComponentCost
			else
				LocalEstimatedComponentCost	= LocalInputQuantity * EstimatedComponentCost

			LocalEstimatedPackingCost = LocalEstimatedComponentCost

		DetermineQuantityChange
			initialize LocalQuantityChange
			if ((WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity > PlanQuantity
			and  WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity > PickedQuantity
			and  WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity > LocalUsedQuantity)
			or   WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity < LocalUsedQuantity)
				if (PlanQuantity > PickedQuantity)
					if (WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity < PlanQuantity)
						LocalPlanAllocatedQuantity = WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity
					else
						LocalPlanAllocatedQuantity = PlanQuantity

					if (LocalUsedQuantity < LocalOldUsedQuantity)
						if (LocalUsedQuantity > LocalPlanAllocatedQuantity)
							LocalQuantityChange = LocalUsedQuantity - LocalOldUsedQuantity
						else
							LocalQuantityChange = LocalPlanAllocatedQuantity - WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity
					else
						if (LocalUsedQuantity > LocalPlanAllocatedQuantity)
							LocalQuantityChange = LocalUsedQuantity - WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity
				else
					if (LocalUsedQuantity > LocalOldUsedQuantity)
						if (LocalUsedQuantity > PickedQuantity)
							if (LocalOldUsedQuantity > PickedQuantity)
								LocalQuantityChange = LocalUsedQuantity - LocalOldUsedQuantity
							else
								LocalQuantityChange = LocalUsedQuantity - PickedQuantity

								if (WarehouseDemandLineForProductionFeedbackRel not exists
								and LocalQuantityChange entered)
									LocalCreateWarehouseDemand = true
					else
						if (LocalUsedQuantity > PickedQuantity)
							LocalQuantityChange = LocalUsedQuantity - LocalOldUsedQuantity
						else
							LocalQuantityChange = PickedQuantity - LocalOldUsedQuantity

							if (WarehouseDemandLineForProductionFeedbackRel exists)
								LocalUpdateWarehouseDemand = true

		CalculateUnitCostFromInventoryCostHistory
			if (Company.CostingMethod.LastInFirstOut)
				for each InventoryCostHistoryForLifoRel
					include InventoryCostHistory
			else
			if (Company.CostingMethod.FirstInFirstOut)
				for each InventoryCostHistoryFifoRel
					include InventoryCostHistory

		InventoryCostHistory
			InventoryCostHistoryRemainingQuantity = each.ReceivedQuantity - each.InspectionHoldQuantity - each.UsedQuantity
			if (LocalQuantity <= InventoryCostHistoryRemainingQuantity)
				InventoryCostHistoryQuantity 	= LocalQuantity
			else
				InventoryCostHistoryQuantity	= InventoryCostHistoryRemainingQuantity

			TempUnitCost						= each.UnitCost

			InventoryCostHistoryCost 			= InventoryCostHistoryQuantity * TempUnitCost
			TotalInventoryHistoryCost 		   += InventoryCostHistoryCost

			if (LocalQuantity = 0)
				end for each

			LocalQuantity 			   			-= InventoryCostHistoryQuantity
			LocalUnitCost						= TotalInventoryHistoryCost / LocalQuantity

   		CalculateBurdenCost
   			if (LocalEstimatedComponentCost != LocalOriginalEstimatedComponentCost
   			or LocalEstimatedPackingCost 	!= LocalOriginalEstimatedPackingCost)
				for each WorkOrderBurdensRel  
					if (each.IsPercentOfFinishedGoodsInventoryCost)
						LocalWorkOrderBurdenPercentage += each.PercentageOfInventoryCost
				LocalOldBurdenCost	= ((LocalOriginalEstimatedComponentCost + LocalOriginalEstimatedPackingCost) * LocalWorkOrderBurdenPercentage)
				LocalNewBurdenCost	= ((LocalEstimatedComponentCost + LocalEstimatedPackingCost) * LocalWorkOrderBurdenPercentage)

				invoke UpdateFromWorkOrderBurden WorkOrder
					invoked.PrmEstimatedAmount = (LocalNewBurdenCost - LocalOldBurdenCost)

		UpdateWorkOrderEstimatedComponentCost
			invoke UpdateWorkOrderForComponent WorkOrder
				if (ComponentType.Rework
				or ComponentType.Component)
					if (!LocalReverseByWorkOrder)
						invoked.PrmEstimatedComponentCost =  LocalEstimatedComponentCost
				else
					invoked.PrmEstimatedPackagingCost =  LocalEstimatedPackingCost

		UpdateWorkOrderActualComponentCost
			invoke InProduction.UpdateActualComponentCostFromComponent WorkOrder
				if (ComponentType.Component
				or  ComponentType.Rework)
					invoked.PrmActualComponentCost = LocalActualCost
				else
					invoked.PrmActualPackagingCost = LocalActualCost

		ValidateItemLocationAvailableQuantity
			if (LocalUsedQuantity > WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity)
				LocalQuantityChange = LocalUsedQuantity - WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity
				if (!ComponentType.Offsite)
					if (LocalQuantityChange entered)
						if (Company.AvailableToAllocateBackorder.SubtractFromStockOnHand)
							constraint (LocalQuantityChange <= (ItemLocationRel.AvailableQuantity + WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity)) 
								"InsufficientAvailableQuantityToAllocate"							
						else
							constraint (LocalQuantityChange <= ItemLocationRel.AvailableQuantity)
								"InsufficientAvailableQuantityToAllocate"												

		ValidateMaterialExpenseAccountInProduction
			if (MaterialExpenseAccount not entered)
				constraint (WorkOrder.ProductionCreditAccount not entered)
				 	"MaterialExpenseAccountNotEnteredInItem;CannotEnterProductionCreditAccount"					`		
				constraint (WorkOrder.BurdenAbsorptionAccount not entered)
				 	"MaterialExpenseAccountNotEnteredInItem;CannotEnterBurdenAbsorptionAccount"							
			else
				constraint (WorkOrder.BurdenAbsorptionAccount entered)
					"MaterialExpenseAccountEnteredInItem;BurdenAbsorptionAccountIsRequired"								

				constraint (WorkOrder.ProductionCreditAccount entered)
					"MaterialExpenseAccountEnteredInItem;ProductionCreditAccountIsRequired"

		CreateDistributionsForIncomeAccounts
			invoke Create InventoryTransactionLineDistribution
				fill in fields from this instance
				invoked.System												= "WO"
				invoked.TransactionSystemCode								= "WO"
				invoked.InventoryTransaction								= LocalInventoryTransaction
				invoked.InventoryTransactionLine.LineNumber					= LocalInventoryTransactionLine

				invoked.PostingType											= LocalPostingType
				invoked.PostingDate											= current corporate date 
				invoked.GLFinanceCodeBlock									= LocalDistributionAccount
				invoked.GLTransactionAmount									= LocalAmount	
				invoked.CurrencyCode										= Company.Currency
				if (ActualQuantity not entered)
					invoked.UnitsAmount										= PickedQuantity
				else
					invoked.UnitsAmount										= ActualQuantity
				invoked.TransactionDate										= current corporate date 
				invoked.GeneralLedgerEvent									= "WO"
				invoked.DocumentNumber										= WorkOrder
				initialize invoked.Status

    Relations

		FSMBODConfigurationParameterRel
        	one-to-one relation to FSMBODConfigurationParameter
			Field Mapping uses symbolic key
            	related.FSMBODConfigurationParameter 		= LocalConfigurationParameter

        SubstituteAssociatedItemsRel
            one-to-many relation to AssociatedItem
            Field Mapping uses symbolic key
                related.ItemGroup = Company.ItemGroup
                related.Item      = Item
            Instance Selection
                where (related.AssociatedItem.AssociatedItemSubType.Substitute)

		ItemLocationRel
			one-to-one relation to ItemLocation
			Field Mapping uses symbolic key
				related.Company           = Company
				related.InventoryLocation = Location
				related.Item              = Item

		ItemLocationsRel
			one-to-many relation to ItemLocation
			Field Mapping uses Set2
				related.Company           = Company
				related.Item              = Item

		WarehouseDemandLineRel
			one-to-one relation to WarehouseDemandLine
			Field Mapping uses symbolic key
				related.Company           						= Company
				related.WarehouseDemand.DemandSystemCode		= DemandSystemCode.WorkOrder // "WO" 
				related.WarehouseDemand.DemandDocument			= WorkOrder
				related.WarehouseDemand.DemandCompany	 		= Company
				related.InventoryLocation						= Location
				related.Item									= Item
				related.WarehouseDemandLine.DemandDocumentType	= DemandDocumentType.WorkOrder //"WO" 
				related.WarehouseDemandLine.LineNumber			= WorkOrderItem
				related.WarehouseDemandLine.ComponentSequence 	= blank

		WarehouseDemandLineItemRel
			one-to-one relation to WarehouseDemandLine
			Field Mapping uses Set1
				related.Company           						= Company
				related.WarehouseDemand.DemandSystemCode		= "WO"
				related.WarehouseDemand.DemandDocument			= WorkOrder
				related.WarehouseDemand.DemandCompany	 		= Company
				related.WarehouseDemandLine.LineNumber			= WorkOrderItem
				related.WarehouseDemandLine.ComponentSequence 	= blank
				related.InventoryLocation						= Location


		WorkOrderItemBinLotSerialRel 			is a WorkOrderItemBinLotSerial set
			Instance Selection
				where (related.WorkOrderItem entered
				and    related.WorkOrderByproduct not exists)

		InventoryCostHistoryForLifoRel
			one-to-many relation to InventoryCostHistory
			Field Mapping uses Set5
				related.Company 								= Company
				related.InventoryLocation						= InventoryLocation
				related.Item									= Item

		InventoryCostHistoryFifoRel
			one-to-many relation to InventoryCostHistory
			Field Mapping uses Set3
				related.Company 					= Company
				related.InventoryLocation			= InventoryLocation
				related.Item						= Item

		WarehouseDemandLineOldLocationRel
			one-to-one relation to WarehouseDemandLine
			Field Mapping uses Set1
				related.Company           						= Company
				related.WarehouseDemand.DemandSystemCode		= "WO"
				related.WarehouseDemand.DemandDocument			= WorkOrder
  				related.WarehouseDemand.DemandCompany	 		= Company
				related.WarehouseDemandLine.LineNumber			= WorkOrderItem
				related.WarehouseDemandLine.ComponentSequence 	= blank
				related.InventoryLocation						= LocalOldLocation


	 	WorkOrderBurdensRel is a WorkOrderBurden(InventoryLocation) set

	 	WarehouseDemandLineForProductionFeedbackRel
			one-to-one relation to WarehouseDemandLine
			Field Mapping uses Set1
				related.Company           						= Company
				related.WarehouseDemand.DemandSystemCode		= "WO"
				related.WarehouseDemand.DemandDocument			= WorkOrder
				related.WarehouseDemand.DemandCompany	 		= Company
				related.WarehouseDemandLine.LineNumber			= WorkOrderItem
				related.WarehouseDemandLine.ComponentSequence 	= blank
				related.InventoryLocation						= InventoryLocation

		InventoryTransactionLineRel
			one-to-many relation to InventoryTransactionLine
			Field Mapping uses ByOriginatingTransaction
				related.OriginatingTransaction		= reference to this instance
				related.TransactionSystemCode 		= "WO"
				related.Company						= Company
				related.InventoryLocation 			= InventoryLocation
			Instance Selection
				where (related.InventoryTransactionLine.LineNumber = WorkOrderItem)

		ItemSerialNumberRel
			one-to-many relation to ItemSerialNumber
			Field Mapping uses symbolic key
				related.Company						= Company
				related.Item						= Item


	Sets

		Set2
			indexed
			Sort Order
				Company
				InventoryLocation
				WorkOrder
				Location
				WorkOrderItem

		Set3
			indexed
			Sort Order
				Company
				InventoryLocation
				WorkOrder
				ComponentType
				WorkOrderItem

		Set4
			indexed
			Instance Selection
				where (IsWalkThroughRequired)
			Sort Order
				Company
				InventoryLocation
				WorkOrder
				WorkOrderItem

		Set5
			indexed
			Instance Selection
				where (IsComponentTypeNotOffsite)
			Sort Order
				Company
				InventoryLocation
				WorkOrder
				WorkOrderItem


	Field Rules

		ComponentType
			required
			cannot be changed																					

			if (ComponentType.Offsite)
				constraint (ItemLocationsRel not exists)
					"OffsiteComponentHasAnItemLocationRecord"													

		Item
			required

			if (ComponentType.Rework)
				constraint (Item = WorkOrder.Item)
					"ComponentItemMustBeSameAsFinishedGoodItemForReworkOrders"									
			else
				constraint (Item != WorkOrder.Item)
					"ComponentItemMustNotBeSameAsFinishedGoodItem"

			if (SubstituteAssociatedItemsRel not exist)
				cannot be changed
					"Item<Item>IsNotAValidSubstituteItem"														
			else
				if (SubstituteAssociatedItemsRel.EffectiveDate entered)
					constraint (WorkOrder.DateNeeded >= SubstituteAssociatedItemsRel.EffectiveDate)
						"SubstituteItemHasExpired"																

				if (SubstituteAssociatedItemsRel.ExpirationDate entered)
					constraint (WorkOrder.DateNeeded <= SubstituteAssociatedItemsRel.ExpirationDate)
						"SubstituteItemHasExpired;DateNeededShouldBeLessThanExpirationDate"																


	   	Location
	   		if (ComponentType.Offsite)
	   			required																						
	   			constraint (InventoryLocation.WorkOrderLocationType.OffsiteLocation)
	   				"ComponentLocationIsNotSetAsOffsite"														
	   		else
	   			default to WorkOrder.InventoryLocation

	   	PlanQuantity
	   		if (ComponentType.Rework)
				constraint (PlanQuantity = WorkOrder.PlanQuantity)
					"PlanComponentQuantityMustEqualFinishedGoodQuantityForReworkOrders"							

	   		if ((ComponentType.Offsite
	   		or   ComponentType.Component)
	   		and  !WorkOrder.Status.InProduction)
	   			required
	   				"QuantityRequiredForComponentTypeComponentOrOffsiteWhenWorkOrderStatusIsNotInProduction"	

	   	MaterialExpenseAccount
	   		if (InventoryLocation.UseIncomeStatementAccounts)
	   			if (IsComponentTypeNotOffsite)
	   				required
	   					"MaterialExpenseAccountMustBeSpecified"													
	   		else
	   			cannot be entered
	   				"<ExpenseAccountErrorMessage>"																

		EstimatedComponentCost
			if (IsComponentTypeNotOffsite)
				initialize InventoryCostDefault
				InventoryCostDefault.InCompany 				= Company
				InventoryCostDefault.InInventoryLocation 	= InventoryLocation
				InventoryCostDefault.InItem 				= Item
				InventoryCostDefault.InQuantity 			= PlanQuantity

				default to InventoryCostDefault.DefaultInventoryCost
	   		else
				cannot be entered


		CatchWeightQuantity																	             		
			if (Item.CatchWeightCode.ReceiptRequiresBoth
			and PickedQuantity entered)
				LocalInputQuantity = PickedQuantity
				include ConversionOfQuantityAndCostFromSecondaryToStock
				default to LocalOutputQuantity

			if ((Item.CatchWeightCode.AllTransactionsRequireBoth                                         		
			or  Item.CatchWeightCode.IssueRequiresBoth)
			and WorkOrder.Status.InProduction
			and WorkOrder.PickingFeedbackStatus.InProcess
			and PickedQuantity entered)
				required

			if (!Item.IsCatchWeightItem)
				cannot be entered
					"NotCatchWeightItem;ValueMustBeZero"


		PickedQuantity
			if (PickedQuantity changed)
				LocalUsedQuantity = PickedQuantity
				include ValidateItemLocationAvailableQuantity

			if (!LocalReverseByWorkOrder)
				constraint (PickedQuantity >= DetailQuantity)
					"DetailQuantitiesAreGreaterThanPickedQuantity"                                  			

			if ((Item.CatchWeightCode.AllTransactionsRequireBoth
			or  Item.CatchWeightCode.IssueRequiresBoth)
			and WorkOrder.Status.InProduction
			and WorkOrder.PickingFeedbackStatus.InProcess
			and CatchWeightQuantity entered)
				required																					

		ActualCatchWeightQuantity
			if (!Item.IsCatchWeightItem)
				cannot be entered
					"NotCatchWeightItem;ValueMustBeZero"													
			else
				if (ActualQuantity entered)
					required
						"MustEnterActualCatchWeightQuantity"												

		WasteCatchWeightQuantity
			if (!Item.IsCatchWeightItem)
				cannot be entered
					"NotCatchWeightItem;ValueMustBeZero"													
			else
				if (WasteQuantity entered)
					required
						"MustEnterWasteCatchWeightQuantity"													

		WasteAccount
			if (WasteQuantity entered)
				default to InventoryLocation.WasteAccount

	Actions
		Create is a Create Action
			valid when (!WorkOrder.IsReleasedOrUnreleased)													

			Field Rules
				PlanQuantity
					if (WorkOrder.Status.InProduction
					and !LocalReverseByWorkOrder)
						cannot be entered
							"QuantityMustBeZeroWhenWorkOrderIsInProduction"

			Action Rules
				constraint (!WorkOrder.IsReleasedOrUnreleased)
					"CreateActionIsValidOnlyWhenNotReleasedOrUnreleased"

				if (WorkOrder.IsInProduction
				and !LocalReverseByWorkOrder)
					constraint (!WorkOrder.PickingFeedbackStatus.Finished)
						"CannotAdd;WorkOrderPickingFeedbackFinished"										

					constraint (WorkOrder.IsWorkOrderProductionFeedbackNotStartedOrInProcess)
						"CannotAdd;WorkOrderProductionFeedbackFinishedOrCompleted"							

			Exit Rules
				LocalOriginalEstimatedComponentCost = WorkOrder.EstimatedComponentCost
				LocalOriginalEstimatedPackingCost 	= WorkOrder.EstimatedPackagingCost
				LocalInputQuantity = PlanQuantity

				include CalculateWorkorderEstimatedComponentCost

				include UpdateWorkOrderEstimatedComponentCost

				include CalculateBurdenCost

				if (PlanQuantity entered
				and IsComponentTypeNotOffsite)
					invoke Create WarehouseDemandLine
						invoked.Company           						= Company
						invoked.InventoryLocation						= Location
						invoked.WarehouseDemand.DemandSystemCode		= "WO"
						invoked.WarehouseDemand.DemandDocument			= WorkOrder
						invoked.WarehouseDemand.DemandCompany			= Company
						invoked.DocumentNumberNumeric					= WorkOrder
						invoked.WarehouseDemandLine.DemandDocumentType  = "WO"
						invoked.WarehouseDemandLine.LineNumber		    = WorkOrderItem
						initialize invoked.WarehouseDemandLine.ComponentSequence
						invoked.DemandRecordType						= "D"
						invoked.Item									= Item
						invoked.LineType								= "I"
						invoked.TransActionType 						= "A"
						invoked.Allocatable								= true
						invoked.Status									= 1
						if (WorkOrder.OriginalWorkOrder entered)
							invoked.Quantity							= PlanQuantity * -1
							invoked.AllocatedQuantity					= PlanQuantity * -1
						else
							invoked.Quantity							= PlanQuantity
							invoked.AllocatedQuantity					= PlanQuantity
						invoked.TransactionUOM 							= Item.StockUOM
						invoked.AllocationDate							= WorkOrder.StartDate
						invoked.ConfirmDemand							= true

		Update is an Update Action
			Exit Rules
				constraint (!InventoryLocation.Status.Inactive)											
					"InventoryLocation<InventoryLocation>IsInactive"

				LocalOriginalEstimatedComponentCost = WorkOrder.EstimatedComponentCost
				LocalOriginalEstimatedPackingCost 	= WorkOrder.EstimatedPackagingCost


				if (PlanQuantity changed)
					LocalQuantityChange = PlanQuantity - old PlanQuantity

				if (Location changed
				or Item changed)
					LocalOldLocation 			= old Location
					LocalOldPlanQuantity		= old PlanQuantity
					if (Item changed)
						LocalOldItem			= old Item

				if (PlanQuantity changed				
				and LocalQuantityChange entered
				and LocalOldLocation not entered)
					if (PlanQuantity entered
					and ComponentType.Packaging)
						invoke Create WarehouseDemandLine
							invoked.Company           						= Company
							invoked.InventoryLocation						= Location
							invoked.WarehouseDemand.DemandSystemCode		= "WO"
							invoked.WarehouseDemand.DemandDocument			= WorkOrder
							invoked.WarehouseDemand.DemandCompany			= Company
							invoked.DocumentNumberNumeric					= WorkOrder
							invoked.WarehouseDemandLine.DemandDocumentType  = "WO"
							invoked.WarehouseDemandLine.LineNumber		    = WorkOrderItem
							invoked.Item									= Item
							invoked.DemandRecordType						= "D"
							invoked.LineType								= "I"
							invoked.Allocatable								= true
							invoked.Status									= 1
							invoked.TransActionType 						= "A"
							invoked.TransactionUOM 							= Item.StockUOM
							invoked.Quantity								= PlanQuantity
							invoked.AllocationDate							= WorkOrder.StartDate
							invoked.ConfirmDemand							= true
							if (Company.AllocationBasis.ByPriority)
								invoked.AllocationPriority	= Company.DefaultWOPriority
					else
					if ((PlanQuantity changed
					and PlanQuantity not entered)
					and ComponentType.Packaging)
						invoke Delete WarehouseDemandLineRel
					else
					if (IsComponentTypeNotOffsite)
						invoke Update WarehouseDemandLineItemRel
							invoked.Quantity								= LocalQuantityChange
							invoked.AllocationDate							= WorkOrder.StartDate



							invoked.LineType								= "I"
							invoked.Allocatable								= true

					LocalInputQuantity			= old PlanQuantity
					include CalculateWorkorderEstimatedComponentCost           

					LocalEstimatedComponentCost	=	LocalEstimatedComponentCost * (-1)
					LocalEstimatedPackingCost	=	LocalEstimatedComponentCost

					include UpdateWorkOrderEstimatedComponentCost

					LocalInputQuantity			= PlanQuantity
					include CalculateWorkorderEstimatedComponentCost		  
					include UpdateWorkOrderEstimatedComponentCost
				else
					if (LocalOldLocation entered)					         
						LocalInputQuantity	= LocalOldPlanQuantity
						include CalculateWorkorderEstimatedComponentCost

						LocalEstimatedComponentCost	= LocalEstimatedComponentCost * (-1)
						LocalEstimatedPackingCost	=	LocalEstimatedComponentCost

						include UpdateWorkOrderEstimatedComponentCost

						if (LocalOldItem not entered)          
							LocalSubstituteItem = Item
						else
							LocalSubstituteItem = LocalOldItem
						invoke Delete WarehouseDemandLineOldLocationRel

						invoke Create WarehouseDemandLine
							invoked.Company           						= Company
							invoked.InventoryLocation						= Location
							invoked.WarehouseDemand.DemandSystemCode		= "WO"
							invoked.WarehouseDemand.DemandDocument			= WorkOrder
							invoked.WarehouseDemand.DemandCompany			= Company
							invoked.DocumentNumberNumeric					= WorkOrder
							invoked.WarehouseDemandLine.DemandDocumentType  = "WO"
							invoked.WarehouseDemandLine.LineNumber		    = WorkOrderItem
							initialize invoked.WarehouseDemandLine.ComponentSequence
							invoked.DemandRecordType						= "D"
							invoked.Item									= Item
							invoked.Allocatable								= true
							invoked.Status									= 1
							invoked.TransActionType 						= "A"
							invoked.TransactionUOM 							= Item.StockUOM
							invoked.AllocationDate							= WorkOrder.StartDate
							invoked.Quantity								= PlanQuantity
							invoked.ConfirmDemand							= true
							invoked.LineType								= "I"

						LocalInputQuantity	= PlanQuantity
						include CalculateWorkorderEstimatedComponentCost

						include UpdateWorkOrderEstimatedComponentCost

				include CalculateBurdenCost


				if (PickedQuantity changed)
					constraint (WorkOrder.Status.InProduction)
						"WorkOrderIsNotInProduction"                                          	 

					constraint (WorkOrder.ProductionFeedbackStatus.NotStarted)
						"ProductionFeedbackBegun;PickingNotAllowed"

					constraint (!WorkOrder.IsPickingFeedbackFinishedOrComplete)
						"WorkOrderPickingFeedbackHasBeenCompleted"

					constraint (WorkOrder.PickingFeedbackStatus.InProcess)
						"CannotUpdate;PickingFeedbackNotStarted"

					constraint (WarehouseDemandLineForProductionFeedbackRel exists)
						"WarehouseDemandLineDoesNotExist"






					initialize LocalQuantityChange


					if (PickedQuantity < old PickedQuantity
					and PickedQuantity >= PlanQuantity)
						LocalQuantityChange = PickedQuantity - old PickedQuantity

					if (PickedQuantity < old PickedQuantity
					and PickedQuantity < PlanQuantity
					and WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity > PlanQuantity)
						LocalQuantityChange = PlanQuantity - WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity

					if (PickedQuantity > old PickedQuantity
					and PickedQuantity > WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity)
						LocalQuantityChange = PickedQuantity - WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity


					if (LocalQuantityChange > 0
					and LocalQuantityChange >= WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity)
						LocalPlanQuantity = LocalQuantityChange - WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity
					else
						LocalPlanQuantity = LocalQuantityChange

					LocalPrintedQuantity = PickedQuantity - old PickedQuantity

					if (LocalQuantityChange entered)                                                           
						if (LocalQuantityChange > 0
						and WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity entered)
							if (LocalQuantityChange > WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity )
								LocalBackorderedQuantity -= WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity
							else
								LocalBackordered = true
								LocalBackorderedQuantity = LocalQuantityChange - WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity

						invoke Update WarehouseDemandLineForProductionFeedbackRel
							if (!LocalBackordered)
								invoked.Quantity							= LocalPlanQuantity
							else
								initialize invoked.Quantity							                      				 
							invoked.PrintedQuantity							= LocalPrintedQuantity
							invoked.Destination								= Location
							invoked.EstimatedTransactionDate				= current corporate date


							if (LocalBackorderedQuantity entered)
								invoked.BackorderedQuantity					= LocalBackorderedQuantity
								invoked.AllocatedQuantity 					= LocalQuantityChange


					else
						if (LocalPrintedQuantity entered)
							invoke UpdateWarehouseDemandLine WarehouseDemandLineForProductionFeedbackRel
								invoked.PrmPrintedQuantity += LocalPrintedQuantity
								
				if (CatchWeightQuantity changed)
					constraint (WorkOrder.Status.InProduction)
						"WorkOrderIsNotInProduction"
						
					constraint (WorkOrder.ProductionFeedbackStatus.NotStarted)
						"ProductionFeedbackBegun;PickingNotAllowed"
						
					constraint (!WorkOrder.IsPickingFeedbackFinishedOrComplete)
						"WorkOrderPickingFeedbackHasBeenCompleted"

					constraint (WorkOrder.PickingFeedbackStatus.InProcess)
						"CannotUpdate;PickingFeedbackNotStarted"



				if (ActualQuantity changed
				or  ActualCatchWeightQuantity changed)
					if (ActualComponentCost entered)
						LocalInputCost		= ActualComponentCost
						LocalInputQuantity	= old ActualQuantity
						LocalOldActualCatchWeightQuantity		= old ActualCatchWeightQuantity
						if (Item.IsCatchWeightItem)
							if (LocalOldActualCatchWeightQuantity not entered)
								include ConversionOfQuantityAndCostFromSecondaryToStock
								LocalActualCost		-= LocalInputCost * LocalOutputQuantity   
							else
								LocalActualCost		-= LocalInputCost * LocalOldActualCatchWeightQuantity
						else
							LocalActualCost			-= LocalInputCost * LocalInputQuantity

						include UpdateWorkOrderActualComponentCost

					initialize InventoryCostDefault
					InventoryCostDefault.InCompany 				= Company
					InventoryCostDefault.InInventoryLocation 	= InventoryLocation
					InventoryCostDefault.InItem 				= Item
					InventoryCostDefault.InQuantity 			= ActualQuantity

					ActualComponentCost	= InventoryCostDefault.DefaultInventoryCost

					LocalInputCost			= ActualComponentCost
					LocalInputQuantity		= ActualQuantity
					if (PickedCost entered)
						LocalUnitCost		= PickedCost
					else
						LocalUnitCost		= ActualComponentCost
					if (Item.IsCatchWeightItem)

						LocalActualCost		= LocalUnitCost * ActualCatchWeightQuantity
					else
						LocalActualCost		= LocalUnitCost * LocalInputQuantity

					include UpdateWorkOrderActualComponentCost
				if (ActualQuantity changed)
					LocalUsedQuantity		= ActualQuantity + WasteQuantity
					include ValidateItemLocationAvailableQuantity

					LocalUsedOldQuantity = old ActualQuantity + old WasteQuantity

					if (PlanQuantity not entered
					and PickedQuantity not entered
					and LocalOldUsedQuantity not entered
					and LocalUsedQuantity entered)
						invoke Create WarehouseDemandLine
							invoked.Company           						= Company
							invoked.InventoryLocation						= Location
							invoked.WarehouseDemand.DemandSystemCode		= "WO"
							invoked.WarehouseDemand.DemandDocument			= WorkOrder
							invoked.WarehouseDemand.DemandCompany			= Company
							invoked.DocumentNumberNumeric					= WorkOrder
							invoked.WarehouseDemandLine.DemandDocumentType  = "WO"
							invoked.WarehouseDemandLine.LineNumber		    = WorkOrderItem
							initialize invoked.WarehouseDemandLine.ComponentSequence
							invoked.DemandRecordType						= "Demand"
							invoked.Item									= Item
							invoked.LineType								= "I"
							invoked.Allocatable								= true
							invoked.Status									= 1
							invoked.Quantity								= LocalUsedQuantity
							invoked.PrintedQuantity							= LocalUsedQuantity
							invoked.TransactionUOM 							= Item.StockUOM
							invoked.Destination								= Location
							invoked.AllocationDate							= WorkOrder.StartDate
							invoked.EstimatedTransactionDate				= current corporate date
							invoked.ConfirmDemand							= true

						LocalOldUsedQuantity = LocalUsedQuantity

					if (LocalOldUsedQuantity != LocalUsedQuantity)		

						include DetermineQuantityChange

						LocalUpdateWarehouseDemand = true   
						if (LocalQuantityChange entered
						or  ActualQuantity changed
						or  WasteQuantity changed)
							if (LocalQuantityChange > 0
							and LocalQuantityChange >= WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity)
								LocalPlanExpQuantity = LocalQuantityChange - WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity
							else
								LocalPlanExpQuantity = LocalQuantityChange

							if (LocalUsedQuantity > PickedQuantity)
								if (LocalOldUsedQuantity > PickedQuantity)
									LocalPrintedQuantity = LocalUsedQuantity - LocalOldUsedQuantity
								else
									LocalPrintedQuantity = LocalUsedQuantity - PickedQuantity
							else
								if (LocalOldUsedQuantity > PickedQuantity)
									LocalPrintedQuantity = PickedQuantity - LocalUsedQuantity
							if (LocalQuantityChange entered)
								if (LocalQuantityChange > 0
								and WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity entered)
									initialize LocalBackorderedQuantity
									if (LocalQuantityChange >= WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity)
										LocalBackorderedQuantity -= WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity
									else
										LocalBackordered = true									
										LocalBackorderedQuantity -= LocalQuantityChange

								if (LocalUpdateWarehouseDemand)
									invoke Update WarehouseDemandLineForProductionFeedbackRel
										if (!LocalBackordered)
											invoked.Quantity							= LocalPlanExpQuantity
										else
											initialize invoked.Quantity
										invoked.PrintedQuantity							= LocalPrintedQuantity
										invoked.EstimatedTransactionDate				= current corporate date


										if (LocalBackorderedQuantity entered)
											invoked.BackorderedQuantity					= LocalBackorderedQuantity
											invoked.AllocatedQuantity 					= LocalQuantityChange



								else
									if (LocalCreateWarehouseDemand)
										invoke Create WarehouseDemandLine
											invoked.Company           						= Company
											invoked.InventoryLocation						= Location
											invoked.WarehouseDemand.DemandSystemCode		= "WO"
											invoked.WarehouseDemand.DemandDocument			= WorkOrder
											invoked.WarehouseDemand.DemandCompany			= Company
											invoked.DocumentNumberNumeric					= WorkOrder
											invoked.WarehouseDemandLine.DemandDocumentType  = "WO"
											invoked.WarehouseDemandLine.LineNumber		    = WorkOrderItem
											initialize invoked.WarehouseDemandLine.ComponentSequence
											invoked.DemandRecordType						= "D"
											invoked.Item									= Item
											invoked.LineType								= "I"
											invoked.Allocatable								= true
											invoked.Status									= 1
											invoked.PrintedQuantity							= LocalPrintedQuantity
											if (LocalBackorderedQuantity entered)
												invoked.BackorderedQuantity					= LocalBackorderedQuantity
												invoked.AllocatedQuantity 					= LocalQuantityChange
												invoked.TransActionType 					= "B"
												invoked.TransKitSpecialFunction 			= "A"
											if (!LocalBackordered)
												invoked.Quantity							= LocalQuantityChange
											else
												initialize invoked.Quantity
											invoked.TransactionUOM 							= Item.StockUOM
											invoked.AllocationDate							= WorkOrder.StartDate
											invoked.EstimatedTransactionDate				= current corporate date
											invoked.ConfirmDemand							= true

							else
								if (LocalPrintedQuantity entered)
									invoke UpdateFromWorkOrderItem WarehouseDemandLineForProductionFeedbackRel
										invoked.PrmPrintedQuantity = LocalPrintedQuantity

		Delete is a Delete Action
			valid when (WorkOrder.IsExploded)

			Entrance Rules
				constraint (WorkOrder.IsExplodedOrInProduction)
					"CannotDeleteWorkOrderItem;WorkOrderStatus<WorkOrder.Status>"

				constraint (WorkOrderItemBinLotSerialRel not exists)
					"CannotDeleteWorkOrderDetailExist"										

				LocalOriginalEstimatedComponentCost = WorkOrder.EstimatedComponentCost
				LocalOriginalEstimatedPackingCost 	= WorkOrder.EstimatedPackagingCost

				if (IsComponentTypeNotOffsite)
					LocalInputQuantity	= PlanQuantity
					LocalInputCost 		= EstimatedComponentCost
					include CalculateWorkorderEstimatedComponentCost
				else
					initialize LocalEstimatedComponentCost

				LocalEstimatedComponentCost	=	LocalEstimatedComponentCost * (-1)
				LocalEstimatedPackingCost	=	LocalEstimatedComponentCost

				include UpdateWorkOrderEstimatedComponentCost

				include CalculateBurdenCost

				if (IsComponentTypeNotOffsite)
					invoke Delete WarehouseDemandLineRel


				if (ActualQuantity entered)
					LocalUsedQuantity = ActualQuantity + WasteQuantity
					include ValidateItemLocationAvailableQuantity

					LocalInputQuantity = ActualQuantity
					LocalInputCost = ActualComponentCost

					if (Item.IsCatchWeightItem)
						include ConversionOfQuantityAndCostFromSecondaryToStock
						LocalActualCost  -= LocalOutputUnitCost * LocalOutputQuantity    
					else
						LocalActualCost  -= LocalInputQuantity * LocalInputCost

					include UpdateWorkOrderActualComponentCost

					LocalUsedQuantity = ActualQuantity + WasteQuantity
					initialize LocalOldUsedQuantity

					include DetermineQuantityChange

					if (LocalQuantityChange entered)
						if (LocalOldUsedQuantity > PickedQuantity)
							LocalPrintedQuantity -= LocalUsedQuantity
						else
							LocalPrintedQuantity -= PickedQuantity

						invoke Update WarehouseDemandLineForProductionFeedbackRel
							invoked.Quantity								= LocalPlanExpQuantity
							invoked.PrintedQuantity							= LocalPrintedQuantity
							invoked.EstimatedTransactionDate				= current corporate date




		Purge is a Purge Action
			restricted
			bypass relational integrity rules

		InProductionValidationAction is an Instance Action
			restricted
			Action Rules
				if (IsComponentTypeNotOffsite)
					if (PlanQuantity entered
			 		or PickedQuantity entered)
			 			constraint (WarehouseDemandLineRel exist)
							"WarehouseDemandRecordDoesNotExist"                                		 							

					constraint (!InProductionAllocation)
						"CannotMoveToInProductionState;SequenceNeedsAllocation"													

					include ValidateMaterialExpenseAccountInProduction


		UpdateDetailQuantityFromDetail is an Instance Action                    
			restricted
			Parameters
				PrmDetailQuantity         		is like Quantity
			Action Rules
				DetailQuantity   += PrmDetailQuantity


		StartPickingFeedback is an Instance Action
			restricted
			Action Rules
				if (IsComponentTypeNotOffsite
				and PickedQuantity not entered)

					constraint (WarehouseDemandLineForProductionFeedbackRel exists)
						"WarehouseDemandLineDoesNotExist"

					if (PlanQuantity <= WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity)
						PickedQuantity         = PlanQuantity
						LocalPrintedQuantity   = PlanQuantity
					else
						PickedQuantity         = WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity
						LocalPrintedQuantity   = WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity

					invoke UpdateWarehouseDemandLine WarehouseDemandLineForProductionFeedbackRel
						invoked.PrmPrintedQuantity += LocalPrintedQuantity

					if (Item.CatchWeightCode.ReceiptRequiresBoth)
						LocalInputQuantity = PickedQuantity
						include ConversionOfQuantityAndCostFromSecondaryToStock
						CatchWeightQuantity = LocalOutputQuantity


		DeletePickingFeedback is an Instance Action
			restricted
			Action Rules
				constraint (WorkOrderItemBinLotSerialRel not exists)
					"DetailsMustBeDeletedPriorToFeedbackDelete"

				if (PickedQuantity > 0)
					if (PickedQuantity > PlanQuantity)
						LocalPlanQuantity = PlanQuantity - PickedQuantity
						invoke Update WarehouseDemandLineForProductionFeedbackRel                           
							invoked.Quantity								= LocalPlanQuantity
							invoked.PrintedQuantity							-= PickedQuantity
							invoked.Destination								= Location
							invoked.EstimatedTransactionDate				= current corporate date


					else
						invoke UpdateWarehouseDemandLine WarehouseDemandLineForProductionFeedbackRel
							invoked.PrmPrintedQuantity = PickedQuantity * -1

					initialize PickedQuantity
					initialize CatchWeightQuantity


		FinishPickingFeedback is an Instance Action
			restricted
			Action Rules
				if (IsComponentTypeNotOffsite)
					include ValidateMaterialExpenseAccountInProduction

				if (DetailTracked)
					constraint (WorkOrderItemBinLotSerialRel exists)
						"CannotFinish;DetailsOfComponent<WorkOrderItem>DoesNotExist"
					
					for each WorkOrderItemBinLotSerialRel
						if (Item.StockUOM = each.WorkOrderItemBinLotSerial.UnitOfMeasure
						or  Item.IsCatchWeightItem
						or	IsSerialTracked)
							if (each.Quantity entered)
								LocalDetailQuantity			+= each.Quantity
							else 
							if(each.ActualQuantity entered)
								LocalDetailQuantity 		+= each.ActualQuantity
							LocalCatchWeightQuantity 		+= each.CatchWeightQuantity
						else
							if (each.Quantity entered)
								LocalActualQuantity			= each.Quantity
							else 
							if(each.ActualQuantity entered)
								LocalActualQuantity 		= each.ActualQuantity
							LocalInputUOM			= each.WorkOrderItemBinLotSerial.UnitOfMeasure
							include ConvertQuantity
							LocalDetailQuantity		+= LocalOutputQuantity
				
					constraint (PlanQuantity = LocalDetailQuantity)
						"CannotFinish;PlanQuantityOfComponent<WorkOrderItem>DoesNotMatchDetailsQuantity"
						
					if (Item.IsCatchWeightItem 
					and !IsSerialTracked)
						constraint (LocalCatchWeightQuantity = CatchWeightQuantity)
							"CannotFinish;CatchWeightQuantityOfComponent<WorkOrderItem>DoesNotMatchDetailsCatchWeightQuantity"






				if (Item.CatchWeightCode.AllTransactionsRequireBoth                                         		
				or  Item.CatchWeightCode.IssueRequiresBoth)
					constraint (CatchWeightQuantity entered)
						"CatchWeightQuantityIsRequiredForCatchWeightItem<Item>"
						
				if (PickedQuantity > 0)                                                       
					constraint (WarehouseDemandLineForProductionFeedbackRel exists)
						"WarehouseDemandLineDoesNotExist"

					invoke UpdateWarehouseDemandLine WarehouseDemandLineForProductionFeedbackRel
						invoked.PrmInProcessQuantity      = PickedQuantity

					invoke UpdateQuantities ItemLocationRel
						invoked.PrmInProcessQuantity      = PickedQuantity
						invoked.PrmAllocatedQuantity	  = PickedQuantity * -1
					

		DeleteWarehouseDemandLineForDemand is an Instance Action
			restricted
			Action Rules
				if (WarehouseDemandLineForProductionFeedbackRel exists)
					invoke Delete WarehouseDemandLineForProductionFeedbackRel


		StartProductionFeedback is an Instance Action
			restricted
			Action Rules
				if (!ComponentType.Offsite)
					if (PickedQuantity >= PlanQuantity)
						ActualQuantity	= PickedQuantity
					else
						if (PickedQuantity > WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity)
							ActualQuantity	= PickedQuantity
						else
							ActualQuantity	= WarehouseDemandLineForProductionFeedbackRel.AllocatedQuantity

					if (ActualQuantity > PickedQuantity)
						LocalPrintedQuantity = ActualQuantity - PickedQuantity
						if (LocalPrintedQuantity entered)
							invoke UpdateWarehouseDemandLine WarehouseDemandLineForProductionFeedbackRel
								invoked.PrmPrintedQuantity = LocalPrintedQuantity

					initialize InventoryCostDefault
					InventoryCostDefault.InCompany 				= Company
					InventoryCostDefault.InInventoryLocation 	= InventoryLocation
					InventoryCostDefault.InItem 				= Item
					InventoryCostDefault.InQuantity 			= ActualQuantity

					if (InventoryCostDefault.DefaultInventoryCost entered)
						ActualComponentCost						= InventoryCostDefault.DefaultInventoryCost
					else
						ActualComponentCost						= EstimatedComponentCost

					if (Item.CatchWeightCode.ReceiptRequiresBoth)
						LocalInputQuantity = ActualQuantity
						LocalInputCost = ActualComponentCost
						include ConversionOfQuantityAndCostFromSecondaryToStock
						ActualCatchWeightQuantity	= LocalOutputQuantity

					if (Item.IsCatchWeightItem)
						LocalInputQuantity = ActualQuantity
						LocalInputCost 	   = ActualComponentCost
						include ConversionOfQuantityAndCostFromSecondaryToStock
						LocalActualCost  = LocalOutputQuantity * ActualComponentCost
					else
						LocalActualCost  = ActualQuantity * ActualComponentCost

					include UpdateWorkOrderActualComponentCost
					
					invoke UpdateActualQuantityFromWorkOrderItem WorkOrderItemBinLotSerialRel
									

		DeleteProductionFeedback is an Instance Action
			restricted
			Action Rules
				if (PlanQuantity >= PickedQuantity)
					if ((ActualQuantity + WasteQuantity) > PlanQuantity)
						LocalPlanQuantity = (PlanQuantity - (ActualQuantity + WasteQuantity))
						LocalPrintChange  = (PickedQuantity - (ActualQuantity + WasteQuantity))

				else
					if ((ActualQuantity + WasteQuantity) > PickedQuantity)
						LocalPlanQuantity = (PickedQuantity - (ActualQuantity + WasteQuantity))
						LocalPrintChange  = (PickedQuantity - (ActualQuantity + WasteQuantity))




				if (LocalPlanQuantity entered)
					invoke Update WarehouseDemandLineForProductionFeedbackRel
						invoked.Quantity								= LocalPlanQuantity
						invoked.PrintedQuantity							= LocalPrintChange
						invoked.AllocationDate							= current corporate date


				else
					if ((ActualQuantity + WasteQuantity) > PickedQuantity)
						invoke UpdateWarehouseDemandLine WarehouseDemandLineForProductionFeedbackRel
							invoked.PrmPrintedQuantity = (PickedQuantity - (ActualQuantity + WasteQuantity))

				initialize ActualQuantity
				initialize ActualCatchWeightQuantity
				initialize WasteQuantity
				initialize WasteCatchWeightQuantity
				initialize ActualComponentCost

				invoke UpdateAllocatedFromWorkOrder WorkOrderItemBinLotSerialRel

		FinishProductionFeedback is an Instance Action
			restricted
			Action Rules
				if (DetailTracked)
					constraint (WorkOrderItemBinLotSerialRel exists)
						"CannotFinish;DetailsOfComponent<WorkOrderItem>DoesNotExist"

					for each WorkOrderItemBinLotSerialRel
						if (each.IsTrackedInAndAlternateStockUOM)
							LocalActualQuantity	 = each.ActualQuantity
							LocalInputUOM		 = each.WorkOrderItemBinLotSerial.UnitOfMeasure
							include ConvertQuantity
							LocalDetailQuantity += LocalOutputQuantity
						else
							LocalDetailQuantity	+= each.ActualQuantity
							
						LocalWasteQuantity  += each.WasteQuantity
					
					constraint (ActualQuantity = LocalDetailQuantity)
						"CannotFinish;ActualQuantityOfComponentDoesNotMatchDetailsActualQuantity"

					constraint (WasteQuantity = LocalWasteQuantity)
						"CannotFinish;WasteQuantityOfComponentDoesNotMatchDetailsWasteQuantity"

				if (Item.IsCatchWeightItem)
					constraint (ActualCatchWeightQuantity entered)
						"ActualCatchWeightQuantityIsRequiredForCatchWeightItem<Item>"

				if ((ActualQuantity + WasteQuantity) > PickedQuantity)
					if (PickedQuantity not entered)
						LocalInProcessQuantity = ActualQuantity + WasteQuantity
					else
						if ((ActualQuantity + WasteQuantity) > WasteQuantity)
							LocalInProcessQuantity = ActualQuantity + WasteQuantity - PickedQuantity

				if (LocalInProcessQuantity > 0)
					if (WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity entered)
						LocalBackorderedQuantity -= WarehouseDemandLineForProductionFeedbackRel.BackorderedQuantity

					invoke Update WarehouseDemandLineForProductionFeedbackRel
						invoked.BackorderedQuantity  = LocalBackorderedQuantity
						invoked.InProcessQuantity   += LocalInProcessQuantity

					invoke UpdateQuantities ItemLocationRel
						invoked.PrmInProcessQuantity 	= LocalInProcessQuantity
						invoked.PrmBackorderedQuantity  = LocalBackorderedQuantity

		ReverseWorkOrderItem is an Instance Action
			restricted
			Parameters
				PrmWorkOrder	is a WorkOrder

			Action Rules
				invoke Create WorkOrderItem
					assign result to NewWorkOrderItem
					fill in fields from this instance
					invoked.Company						= Company
					invoked.InventoryLocation			= InventoryLocation
					invoked.WorkOrder					= PrmWorkOrder
					invoked.LocalReverseByWorkOrder		= true
					invoked.PlanQuantity				= PlanQuantity * -1
					invoked.PickedQuantity				= PickedQuantity * -1
					invoked.CatchWeightQuantity			= CatchWeightQuantity * -1
					invoked.ActualQuantity				= ActualQuantity * -1
					invoked.ActualCatchWeightQuantity	= ActualCatchWeightQuantity * -1
					invoked.WasteQuantity				= WasteQuantity * -1
					invoked.WasteCatchWeightQuantity	= WasteCatchWeightQuantity * -1
					invoked.TotalActualCost				= TotalActualCost * -1
					invoked.TotalWasteCost				= TotalWasteCost * -1

				LocalWorkOrderItem           			= NewWorkOrderItem.WorkOrderItem

				if (DetailTracked)
					for each WorkOrderItemBinLotSerialRel
						invoke ReverseWorkOrderDetail each
							invoked.PrmWorkOrder				= PrmWorkOrder
							invoked.PrmItem						= Item
							invoked.PrmWorkOrderItem			= LocalWorkOrderItem

		CreateDistributions	is an Instance Action
			restricted
			Parameters
				PrmInventoryTransaction					is like InventoryTransaction

			Action Rules
				LocalInventoryTransaction	= PrmInventoryTransaction
				
				if (WorkOrder.OriginalWorkOrder not entered)
					invoke UpdateQuantities ItemLocationRel
						invoked.PrmInProcessQuantity      = PickedQuantity * -1
				if (ActualQuantity entered)
					if (WorkOrder.OriginalWorkOrder entered)
						LocalQuantity				= ((ActualQuantity + WasteQuantity) * -1)
					else
						LocalQuantity				= ActualQuantity + WasteQuantity
				else
					LocalQuantity					= PickedQuantity + WasteQuantity

				if (Item.IsCatchWeightItem)
					LocalSecondaryQuantity			= LocalQuantity
					initialize LocalQuantity
					if (ActualCatchWeightQuantity entered)
						LocalQuantity				= ActualCatchWeightQuantity
					else
						LocalQuantity				= CatchWeightQuantity

					if (WorkOrder.OriginalWorkOrder entered)
						LocalQuantity				= LocalQuantity * -1

				invoke Unreleased.Create InventoryTransactionLine
					assign result to NewInventoryTransactionLine
					fill in fields from this instance
					invoked.TransactionSystemCode 						= "WO"
					invoked.InventoryTransaction						= LocalInventoryTransaction
					invoked.OriginatingTransaction						= reference to this instance
					invoked.Quantity									= LocalQuantity
					if (ActualComponentCost entered)
						invoked.UnitCost								= ActualComponentCost
					else
						invoked.UnitCost								= EstimatedComponentCost
					invoked.OffsetAccount								= Location.WorkInProcessAccount
					invoked.KitType										= "S"
					invoked.TransactionUOM								= Item.StockUOM
					if (Item.IsCatchWeightItem)

						invoked.SecondaryUOM							= Item.SecondaryUOM
						invoked.SecondaryQuantity						= LocalSecondaryQuantity
					if (IsBinTracked)
						invoked.MultipleBins							= true

				LocalInventoryTransactionLine							= NewInventoryTransactionLine.InventoryTransactionLine.LineNumber
				PickedCost												= NewInventoryTransactionLine.UnitCost
				invoke CreateDistributions WorkOrderItemBinLotSerialRel
					invoked.PrmInventoryTransaction						= LocalInventoryTransaction
					invoked.PrmInventoryTransactionLine 				= LocalInventoryTransactionLine

				if (InventoryLocation.UseIncomeStatementAccounts)
					LocalPostingType 									= "IM"
					LocalDistributionAccount 							= MaterialExpenseAccount
					if (ActualQuantity entered)
						LocalAmount										= ActualQuantity * ActualComponentCost
					else
						LocalAmount										= PickedQuantity * EstimatedComponentCost
					include CreateDistributionsForIncomeAccounts

				if (WasteQuantity entered)
					LocalPostingType 									= "CW"
					LocalDistributionAccount 							= InventoryLocation.WorkInProcessAccount
					if (ActualComponentCost entered)
						LocalAmount										= WasteQuantity * ActualComponentCost
					else
						LocalAmount										= WasteQuantity * EstimatedComponentCost
					include CreateDistributionsForIncomeAccounts

					LocalPostingType 									= "CW"
					LocalDistributionAccount 							= InventoryLocation.WasteAccount
					if (ActualComponentCost entered)
						LocalAmount										= WasteQuantity * ActualComponentCost * -1
					else
						LocalAmount										= WasteQuantity * EstimatedComponentCost * -1
					include CreateDistributionsForIncomeAccounts

		WorkOrderItemStartProduction is an Instance Action
			restricted
			Action Rules

				if (!ItemLocationRel.BinTracked
				and ItemLocationRel.IsSerialTracked
				and !ItemLocationRel.IsLotTracked)
					if (ItemLocationRel.PreferredBin not entered)
						initialize LocalActualQuantity
						for each ItemSerialNumberRel
							LocalActualQuantity += 1
							invoke Create WorkOrderItemBinLotSerial
								invoked.Company									= Company
								invoked.InventoryLocation 						= InventoryLocation
								invoked.WorkOrder 								= WorkOrder
								invoked.WorkOrderItem							= WorkOrderItem
								invoked.WorkOrderItemBinLotSerial.DetailType 	= "C"
								invoked.WorkOrderItemBinLotSerial.Bin 			= ItemLocationRel.PreferredBin
								invoked.WorkOrderItemBinLotSerial.Serial        = each.ItemSerialNumber
								invoked.ActualQuantity							= ActualQuantity
								invoked.Item 									= Item
            				if (LocalActualQuantity > WorkOrder.ActualQuantity)
            					end for each
